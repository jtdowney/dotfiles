---
name: elixir
description: Elixir language
---

# Elixir Skill

Comprehensive assistance with elixir development, generated from official documentation.

## When to Use This Skill

This skill should be triggered when:
- Working with elixir
- Asking about elixir features or APIs
- Implementing elixir solutions
- Debugging elixir code
- Learning elixir best practices

## Quick Reference

### Common Patterns

**Pattern 1:** Elixir v1.19.0 Search documentation of Elixir Settings Kernel (Elixir v1.19.0) View Source Kernel is Elixir's default environment.It mainly consists of:basic language primitives, such as arithmetic operators, spawning of processes, data type handling, and othersmacros for control-flow and defining new functionality (modules, functions, and the like)guard checks for augmenting pattern matchingYou can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:iex> is_number(13) trueIf you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:import Kernel, except: [if: 2, is_number: 1]See import/2 for more information on importing.Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.The standard libraryKernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).Built-in typesThe following modules handle Elixir built-in data types:Atom - literal constants with a name (true, false, and nil are atoms)Float - numbers with floating point precisionFunction - a reference to code chunk, created with the fn/1 special formInteger - whole numbers (not fractions)List - collections of a variable number of elements (linked lists)Map - collections of key-value pairsProcess - light-weight threads of executionPort - mechanisms to interact with the external worldTuple - collections of a fixed number of elementsThere are two data types without an accompanying module:Bitstring - a sequence of bits, created with <<>>/1. When the number of bits is divisible by 8, they are called binaries and can be manipulated with Erlang's :binary moduleReference - a unique value in the runtime system, created with make_ref/0Data typesElixir also provides other data types that are built on top of the types listed above. Some of them are:Date - year-month-day structs in a given calendarDateTime - date and time with time zone in a given calendarException - data raised from errors and unexpected scenariosMapSet - unordered collections of unique elementsNaiveDateTime - date and time without time zone in a given calendarKeyword - lists of two-element tuples, often representing optional valuesRange - inclusive ranges between two integersRegex - regular expressionsString - UTF-8 encoded binaries representing charactersTime - hour:minute:second structs in a given calendarURI - representation of URIs that identify resourcesVersion - representation of versions and requirementsSystem modulesModules that interface with the underlying system, such as:IO - handles input and outputFile - interacts with the underlying file systemPath - manipulates file system pathsSystem - reads and writes system informationProtocolsProtocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:Collectable - collects data into a data typeEnumerable - handles collections in Elixir. The Enum module provides eager functions for working with collections, the Stream module provides lazy functionsInspect - converts data types into their programming language representationList.Chars - converts data types to their outside world representation as charlists (non-programming based)String.Chars - converts data types to their outside world representation as strings (non-programming based)Process-based and application-centric functionalityThe following modules build on top of processes to provide concurrency, fault-tolerance, and more.Agent - a process that encapsulates mutable stateApplication - functions for starting, stopping and configuring applicationsGenServer - a generic client-server APIRegistry - a key-value process-based storageSupervisor - a process that is responsible for starting, supervising and shutting down other processesTask - a process that performs computationsTask.Supervisor - a supervisor for managing tasks exclusivelySupporting documentsUnder the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:Compatibility and deprecations - lists compatibility between every Elixir version and Erlang/OTP, release schema; lists all deprecated functions, when they were deprecated and alternativesLibrary guidelines - general guidelines, anti-patterns, and rules for those writing librariesNaming conventions - naming conventions for Elixir codeOperators reference - lists all Elixir operators and their precedencesPatterns and guards - an introduction to patterns, guards, and extensionsSyntax reference - the language syntax referenceTypespecs reference- types and function specifications, including list of typesUnicode syntax - outlines Elixir support for UnicodeGuardsThis module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:def drive(%User{age: age}) when age >= 16 do ... endThe clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.Truthy and falsy valuesBesides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value. a value is truthy when it is neither false nor nil a value is falsy when it is either false or nilElixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.Structural comparisonThe functions in this module perform structural comparison. This allows different data types to be compared using comparison operators:1 < :an_atomThis is possible so Elixir developers can create collections, such as dictionaries and ordered sets, that store a mixture of data types in them. To understand why this matters, let's discuss the two types of comparisons we find in software: structural and semantic.Structural means we are comparing the underlying data structures and we often want those operations to be as fast as possible, because it is used to power several algorithms and data structures in the language. A semantic comparison worries about what each data type represents. For example, semantically speaking, it doesn't make sense to compare Time with Date.One example that shows the differences between structural and semantic comparisons are strings: "alien" sorts less than "office" ("alien" < "office") but "álien" is greater than "office". This happens because < compares the underlying bytes that form the string. If you were doing alphabetical listing, you may want "álien" to also appear before "office".This means comparisons in Elixir are structural, as it has the goal of comparing data types as efficiently as possible to create flexible and performant data structures. This distinction is specially important for functions that provide ordering, such as >/2, </2, >=/2, <=/2, min/2, and max/2. For example:~D[2017-03-31] > ~D[2017-04-01]will return true because structural comparison compares the :day field before :month or :year. Luckily, the Elixir compiler will detect whenever comparing structs or whenever comparing code that is either always true or false, and emit a warning accordingly.In order to perform semantic comparisons, the relevant data-types provide a compare/2 function, such as Date.compare/2:iex> Date.compare(~D[2017-03-31], ~D[2017-04-01]) :ltAlternatively, you can use the functions in the Enum module to sort or compute a maximum/minimum:iex> Enum.sort([~D[2017-03-31], ~D[2017-04-01]], Date) [~D[2017-03-31], ~D[2017-04-01]] iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date) ~D[2017-04-01]The second argument is precisely the module to be used for semantic comparison. Keeping this distinction is important, because if semantic comparison was used by default for implementing data structures and algorithms, they could become orders of magnitude slower!Finally, note there is an overall structural sorting order, called "Term Ordering", defined below. This order is provided for reference purposes, it is not required for Elixir developers to know it by heart.Term orderingnumber < atom < reference < function < port < pid < tuple < map < list < bitstringWhen comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either ===/2 or !==/2. A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive.The collection types are compared using the following rules:Tuples are compared by size, then element by element.Maps are compared by size, then by key-value pairs.Lists are compared element by element.Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit.Atoms are compared using their string value, codepoint by codepoint.ExamplesWe can check the truthiness of a value by using the !/1 function twice.Truthy values:iex> !!true true iex> !!5 true iex> !![1,2] true iex> !!"foo" trueFalsy values (of which there are exactly two):iex> !!false false iex> !!nil falseInliningSome of the functions described in this module are inlined by the Elixir compiler into their Erlang counterparts in the :erlang module. Those functions are called BIFs (built-in internal functions) in Erlang-land and they exhibit interesting properties, as some of them are allowed in guards and others are used for compiler optimizations.Most of the inlined functions can be seen in effect when capturing the function:iex> &Kernel.is_atom/1 &:erlang.is_atom/1Those functions will be explicitly marked in their docs as "inlined by the compiler". Summary Guards left * right Arithmetic multiplication operator. +value Arithmetic positive unary operator. left + right Arithmetic addition operator. -value Arithmetic negative unary operator. left - right Arithmetic subtraction operator. left / right Arithmetic division operator. left != right Not equal to operator. left !== right Strictly not equal to operator. left < right Less-than operator. left <= right Less-than or equal to operator. left == right Equal to operator. Returns true if the two terms are equal. left === right Strictly equal to operator. left > right Greater-than operator. left >= right Greater-than or equal to operator. abs(number) Returns an integer or float which is the arithmetical absolute value of number. left and right Strictly boolean "and" operator. binary_part(binary, start, size) Extracts the part of the binary at start with size. bit_size(bitstring) Returns an integer which is the size in bits of bitstring. byte_size(bitstring) Returns the number of bytes needed to contain bitstring. ceil(number) Returns the smallest integer greater than or equal to number. div(dividend, divisor) Performs an integer division. elem(tuple, index) Gets the element at the zero-based index in tuple. floor(number) Returns the largest integer smaller than or equal to number. hd(list) Returns the head of a list. Raises ArgumentError if the list is empty. left in right Membership operator. is_atom(term) Returns true if term is an atom, otherwise returns false. is_binary(term) Returns true if term is a binary, otherwise returns false. is_bitstring(term) Returns true if term is a bitstring (including a binary), otherwise returns false. is_boolean(term) Returns true if term is either the atom true or the atom false (i.e., a boolean), otherwise returns false. is_exception(term) Returns true if term is an exception, otherwise returns false. is_exception(term, name) Returns true if term is an exception of name, otherwise returns false. is_float(term) Returns true if term is a floating-point number, otherwise returns false. is_function(term) Returns true if term is a function, otherwise returns false. is_function(term, arity) Returns true if term is a function that can be applied with arity number of arguments; otherwise returns false. is_integer(term) Returns true if term is an integer, otherwise returns false. is_list(term) Returns true if term is a list with zero or more elements, otherwise returns false. is_map(term) Returns true if term is a map, otherwise returns false. is_map_key(map, key) Returns true if key is a key in map, otherwise returns false. is_nil(term) Returns true if term is nil, false otherwise. is_non_struct_map(term) Returns true if term is a map that is not a struct, otherwise returns false. is_number(term) Returns true if term is either an integer or a floating-point number; otherwise returns false. is_pid(term) Returns true if term is a PID (process identifier), otherwise returns false. is_port(term) Returns true if term is a port identifier, otherwise returns false. is_reference(term) Returns true if term is a reference, otherwise returns false. is_struct(term) Returns true if term is a struct, otherwise returns false. is_struct(term, name) Returns true if term is a struct of name, otherwise returns false. is_tuple(term) Returns true if term is a tuple, otherwise returns false. length(list) Returns the length of list. map_size(map) Returns the size of a map. max(first, second) Returns the biggest of the two given terms according to their structural comparison. min(first, second) Returns the smallest of the two given terms according to their structural comparison. node() Returns an atom representing the name of the local node. If the node is not alive, :nonode@nohost is returned instead. node(arg) Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, :nonode@nohost is returned. not value Strictly boolean "not" operator. left or right Strictly boolean "or" operator. rem(dividend, divisor) Computes the remainder of an integer division. round(number) Rounds a number to the nearest integer. self() Returns the PID (process identifier) of the calling process. tl(list) Returns the tail of a list. Raises ArgumentError if the list is empty. trunc(number) Returns the integer part of number. tuple_size(tuple) Returns the size of a tuple. Functions left && right Boolean "and" operator. base ** exponent Power operator. left ++ right List concatenation operator. Concatenates a proper list and a term, returning a list. left -- right List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right. .. Creates the full-slice range 0..-1//1. first..last Creates a range from first to last. first..last//step Creates a range from first to last with step. !value Boolean "not" operator. left <> right Binary concatenation operator. Concatenates two binaries. left =~ right Text-based match operator. Matches the string on the left against the regular expression or string on the right. @expr Module attribute unary operator. alias!(alias) When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded. apply(fun, args) Invokes the given anonymous function fun with the list of arguments args. apply(module, function_name, args) Invokes the given function from module with the list of arguments args. binary_slice(binary, range) Returns a binary from the offset given by the start of the range to the offset given by the end of the range. binary_slice(binary, start, size) Returns a binary starting at the offset start and of the given size. binding(context \\ nil) Returns the binding for the given context as a keyword list. dbg(code \\ quote do binding() end, options \\ []) Debugs the given code. def(call, expr \\ nil) Defines a public function with the given name and body. defdelegate(funs, opts) Defines a function that delegates to another module. defexception(fields) Defines an exception. defguard(guard) Defines a macro suitable for use in guard expressions. defguardp(guard) Defines a private macro suitable for use in guard expressions. defimpl(name, opts, do_block \\ []) Defines an implementation for the given protocol. defmacro(call, expr \\ nil) Defines a public macro with the given name and body. defmacrop(call, expr \\ nil) Defines a private macro with the given name and body. defmodule(alias, do_block) Defines a module given by name with the given contents. defoverridable(keywords_or_behaviour) Makes the given definitions in the current module overridable. defp(call, expr \\ nil) Defines a private function with the given name and body. defprotocol(name, do_block) Defines a protocol. defstruct(fields) Defines a struct. destructure(left, right) Destructures two lists, assigning each term in the right one to the matching term in the left one. exit(reason) Stops the execution of the calling process with the given reason. function_exported?(module, function, arity) Returns true if module is loaded and contains a public function with the given arity, otherwise false. get_and_update_in(path, fun) Gets a value and updates a nested data structure via the given path. get_and_update_in(data, keys, fun) Gets a value and updates a nested structure. get_in(path) Gets a key from the nested structure via the given path, with nil-safe handling. get_in(data, keys) Gets a value from a nested structure with nil-safe handling. if(condition, clauses) Provides an if/2 macro. inspect(term, opts \\ []) Inspects the given argument according to the Inspect protocol. The second argument is a keyword list with options to control inspection. macro_exported?(module, macro, arity) Returns true if module is loaded and contains a public macro with the given arity, otherwise false. make_ref() Returns an almost unique reference. match?(pattern, expr) A convenience macro that checks if the right side (an expression) matches the left side (a pattern). pop_in(path) Pops a key from the nested structure via the given path. pop_in(data, keys) Pops a key from the given nested structure. put_elem(tuple, index, value) Puts value at the given zero-based index in tuple. put_in(path, value) Puts a value in a nested structure via the given path. put_in(data, keys, value) Puts a value in a nested structure. raise(message) Raises an exception. raise(exception, attributes) Raises an exception. reraise(message, stacktrace) Raises an exception preserving a previous stacktrace. reraise(exception, attributes, stacktrace) Raises an exception preserving a previous stacktrace. send(dest, message) Sends a message to the given dest and returns the message. sigil_C(term, modifiers) Handles the sigil ~C for charlists. sigil_c(term, modifiers) Handles the sigil ~c for charlists. sigil_D(date_string, modifiers) Handles the sigil ~D for dates. sigil_N(naive_datetime_string, modifiers) Handles the sigil ~N for naive date times. sigil_r(term, modifiers) Handles the sigil ~r for regular expressions. sigil_S(term, modifiers) Handles the sigil ~S for strings. sigil_s(term, modifiers) Handles the sigil ~s for strings. sigil_T(time_string, modifiers) Handles the sigil ~T for times. sigil_U(datetime_string, modifiers) Handles the sigil ~U to create a UTC DateTime. sigil_W(term, modifiers) Handles the sigil ~W for list of words. sigil_w(term, modifiers) Handles the sigil ~w for list of words. spawn(fun) Spawns the given function and returns its PID. spawn(module, fun, args) Spawns the given function fun from the given module passing it the given args and returns its PID. spawn_link(fun) Spawns the given function, links it to the current process, and returns its PID. spawn_link(module, fun, args) Spawns the given function fun from the given module passing it the given args, links it to the current process, and returns its PID. spawn_monitor(fun) Spawns the given function, monitors it and returns its PID and monitoring reference. spawn_monitor(module, fun, args) Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference. struct(struct, fields \\ []) Creates and updates a struct. struct!(struct, fields \\ []) Similar to struct/2 but checks for key validity. tap(value, fun) Pipes the first argument, value, into the second argument, a function fun, and returns value itself. then(value, fun) Pipes the first argument, value, into the second argument, a function fun, and returns the result of calling fun. throw(term) A non-local return from a function. to_charlist(term) Converts the given term to a charlist according to the List.Chars protocol. to_string(term) Converts the argument to a string according to the String.Chars protocol. to_timeout(duration) Constructs a millisecond timeout from the given components, duration, or timeout. unless(condition, clauses) deprecated Provides an unless macro. update_in(path, fun) Updates a nested structure via the given path. update_in(data, keys, fun) Updates a key in a nested structure. use(module, opts \\ []) Uses the given module in the current context. var!(var, context \\ nil) Marks that the given variable should not be hygienized. left |> right Pipe operator. left || right Boolean "or" operator. Guards left * right @spec integer() * integer() :: integer() @spec float() * float() :: float() @spec integer() * float() :: float() @spec float() * integer() :: float() Arithmetic multiplication operator.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 * 2 2 +value @spec +integer() :: integer() @spec +float() :: float() Arithmetic positive unary operator.Allowed in guard tests. Inlined by the compiler.Examplesiex> +1 1 left + right @spec integer() + integer() :: integer() @spec float() + float() :: float() @spec integer() + float() :: float() @spec float() + integer() :: float() Arithmetic addition operator.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 + 2 3 -value @spec -0 :: 0 @spec -pos_integer() :: neg_integer() @spec -neg_integer() :: pos_integer() @spec -float() :: float() Arithmetic negative unary operator.Allowed in guard tests. Inlined by the compiler.Examplesiex> -2 -2 left - right @spec integer() - integer() :: integer() @spec float() - float() :: float() @spec integer() - float() :: float() @spec float() - integer() :: float() Arithmetic subtraction operator.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 - 2 -1 left / right @spec number() / number() :: float() Arithmetic division operator.The result is always a float. Use div/2 and rem/2 if you want an integer division or the remainder.Raises ArithmeticError if right is 0 or 0.0.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 / 2 0.5 iex> -3.0 / 2.0 -1.5 iex> 5 / 1 5.0 7 / 0 ** (ArithmeticError) bad argument in arithmetic expression left != right @spec term() != term() :: boolean() Not equal to operator.Returns true if the two terms are not equal.This operator considers 1 and 1.0 to be equal. For match comparison, use !==/2 instead.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 != 2 true iex> 1 != 1.0 false left !== right @spec term() !== term() :: boolean() Strictly not equal to operator.Returns true if the two terms are not exactly equal. See ===/2 for a definition of what is considered "exactly equal".This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 !== 2 true iex> 1 !== 1.0 true left < right @spec term() < term() :: boolean() Less-than operator.Returns true if left is less than right.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 < 2 true left <= right @spec term() <= term() :: boolean() Less-than or equal to operator.Returns true if left is less than or equal to right.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 <= 2 true left == right @spec term() == term() :: boolean() Equal to operator. Returns true if the two terms are equal.This operator considers 1 and 1.0 to be equal. For stricter semantics, use ===/2 instead.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 == 2 false iex> 1 == 1.0 true left === right @spec term() === term() :: boolean() Strictly equal to operator.Returns true if the two terms are exactly equal.The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, 1 == 1.0 returns true, but since they are of different types, 1 === 1.0 returns false.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 === 2 false iex> 1 === 1.0 false left > right @spec term() > term() :: boolean() Greater-than operator.Returns true if left is more than right.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 > 2 false left >= right @spec term() >= term() :: boolean() Greater-than or equal to operator.Returns true if left is more than or equal to right.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> 1 >= 2 false abs(number) @spec abs(number()) :: number() Returns an integer or float which is the arithmetical absolute value of number.Allowed in guard tests. Inlined by the compiler.Examplesiex> abs(-3.33) 3.33 iex> abs(-3) 3 left and right (macro) Strictly boolean "and" operator.If left is false, returns false, otherwise returns right.Requires only the left operand to be a boolean since it short-circuits. If the left operand is not a boolean, a BadBooleanError exception is raised.Allowed in guard tests.Examplesiex> true and false false iex> true and "yay!" "yay!" iex> "yay!" and true ** (BadBooleanError) expected a boolean on left-side of "and", got: "yay!" binary_part(binary, start, size) @spec binary_part(binary(), non_neg_integer(), integer()) :: binary() Extracts the part of the binary at start with size.If start or size reference in any way outside the binary, an ArgumentError exception is raised.Allowed in guard tests. Inlined by the compiler.Examplesiex> binary_part("foo", 1, 2) "oo"A negative size can be used to extract bytes that come before the byte at start:iex> binary_part("Hello", 5, -3) "llo"An ArgumentError is raised when the size is outside of the binary:binary_part("Hello", 0, 10) ** (ArgumentError) argument error bit_size(bitstring) @spec bit_size(bitstring()) :: non_neg_integer() Returns an integer which is the size in bits of bitstring.Allowed in guard tests. Inlined by the compiler.Examplesiex> bit_size(<<433::16, 3::3>>) 19 iex> bit_size(<<1, 2, 3>>) 24 byte_size(bitstring) @spec byte_size(bitstring()) :: non_neg_integer() Returns the number of bytes needed to contain bitstring.That is, if the number of bits in bitstring is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.Allowed in guard tests. Inlined by the compiler.Examplesiex> byte_size(<<433::16, 3::3>>) 3 iex> byte_size(<<1, 2, 3>>) 3 ceil(number) (since 1.8.0) @spec ceil(number()) :: integer() Returns the smallest integer greater than or equal to number.If you want to perform ceil operation on other decimal places, use Float.ceil/2 instead.Allowed in guard tests. Inlined by the compiler.Examplesiex> ceil(10) 10 iex> ceil(10.1) 11 iex> ceil(-10.1) -10 div(dividend, divisor) @spec div(integer(), neg_integer() | pos_integer()) :: integer() Performs an integer division.Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0.div/2 performs truncated integer division. This means that the result is always rounded towards zero.If you want to perform floored integer division (rounding towards negative infinity), use Integer.floor_div/2 instead.Allowed in guard tests. Inlined by the compiler.Examplesiex> div(5, 2) 2 iex> div(6, -4) -1 iex> div(-99, 2) -49 div(100, 0) ** (ArithmeticError) bad argument in arithmetic expression elem(tuple, index) @spec elem(tuple(), non_neg_integer()) :: term() Gets the element at the zero-based index in tuple.It raises ArgumentError when index is negative or it is out of range of the tuple elements.Allowed in guard tests. Inlined by the compiler.Examplesiex> tuple = {:foo, :bar, 3} iex> elem(tuple, 1) :bar elem({}, 0) ** (ArgumentError) argument error elem({:foo, :bar}, 2) ** (ArgumentError) argument error floor(number) (since 1.8.0) @spec floor(number()) :: integer() Returns the largest integer smaller than or equal to number.If you want to perform floor operation on other decimal places, use Float.floor/2 instead.Allowed in guard tests. Inlined by the compiler.Examplesiex> floor(10) 10 iex> floor(9.7) 9 iex> floor(-9.7) -10 hd(list) @spec hd(nonempty_maybe_improper_list(elem, term())) :: elem when elem: term() Returns the head of a list. Raises ArgumentError if the list is empty.The head of a list is its first element.It works with improper lists.Allowed in guard tests. Inlined by the compiler.Examplesiex> hd([1, 2, 3, 4]) 1 iex> hd([1 | 2]) 1Giving it an empty list raises:hd([]) ** (ArgumentError) argument error left in right (macro) Membership operator.Checks if the element on the left-hand side is a member of the collection on the right-hand side.Examplesiex> x = 1 iex> x in [1, 2, 3] trueThis operator (which is a macro) simply translates to a call to Enum.member?/2. The example above would translate to:Enum.member?([1, 2, 3], x)Elixir also supports left not in right, which evaluates to not(left in right):iex> x = 1 iex> x not in [1, 2, 3] falseGuardsThe in/2 operator (as well as not in) can be used in guard clauses as long as the right-hand side is a range or a list.If the right-hand side is a list, Elixir will expand the operator to a valid guard expression which needs to check each value. For example:when x in [1, 2, 3]translates to:when x === 1 or x === 2 or x === 3However, this construct will be inefficient for large lists. In such cases, it is best to stop using guards and use a more appropriate data structure, such as MapSet.If the right-hand side is a range, a more efficient comparison check will be done. For example:when x in 1..1000translates roughly to:when x >= 1 and x <= 1000AST considerationsleft not in right is parsed by the compiler into the AST:{:not, _, [{:in, _, [left, right]}]}This is the same AST as not(left in right).Additionally, Macro.to_string/2 and Code.format_string!/2 will translate all occurrences of this AST to left not in right. is_atom(term) @spec is_atom(term()) :: boolean() Returns true if term is an atom, otherwise returns false.Note true, false, and nil are atoms in Elixir, as well as module names. Therefore this function will return true to all of those values.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_atom(:name) true iex> is_atom(false) true iex> is_atom(AnAtom) true iex> is_atom("string") false is_binary(term) @spec is_binary(term()) :: boolean() Returns true if term is a binary, otherwise returns false.A binary always contains a complete number of bytes.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_binary("foo") true iex> is_binary(<<1::3>>) false is_bitstring(term) @spec is_bitstring(term()) :: boolean() Returns true if term is a bitstring (including a binary), otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_bitstring("foo") true iex> is_bitstring(<<1::3>>) true is_boolean(term) @spec is_boolean(term()) :: boolean() Returns true if term is either the atom true or the atom false (i.e., a boolean), otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_boolean(false) true iex> is_boolean(true) true iex> is_boolean(:test) false is_exception(term) (since 1.11.0) (macro) Returns true if term is an exception, otherwise returns false.Allowed in guard tests.Examplesiex> is_exception(%RuntimeError{}) true iex> is_exception(%{}) false is_exception(term, name) (since 1.11.0) (macro) Returns true if term is an exception of name, otherwise returns false.Allowed in guard tests.Examplesiex> is_exception(%RuntimeError{}, RuntimeError) true iex> is_exception(%RuntimeError{}, Macro.Env) false is_float(term) @spec is_float(term()) :: boolean() Returns true if term is a floating-point number, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_float(2.15) true iex> is_float(3.45e5) true iex> is_float(5) false is_function(term) @spec is_function(term()) :: boolean() Returns true if term is a function, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_function(fn x -> x + x end) true iex> is_function("not a function") false is_function(term, arity) @spec is_function(term(), non_neg_integer()) :: boolean() Returns true if term is a function that can be applied with arity number of arguments; otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_function(fn x -> x * 2 end, 1) true iex> is_function(fn x -> x * 2 end, 2) false is_integer(term) @spec is_integer(term()) :: boolean() Returns true if term is an integer, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_integer(5) true iex> is_integer(5.0) false is_list(term) @spec is_list(term()) :: boolean() Returns true if term is a list with zero or more elements, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_list([1, 2, 3]) true iex> is_list(key: :sum, value: 3) true iex> is_list({1, 2, 3}) false is_map(term) @spec is_map(term()) :: boolean() Returns true if term is a map, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Structs are mapsStructs are also maps, and many of Elixir data structures are implemented using structs: Ranges, Regexes, Dates...iex> is_map(1..10) true iex> is_map(~D[2024-04-18]) trueIf you mean to specifically check for non-struct maps, use is_non_struct_map/1 instead.iex> is_non_struct_map(1..10) false is_map_key(map, key) (since 1.10.0) @spec is_map_key(map(), term()) :: boolean() Returns true if key is a key in map, otherwise returns false.It raises BadMapError if the first element is not a map.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_map_key(%{a: "foo", b: "bar"}, :a) true iex> is_map_key(%{a: "foo", b: "bar"}, :c) false is_nil(term) (macro) Returns true if term is nil, false otherwise.Allowed in guard clauses.Examplesiex> is_nil(1 + 2) false iex> is_nil(nil) true is_non_struct_map(term) (since 1.17.0) (macro) Returns true if term is a map that is not a struct, otherwise returns false.Allowed in guard tests.Examplesiex> is_non_struct_map(%{}) true iex> is_non_struct_map(URI.parse("/")) false iex> is_non_struct_map(nil) false is_number(term) @spec is_number(term()) :: boolean() Returns true if term is either an integer or a floating-point number; otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_number(2.15) true iex> is_number(5) true iex> is_number(:one) false is_pid(term) @spec is_pid(term()) :: boolean() Returns true if term is a PID (process identifier), otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> {:ok, agent_pid} = Agent.start_link(fn -> 0 end) iex> is_pid(agent_pid) true iex> is_pid(self()) true iex> is_pid(:pid) false is_port(term) @spec is_port(term()) :: boolean() Returns true if term is a port identifier, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> [port | _] = Port.list() iex> is_port(port) true iex> is_port(:port) false is_reference(term) @spec is_reference(term()) :: boolean() Returns true if term is a reference, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> ref = make_ref() iex> is_reference(ref) true iex> is_reference(:ref) false is_struct(term) (since 1.10.0) (macro) Returns true if term is a struct, otherwise returns false.Allowed in guard tests.Examplesiex> is_struct(URI.parse("/")) true iex> is_struct(%{}) false is_struct(term, name) (since 1.11.0) (macro) Returns true if term is a struct of name, otherwise returns false.is_struct/2 does not check that name exists and is a valid struct. If you want such validations, you must pattern match on the struct instead, such as match?(%URI{}, arg).Allowed in guard tests.Examplesiex> is_struct(URI.parse("/"), URI) true iex> is_struct(URI.parse("/"), Macro.Env) false is_tuple(term) @spec is_tuple(term()) :: boolean() Returns true if term is a tuple, otherwise returns false.Allowed in guard tests. Inlined by the compiler.Examplesiex> is_tuple({1, 2, 3}) true iex> is_tuple({}) true iex> is_tuple(true) false length(list) @spec length(list()) :: non_neg_integer() Returns the length of list.Allowed in guard tests. Inlined by the compiler.Examplesiex> length([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 map_size(map) @spec map_size(map()) :: non_neg_integer() Returns the size of a map.The size of a map is the number of key-value pairs that the map contains.This operation happens in constant time.Allowed in guard tests. Inlined by the compiler.Examplesiex> map_size(%{a: "foo", b: "bar"}) 2 max(first, second) @spec max(first, second) :: first | second when first: term(), second: term() Returns the biggest of the two given terms according to their structural comparison.If the terms compare equal, the first one is returned.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> max(1, 2) 2 iex> max("a", "b") "b" min(first, second) @spec min(first, second) :: first | second when first: term(), second: term() Returns the smallest of the two given terms according to their structural comparison.If the terms compare equal, the first one is returned.This performs a structural comparison where all Elixir terms can be compared with each other. See the "Structural comparison" section for more information.Allowed in guard tests. Inlined by the compiler.Examplesiex> min(1, 2) 1 iex> min("foo", "bar") "bar" node() @spec node() :: node() Returns an atom representing the name of the local node. If the node is not alive, :nonode@nohost is returned instead.Allowed in guard tests. Inlined by the compiler. node(arg) @spec node(pid() | reference() | port()) :: node() Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, :nonode@nohost is returned.Allowed in guard tests. Inlined by the compiler. not value @spec not true :: false @spec not false :: true Strictly boolean "not" operator.value must be a boolean; if it's not, an ArgumentError exception is raised.Allowed in guard tests. Inlined by the compiler.Examplesiex> not false true left or right (macro) Strictly boolean "or" operator.If left is true, returns true, otherwise returns right.Requires only the left operand to be a boolean since it short-circuits. If the left operand is not a boolean, a BadBooleanError exception is raised.Allowed in guard tests.Examplesiex> true or false true iex> false or 42 42 iex> 42 or false ** (BadBooleanError) expected a boolean on left-side of "or", got: 42 rem(dividend, divisor) @spec rem(integer(), neg_integer() | pos_integer()) :: integer() Computes the remainder of an integer division.rem/2 uses truncated division, which means that the result will always have the sign of the dividend.Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0.Allowed in guard tests. Inlined by the compiler.Examplesiex> rem(5, 2) 1 iex> rem(6, -4) 2 round(number) @spec round(number()) :: integer() Rounds a number to the nearest integer.If the number is equidistant to the two nearest integers, rounds away from zero.Allowed in guard tests. Inlined by the compiler.Examplesiex> round(5.6) 6 iex> round(5.2) 5 iex> round(-9.9) -10 iex> round(-9) -9 iex> round(2.5) 3 iex> round(-2.5) -3 self() @spec self() :: pid() Returns the PID (process identifier) of the calling process.Allowed in guard clauses. Inlined by the compiler. tl(list) @spec tl(nonempty_maybe_improper_list(elem, last)) :: maybe_improper_list(elem, last) | last when elem: term(), last: term() Returns the tail of a list. Raises ArgumentError if the list is empty.The tail of a list is the list without its first element.It works with improper lists.Allowed in guard tests. Inlined by the compiler.Examplesiex> tl([1, 2, 3, :go]) [2, 3, :go] iex> tl([:one]) [] iex> tl([:a, :b | :improper_end]) [:b | :improper_end] iex> tl([:a | %{b: 1}]) %{b: 1}Giving it an empty list raises:tl([]) ** (ArgumentError) argument error trunc(number) @spec trunc(number()) :: integer() Returns the integer part of number.Allowed in guard tests. Inlined by the compiler.Examplesiex> trunc(5.4) 5 iex> trunc(-5.99) -5 iex> trunc(-5) -5 tuple_size(tuple) @spec tuple_size(tuple()) :: non_neg_integer() Returns the size of a tuple.This operation happens in constant time.Allowed in guard tests. Inlined by the compiler.Examplesiex> tuple_size({:a, :b, :c}) 3 Functions left && right (macro) Boolean "and" operator.Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to a truthy value (neither false nor nil). Returns the first expression otherwise.Not allowed in guard clauses.Examplesiex> Enum.empty?([]) && Enum.empty?([]) true iex> List.first([]) && true nil iex> Enum.empty?([]) && List.first([1]) 1 iex> false && throw(:bad) falseNote that, unlike and/2, this operator accepts any expression as the first argument, not only booleans. base ** exponent (since 1.13.0) @spec integer() ** non_neg_integer() :: integer() @spec integer() ** neg_integer() :: float() @spec float() ** float() :: float() @spec integer() ** float() :: float() @spec float() ** integer() :: float() Power operator.It takes two numbers for input. If both are integers and the right-hand side (the exponent) is also greater than or equal to 0, then the result will also be an integer. Otherwise it returns a float.Examplesiex> 2 ** 2 4 iex> 2 ** -4 0.0625 iex> 2.0 ** 2 4.0 iex> 2 ** 2.0 4.0 left ++ right @spec [] ++ a :: a when a: term() @spec [...] ++ term() :: maybe_improper_list() List concatenation operator. Concatenates a proper list and a term, returning a list.The complexity of a ++ b is proportional to length(a), so avoid repeatedly appending to lists of arbitrary length, for example, list ++ [element]. Instead, consider prepending via [element | rest] and then reversing.If the right operand is not a proper list, it returns an improper list. If the left operand is not a proper list, it raises ArgumentError. If the left operand is an empty list, it returns the right operand.Inlined by the compiler.Examplesiex> [1] ++ [2, 3] [1, 2, 3] iex> ~c"foo" ++ ~c"bar" ~c"foobar" # a non-list on the right will return an improper list # with said element at the end iex> [1, 2] ++ 3 [1, 2 | 3] iex> [1, 2] ++ {3, 4} [1, 2 | {3, 4}] # improper list on the right will return an improper list iex> [1] ++ [2 | 3] [1, 2 | 3] # empty list on the left will return the right operand iex> [] ++ 1 1The ++/2 operator is right associative, meaning:iex> [1, 2, 3] -- [1] ++ [2] [3]As it is equivalent to:iex> [1, 2, 3] -- ([1] ++ [2]) [3] left -- right @spec list() -- list() :: list() List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right.This function is optimized so the complexity of a -- b is proportional to length(a) * log(length(b)). See also the Erlang efficiency guide.Inlined by the compiler.Examplesiex> [1, 2, 3] -- [1, 2] [3] iex> [1, 2, 3, 2, 1] -- [1, 2, 2] [3, 1]The --/2 operator is right associative, meaning:iex> [1, 2, 3] -- [2] -- [3] [1, 3]As it is equivalent to:iex> [1, 2, 3] -- ([2] -- [3]) [1, 3] .. (since 1.14.0) (macro) Creates the full-slice range 0..-1//1.This macro returns a range with the following properties:When enumerated, it is emptyWhen used as a slice, it returns the sliced element as isSee ..///3 and the Range module for more information.Examplesiex> Enum.to_list(..) [] iex> String.slice("Hello world!", ..) "Hello world!" first..last (macro) Creates a range from first to last.If first is less than last, the range will be increasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.If first is more than last, the range will be decreasing from first to last, albeit this behavior is deprecated. Instead prefer to explicitly list the step with first..last//-1.See the Range module for more information.Examplesiex> 0 in 1..3 false iex> 2 in 1..3 true iex> Enum.to_list(1..3) [1, 2, 3] first..last//step (since 1.12.0) (macro) Creates a range from first to last with step.See the Range module for more information.Examplesiex> 0 in 1..3//1 false iex> 2 in 1..3//1 true iex> 2 in 1..3//2 false iex> Enum.to_list(1..3//1) [1, 2, 3] iex> Enum.to_list(1..3//2) [1, 3] iex> Enum.to_list(3..1//-1) [3, 2, 1] iex> Enum.to_list(1..0//1) [] !value (macro) Boolean "not" operator.Receives any value (not just booleans) and returns true if value is false or nil; returns false otherwise.Not allowed in guard clauses.Examplesiex> !Enum.empty?([]) false iex> !List.first([]) true left <> right (macro) Binary concatenation operator. Concatenates two binaries.Raises an ArgumentError if one of the sides aren't binaries.Examplesiex> "foo" <> "bar" "foobar"The <>/2 operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:iex> "foo" <> x = "foobar" iex> x "bar"x <> "bar" = "foobar" would result in an ArgumentError exception. left =~ right @spec String.t() =~ (String.t() | Regex.t()) :: boolean() Text-based match operator. Matches the string on the left against the regular expression or string on the right.If right is a regular expression, returns true if left matches right.If right is a string, returns true if left contains right.Examplesiex> "abcd" =~ ~r/c(d)/ true iex> "abcd" =~ ~r/e/ false iex> "abcd" =~ ~r// true iex> "abcd" =~ "bc" true iex> "abcd" =~ "ad" false iex> "abcd" =~ "abcd" true iex> "abcd" =~ "" trueFor more information about regular expressions, please check the Regex module. @expr (macro) Module attribute unary operator.Reads and writes attributes in the current module.The canonical example for attributes is annotating that a module implements an OTP behaviour, such as GenServer:defmodule MyServer do @behaviour GenServer # ... callbacks ... endBy default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well:defmodule MyServer do @my_data 13 IO.inspect(@my_data) #=> 13 endUnlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using Module.register_attribute/3.Prefixing module attributesLibraries and frameworks should consider prefixing any module attributes that are private by underscore, such as @_my_data, so code completion tools do not show them on suggestions and prompts.Finally, note that attributes can also be read inside functions:defmodule MyServer do @my_data 11 def first_data, do: @my_data @my_data 13 def second_data, do: @my_data end MyServer.first_data() #=> 11 MyServer.second_data() #=> 13It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the Module module for other functions to manipulate module attributes.Attention! Multiple references of the same attributeAs mentioned above, every time you read a module attribute, a snapshot of its current value is taken. Therefore, if you are storing large values inside module attributes (for example, embedding external files in module attributes), you should avoid referencing the same attribute multiple times. For example, don't do this:@files %{ example1: File.read!("lib/example1.data"), example2: File.read!("lib/example2.data") } def example1, do: @files[:example1] def example2, do: @files[:example2]In the above, each reference to @files may end-up with a complete and individual copy of the whole @files module attribute. Instead, reference the module attribute once in a private function:@files %{ example1: File.read!("lib/example1.data"), example2: File.read!("lib/example2.data") } defp files(), do: @files def example1, do: files()[:example1] def example2, do: files()[:example2] alias!(alias) (macro) When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.Check quote/2 for more information. apply(fun, args) @spec apply(fun(), [any()]) :: any() Invokes the given anonymous function fun with the list of arguments args.If the number of arguments is known at compile time, prefer fun.(arg_1, arg_2, ..., arg_n) as it is clearer than apply(fun, [arg_1, arg_2, ..., arg_n]).Inlined by the compiler.Examplesiex> apply(fn x -> x * 2 end, [2]) 4 apply(module, function_name, args) @spec apply(module(), function_name :: atom(), [any()]) :: any() Invokes the given function from module with the list of arguments args.apply/3 is used to invoke functions where the module, function name or arguments are defined dynamically at runtime. For this reason, you can't invoke macros using apply/3, only functions.If the number of arguments and the function name are known at compile time, prefer module.function(arg_1, arg_2, ..., arg_n) as it is clearer than apply(module, :function, [arg_1, arg_2, ..., arg_n]).apply/3 cannot be used to call private functions.Inlined by the compiler.Examplesiex> apply(Enum, :reverse, [[1, 2, 3]]) [3, 2, 1] binary_slice(binary, range) (since 1.14.0) Returns a binary from the offset given by the start of the range to the offset given by the end of the range.If the start or end of the range are negative, they are converted into positive indices based on the binary size. For example, -1 means the last byte of the binary.This is similar to binary_part/3 except that it works with ranges and it is not allowed in guards.This function works with bytes. For a slicing operation that considers characters, see String.slice/2.Examplesiex> binary_slice("elixir", 0..5) "elixir" iex> binary_slice("elixir", 1..3) "lix" iex> binary_slice("elixir", 1..10) "lixir" iex> binary_slice("elixir", -4..-1) "ixir" iex> binary_slice("elixir", -4..6) "ixir" iex> binary_slice("elixir", -10..10) "elixir"For ranges where start > stop, you need to explicitly mark them as increasing:iex> binary_slice("elixir", 2..-1//1) "ixir" iex> binary_slice("elixir", 1..-2//1) "lixi"You can use ../0 as a shortcut for 0..-1//1, which returns the whole binary as is:iex> binary_slice("elixir", ..) "elixir"The step can be any positive number. For example, to get every 2 characters of the binary:iex> binary_slice("elixir", 0..-1//2) "eii"If the first position is after the string ends or after the last position of the range, it returns an empty string:iex> binary_slice("elixir", 10..3//1) "" iex> binary_slice("elixir", -10..-7) "" iex> binary_slice("a", 1..1500) "" binary_slice(binary, start, size) (since 1.14.0) Returns a binary starting at the offset start and of the given size.This is similar to binary_part/3 except that if start + size is greater than the binary size, it automatically clips it to the binary size instead of raising. Opposite to binary_part/3, this function is not allowed in guards.This function works with bytes. For a slicing operation that considers characters, see String.slice/3.Examplesiex> binary_slice("elixir", 0, 6) "elixir" iex> binary_slice("elixir", 0, 5) "elixi" iex> binary_slice("elixir", 1, 4) "lixi" iex> binary_slice("elixir", 0, 10) "elixir"If start is negative, it is normalized against the binary size and clamped to 0:iex> binary_slice("elixir", -3, 10) "xir" iex> binary_slice("elixir", -10, 10) "elixir"If the size is zero, an empty binary is returned:iex> binary_slice("elixir", 1, 0) ""If start is greater than or equal to the binary size, an empty binary is returned:iex> binary_slice("elixir", 10, 10) "" binding(context \\ nil) (macro) Returns the binding for the given context as a keyword list.In the returned result, keys are variable names and values are the corresponding variable values.If the given context is nil (by default it is), the binding for the current context is returned.Examplesiex> x = 1 iex> binding() [x: 1] iex> x = 2 iex> binding() [x: 2] iex> binding(:foo) [] iex> var!(x, :foo) = 1 1 iex> binding(:foo) [x: 1] dbg(code \\ quote do binding() end, options \\ []) (since 1.14.0) (macro) Debugs the given code.dbg/2 can be used to debug the given code through a configurable debug function. It returns the result of the given code.ExamplesLet's take this call to dbg/2:dbg(Atom.to_string(:debugging)) #=> "debugging"It returns the string "debugging", which is the result of the Atom.to_string/1 call. Additionally, the call above prints:[my_file.ex:10: MyMod.my_fun/0] Atom.to_string(:debugging) #=> "debugging"The default debugging function prints additional debugging info when dealing with pipelines. It prints the values at every "step" of the pipeline."Elixir is cool!" |> String.trim_trailing("!") |> String.split() |> List.first() |> dbg() #=> "Elixir"The code above prints:[my_file.ex:10: MyMod.my_fun/0] "Elixir is cool!" #=> "Elixir is cool!" |> String.trim_trailing("!") #=> "Elixir is cool" |> String.split() #=> ["Elixir", "is", "cool"] |> List.first() #=> "Elixir"With no arguments, dbg() debugs information about the current binding. See binding/1.dbg inside IExYou can enable IEx to replace dbg with its IEx.pry/0 backend by calling:$ iex --dbg pry In such cases, dbg will start a pry session where you can interact with the imports, aliases, and variables of the current environment at the location of the dbg call.If you call dbg at the end of a pipeline (using |>) within IEx, you are able to go through each step of the pipeline one by one by entering "next" (or "n").Note dbg only supports stepping for pipelines (in other words, it can only step through the code it sees). For general stepping, you can set breakpoints using IEx.break!/4.For more information, see IEx documentation.Configuring the debug functionOne of the benefits of dbg/2 is that its debugging logic is configurable, allowing tools to extend dbg with enhanced behaviour. This is done, for example, by IEx which extends dbg with an interactive shell where you can directly inspect and access values.The debug function can be configured at compile time through the :dbg_callback key of the :elixir application. The debug function must be a {module, function, args} tuple. The function function in module will be invoked with three arguments prepended to args:The AST of codeThe AST of optionsThe Macro.Env environment of where dbg/2 is invokedThe debug function is invoked at compile time and it must also return an AST. The AST is expected to ultimately return the result of evaluating the debugged expression.Here's a simple example:defmodule MyMod do def debug_fun(code, options, caller, device) do quote do result = unquote(code) IO.inspect(unquote(device), result, label: unquote(Macro.to_string(code))) end end endTo configure the debug function:# In config/config.exs config :elixir, :dbg_callback, {MyMod, :debug_fun, [:stdio]}Default debug functionBy default, the debug function we use is Macro.dbg/3. It just prints information about the code to standard output and returns the value returned by evaluating code. options are used to control how terms are inspected. They are the same options accepted by inspect/2. def(call, expr \\ nil) (macro) Defines a public function with the given name and body.Examplesdefmodule Foo do def bar, do: :baz end Foo.bar() #=> :bazA function that expects arguments can be defined as follows:defmodule Foo do def sum(a, b) do a + b end endIn the example above, a sum/2 function is defined; this function receives two arguments and returns their sum.Default arguments\\ is used to specify a default value for a parameter of a function. For example:defmodule MyMath do def multiply_by(number, factor \\ 2) do number * factor end end MyMath.multiply_by(4, 3) #=> 12 MyMath.multiply_by(4) #=> 8The compiler translates this into multiple functions with different arities, here MyMath.multiply_by/1 and MyMath.multiply_by/2, that represent cases when arguments for parameters with default values are passed or not passed.When defining a function with default arguments as well as multiple explicitly declared clauses, you must write a function head that declares the defaults. For example:defmodule MyString do def join(string1, string2 \\ nil, separator \\ " ") def join(string1, nil, _separator) do string1 end def join(string1, string2, separator) do string1 <> separator <> string2 end endNote that \\ can't be used with anonymous functions because they can only have a sole arity.Keyword lists with default argumentsFunctions containing many arguments can benefit from using Keyword lists to group and pass attributes as a single value.defmodule MyConfiguration do @default_opts [storage: "local"] def configure(resource, opts \\ []) do opts = Keyword.merge(@default_opts, opts) storage = opts[:storage] # ... end endThe difference between using Map and Keyword to store many arguments is Keyword's keys:must be atomscan be given more than onceordered, as specified by the developerFunction namesFunction and variable names in Elixir must start with an underscore or a Unicode letter that is not in uppercase or titlecase. They may continue using a sequence of Unicode letters, numbers, and underscores. They may end in ? or !. Elixir's Naming Conventions suggest for function and variable names to be written in the snake_case format.rescue/catch/after/elseFunction bodies support rescue, catch, after, and else as try/1 does (known as "implicit try"). For example, the following two functions are equivalent:def convert(number) do try do String.to_integer(number) rescue e in ArgumentError -> {:error, e.message} end end def convert(number) do String.to_integer(number) rescue e in ArgumentError -> {:error, e.message} end defdelegate(funs, opts) (macro) Defines a function that delegates to another module.Functions defined with defdelegate/2 are public and can be invoked from outside the module they're defined in, as if they were defined using def/2. Therefore, defdelegate/2 is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use alias/2 to shorten the module name or use import/2 to be able to invoke the function without the module name altogether.Delegation only works with functions; delegating macros is not supported.Check def/2 for rules on naming and default arguments.Options:to - the module to dispatch to.:as - the function to call on the target given in :to. This parameter is optional and defaults to the name being delegated (funs).Examplesdefmodule MyList do defdelegate reverse(list), to: Enum defdelegate other_reverse(list), to: Enum, as: :reverse end MyList.reverse([1, 2, 3]) #=> [3, 2, 1] MyList.other_reverse([1, 2, 3]) #=> [3, 2, 1] defexception(fields) (macro) Defines an exception.Exceptions are structs backed by a module that implements the Exception behaviour. The Exception behaviour requires two functions to be implemented:exception/1 - receives the arguments given to raise/2 and returns the exception struct. The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message.message/1 - receives the exception struct and must return its message. Most commonly exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented.Since exceptions are structs, the API supported by defstruct/1 is also available in defexception/1.Raising exceptionsThe most common way to raise an exception is via raise/2:defmodule MyAppError do defexception [:message] end value = [:hello] raise MyAppError, message: "did not get what was expected, got: #{inspect(value)}"In many cases it is more convenient to pass the expected value to raise/2 and generate the message in the Exception.exception/1 callback:defmodule MyAppError do defexception [:message] @impl true def exception(value) do msg = "did not get what was expected, got: #{inspect(value)}" %MyAppError{message: msg} end end raise MyAppError, valueThe example above shows the preferred strategy for customizing exception messages. defguard(guard) (since 1.6.0) (macro) @spec defguard(Macro.t()) :: Macro.t() Defines a macro suitable for use in guard expressions.It raises at compile time if the guard uses expressions that aren't allowed in guard clauses, and otherwise creates a macro that can be used both inside or outside guards.When defining your own guards, consider the naming conventions around boolean-returning guards.Exampledefmodule Integer.Guards do defguard is_even(value) when is_integer(value) and rem(value, 2) == 0 end defmodule Collatz do @moduledoc "Tools for working with the Collatz sequence." import Integer.Guards @doc "Determines the number of steps `n` takes to reach `1`." # If this function never converges, please let me know what `n` you used. def converge(n) when n > 0, do: step(n, 0) defp step(1, step_count) do step_count end defp step(n, step_count) when is_even(n) do step(div(n, 2), step_count + 1) end defp step(n, step_count) do step(3 * n + 1, step_count + 1) end end defguardp(guard) (since 1.6.0) (macro) @spec defguardp(Macro.t()) :: Macro.t() Defines a private macro suitable for use in guard expressions.It raises at compile time if the guard uses expressions that aren't allowed in guard clauses, and otherwise creates a private macro that can be used both inside or outside guards in the current module.When defining your own guards, consider the naming conventions around boolean-returning guards.Similar to defmacrop/2, defguardp/1 must be defined before its use in the current module. defimpl(name, opts, do_block \\ []) (macro) Defines an implementation for the given protocol.See the Protocol module for more information. defmacro(call, expr \\ nil) (macro) Defines a public macro with the given name and body.Macros must be defined before its usage.Check def/2 for rules on naming and default arguments.Examplesdefmodule MyLogic do defmacro unless(expr, opts) do quote do if !unquote(expr), unquote(opts) end end end require MyLogic MyLogic.unless false do IO.puts("It works") end defmacrop(call, expr \\ nil) (macro) Defines a private macro with the given name and body.Private macros are only accessible from the same module in which they are defined.Private macros must be defined before its usage.Check defmacro/2 for more information, and check def/2 for rules on naming and default arguments. defmodule(alias, do_block) (macro) Defines a module given by name with the given contents.This macro defines a module with the given alias as its name and with the given contents. It returns a tuple with four elements::modulethe module namethe binary contents of the modulethe result of evaluating the contents blockExamplesdefmodule Number do def one, do: 1 def two, do: 2 end #=> {:module, Number, <<70, 79, 82, ...>>, {:two, 0}} Number.one() #=> 1 Number.two() #=> 2Module names and aliasesModule names (and aliases) must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Elixir's Naming Conventions suggest for module names and aliases to be written in the CamelCase format.You can also use atoms as the module name, although they must only contain ASCII characters.NestingNesting a module inside another module affects the name of the nested module:defmodule Foo do defmodule Bar do end endIn the example above, two modules - Foo and Foo.Bar - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module Foo.Bar to be accessed as Bar in the same lexical scope where it's defined (the Foo module). This only happens if the nested module is defined via an alias.If the Foo.Bar module is moved somewhere else, the references to Bar in the Foo module need to be updated to the fully-qualified name (Foo.Bar) or an alias has to be explicitly set in the Foo module with the help of alias/2.defmodule Foo.Bar do # code end defmodule Foo do alias Foo.Bar # code here can refer to "Foo.Bar" as just "Bar" endDynamic namesElixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:defmodule Module.concat(["Foo", "Bar"]) do # contents ... endElixir will accept any module name as long as the expression passed as the first argument to defmodule/2 evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias.Reserved module namesIf you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error:defmodule Any do # code end ** (CompileError) iex:1: module Any is reserved and cannot be definedElixir reserves the following module names: Elixir, Any, BitString, PID, and Reference. defoverridable(keywords_or_behaviour) (macro) Makes the given definitions in the current module overridable.If the user defines a new function or macro with the same name and arity, then the overridable ones are discarded. Otherwise, the original definitions are used.It is possible for the overridden definition to have a different visibility than the original: a public function can be overridden by a private function and vice-versa. Macros cannot be overridden as functions and vice-versa.Exampledefmodule DefaultMod do defmacro __using__(_opts) do quote do def test(x, y) do x + y end defoverridable test: 2 end end end defmodule ChildMod do use DefaultMod def test(x, y) do x * y + super(x, y) end endAs seen as in the example above, super can be used to call the default implementation.Example with behaviourdefoverridable is commonly used with behaviours. The behaviours use @callback definitions to define the general module API and the __using__ callback is used to define default implementations of functions, which can then be overridable.For convenience, you can pass a behaviour to defoverridable and it will mark all of the callbacks in the behaviour as overridable:defmodule Behaviour do @callback test(number(), number()) :: number() end defmodule DefaultMod do defmacro __using__(_opts) do quote do @behaviour Behaviour def test(x, y) do x + y end defoverridable Behaviour end end end defmodule ChildMod do use DefaultMod def test(x, y) do x * y + super(x, y) end endNarrow behaviours and entry pointsWhen defining behaviours, a general rule of thumb is to define narrow behaviours, with the minimum amount of callbacks, to facilitate maintenance over time. Fewer callbacks minimize the points of contact between different parts of the system and reduces the risk of breaking changes and of different implementations having inconsistent behaviour. However, when using defoverridable with behaviours, you may accidentally define broad interfaces as all default behaviour is provided via defoverridable. Furthermore, defoverridable necessarily relies on meta-programming, which complicates debugging. super is also hard to troubleshoot, as it by definition relies on calling an implicitly defined function.A possible alternative to defoverridable is to use optional callbacks and move the default implementation to the caller. Then you can check if a callback exists via Code.ensure_loaded?/1 and function_exported?/3. For instance, in the example above, imagine there is a module that calls the test/2 function. This module could be defined as such:defmodule CallsTest do def receives_module_and_calls_test(module, x, y) do if Code.ensure_loaded?(module) and function_exported?(module, :test, 2) do module.test(x, y) else x + y end end endThe downside of the above code is that it must call Code.ensure_loaded?/1 and function_exported?/3 on every invocation of the behaviour, which may impact runtime performance. For this reason, this approach works best when the behaviour has an entry point, such as a init callback (as seen in GenServer), which you invoke once to guarantee the module is loaded, and from that moment, you only need to perform function_exported?/3 checks.To recap:Prefer narrow behavioursIf your behaviour has an entry point, consider using optional callbacks followed by Code.ensure_loaded?/1 and function_exported?/3 checksIf using defoverridable, avoid relying on super to trigger the default behaviour, suggesting users to invoke well-defined APIs instead. defp(call, expr \\ nil) (macro) Defines a private function with the given name and body.Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an UndefinedFunctionError exception.Check def/2 for more information.Examplesdefmodule Foo do def bar do sum(1, 2) end defp sum(a, b), do: a + b end Foo.bar() #=> 3 Foo.sum(1, 2) ** (UndefinedFunctionError) undefined function Foo.sum/2 defprotocol(name, do_block) (macro) Defines a protocol.See the Protocol module for more information. defstruct(fields) (macro) Defines a struct.A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.It is only possible to define a struct per module, as the struct is tied to the module itself.Examplesdefmodule User do defstruct name: nil, age: nil endStruct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, 10 + 11 is evaluated at compile-time and the age field is stored with value 21:defmodule User do defstruct name: nil, age: 10 + 11 endThe fields argument is usually a keyword list with field names as atom keys and default values as corresponding values. defstruct/1 also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to nil.defmodule Post do defstruct [:title, :content, :author] endAdd documentation to a struct with the @doc attribute, like a function.defmodule Post do @doc "A post. The content should be valid Markdown." defstruct [:title, :content, :author] endOnce a struct is defined, it is possible to create them as follows:%Post{title: "Hello world!"}For more information on creating, updating, and pattern matching on structs, please check %/2.DerivingAlthough structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the User struct leads to an error:john = %User{name: "John"} MyProtocol.call(john) ** (Protocol.UndefinedError) protocol MyProtocol not implemented for User (a struct)defstruct/1, however, allows protocol implementations to be derived. This can be done by defining a @derive attribute as a list before invoking defstruct/1:defmodule User do @derive MyProtocol defstruct name: nil, age: nil end MyProtocol.call(john) # it works!A common example is to @derive the Inspect protocol to hide certain fields when the struct is printed:defmodule User do @derive {Inspect, only: :name} defstruct name: nil, age: nil endFor each protocol in @derive, Elixir will verify if the protocol has implemented the Protocol.__deriving__/2 callback. If so, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the Any implementation is automatically derived. For more information, see Protocol.derive/3.Enforcing keysWhen building a struct, Elixir will automatically guarantee all keys belong to the struct:%User{name: "john", unknown: :key} ** (KeyError) key :unknown not found in: %User{age: 21, name: nil}Elixir also allows developers to enforce that certain keys must always be given when building the struct:defmodule User do @enforce_keys [:name] defstruct name: nil, age: 10 + 11 endNow trying to build a struct without the name key will fail:%User{age: 21} ** (ArgumentError) the following keys must also be given when building struct User: [:name]Keep in mind @enforce_keys is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.TypesIt is recommended to define types for structs. By convention, such a type is called t. To define a struct inside a type, the struct literal syntax is used:defmodule User do defstruct name: "John", age: 25 @type t :: %__MODULE__{name: String.t(), age: non_neg_integer} endIt is recommended to only use the struct syntax when defining the struct's type. When referring to another struct, it's better to use User.t() instead of %User{}.The types of the struct fields that are not included in %User{} default to term() (see term/0).Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the @opaque attribute. Structs whose internal structure is public should use @type. destructure(left, right) (macro) Destructures two lists, assigning each term in the right one to the matching term in the left one.Unlike pattern matching via =, if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error.Examplesiex> destructure([x, y, z], [1, 2, 3, 4, 5]) iex> {x, y, z} {1, 2, 3}In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to nil:iex> destructure([x, y, z], [1]) iex> {x, y, z} {1, nil, nil}The left-hand side supports any expression you would use on the left-hand side of a match:iex> x = 1 iex> destructure([^x, y, z], [1, 2, 3]) iex> {x, y, z} {1, 2, 3}The example above will only work if x matches the first value in the right list. Otherwise, it will raise a MatchError (like the = operator would do). exit(reason) @spec exit(term()) :: no_return() Stops the execution of the calling process with the given reason.Since evaluating this function causes the process to terminate, it has no return value.Inlined by the compiler.ExamplesWhen a process reaches its end, by default it exits with reason :normal. You can also call exit/1 explicitly if you want to terminate a process but not signal any failure:exit(:normal)In case something goes wrong, you can also use exit/1 with a different reason:exit(:seems_bad)If the exit reason is not :normal, all the processes linked to the process that exited will crash (unless they are trapping exits).OTP exitsExits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered "normal":exit(:normal)exit(:shutdown)exit({:shutdown, term})Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behavior kicks in, error reports are emitted, and so forth.This behavior is relied on in many different places. For example, ExUnit uses exit(:shutdown) when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too.CLI exitsBuilding on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0.It is, however, possible to customize the operating system exit signal by invoking:exit({:shutdown, integer})This will cause the operating system process to exit with the status given by integer while signaling all linked Erlang processes to politely shut down.Any other exit reason will cause the operating system process to exit with status 1 and linked Erlang processes to crash. function_exported?(module, function, arity) @spec function_exported?(module(), atom(), arity()) :: boolean() Returns true if module is loaded and contains a public function with the given arity, otherwise false.Unloaded modulesThis function does not load the module in case it is not loaded and Elixir lazily loads modules by default (except on releases).This may lead to unexpected behaviour as the result of this function may depend if another code has happened to load the given module as argument beforehand. For example, this could manifest in mix test by having tests that fail when running in isolation or depending on the test seed. For those reasons, it is recommended to always check for Code.ensure_loaded?/1 before function_exported?/3, unless you are certain the module has been loaded before.See Code.ensure_loaded/1 for more information.Inlined by the compiler.Examplesiex> Code.ensure_loaded?(Enum) and function_exported?(Enum, :map, 2) true iex> Code.ensure_loaded?(Enum) and function_exported?(Enum, :map, 10) false iex> Code.ensure_loaded?(List) and function_exported?(List, :to_string, 1) true get_and_update_in(path, fun) (macro) Gets a value and updates a nested data structure via the given path.This is similar to get_and_update_in/3, except the path is extracted via a macro rather than passing a list. For example:get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})Is equivalent to:get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})This also works with nested structs and the struct.path.to.value way to specify paths:get_and_update_in(struct.foo.bar, &{&1, &1 + 1})Note that in order for this macro to work, the complete path must always be visible by this macro. See the "Paths" section below.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> get_and_update_in(users["john"].age, &{&1, &1 + 1}) {27, %{"john" => %{age: 28}, "meg" => %{age: 23}}}PathsA path may start with a variable, local or remote call, and must be followed by one or more:foo[bar] - accesses the key bar in foo; in case foo is nil, nil is returnedfoo.bar - accesses a map/struct field; in case the field is not present, an error is raisedHere are some valid paths:users["john"][:age] users["john"].age User.all()["john"].age all_users()["john"].ageHere are some invalid ones:# Does a remote call after the initial value users["john"].do_something(arg1, arg2) # Does not access any key or field users get_and_update_in(data, keys, fun) @spec get_and_update_in( structure, keys, (term() | nil -> {current_value, new_value} | :pop) ) :: {current_value, new_structure :: structure} when structure: Access.t(), keys: [term(), ...], current_value: Access.value(), new_value: Access.value() Gets a value and updates a nested structure.data is a nested structure (that is, a map, keyword list, or struct that implements the Access behaviour).The fun argument receives the value of key (or nil if key is not present) and must return one of the following values:a two-element tuple {current_value, new_value}. In this case, current_value is the retrieved value which can possibly be operated on before being returned. new_value is the new value to be stored under key.:pop, which implies that the current value under key should be removed from the structure and returned.This function uses the Access module to traverse the structures according to the given keys, unless the key is a function, which is detailed in a later section.ExamplesThis function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass:iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> get_and_update_in(users, ["john", :age], &{&1, &1 + 1}) {27, %{"john" => %{age: 28}, "meg" => %{age: 23}}}Note the current value given to the anonymous function may be nil. If any of the intermediate values are nil, it will raise:iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> get_and_update_in(users, ["jane", :age], &{&1, &1 + 1}) ** (ArgumentError) could not put/update key :age on a nil valueFunctions as keysIf a key is a function, the function will be invoked passing three arguments:the operation (:get_and_update)the data to be accesseda function to be invoked nextThis means get_and_update_in/3 can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list:iex> users = [%{name: "john", age: 27}, %{name: "meg", age: 23}] iex> all = fn :get_and_update, data, next -> ...> data |> Enum.map(next) |> Enum.unzip() ...> end iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1}) {[27, 23], [%{name: "john", age: 28}, %{name: "meg", age: 24}]}If the previous value before invoking the function is nil, the function will receive nil as a value and must handle it accordingly (be it by failing or providing a sane default).The Access module ships with many convenience accessor functions, like the all anonymous function defined above. See Access.all/0, Access.key/2, and others as examples. get_in(path) (since 1.17.0) (macro) Gets a key from the nested structure via the given path, with nil-safe handling.This is similar to get_in/2, except the path is extracted via a macro rather than passing a list. For example:get_in(opts[:foo][:bar])Is equivalent to:get_in(opts, [:foo, :bar])Additionally, this macro can traverse structs:get_in(struct.foo.bar)In case any of the keys returns nil, then nil will be returned and get_in/1 won't traverse any further.Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> get_in(users["john"].age) 27 iex> get_in(users["unknown"].age) nil get_in(data, keys) @spec get_in(Access.t(), [term(), ...]) :: term() Gets a value from a nested structure with nil-safe handling.Uses the Access module to traverse the structures according to the given keys, unless the key is a function, which is detailed in a later section.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> get_in(users, ["john", :age]) 27 iex> # Equivalent to: iex> users["john"][:age] 27get_in/2 can also use the accessors in the Access module to traverse more complex data structures. For example, here we use Access.all/0 to traverse a list:iex> users = [%{name: "john", age: 27}, %{name: "meg", age: 23}] iex> get_in(users, [Access.all(), :age]) [27, 23]In case any of the components returns nil, nil will be returned and get_in/2 won't traverse any further:iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> get_in(users, ["unknown", :age]) nil iex> # Equivalent to: iex> users["unknown"][:age] nilFunctions as keysIf a key given to get_in/2 is a function, the function will be invoked passing three arguments:the operation (:get)the data to be accesseda function to be invoked nextThis means get_in/2 can be extended to provide custom lookups. That's precisely how the Access.all/0 key in the previous section behaves. For example, we can manually implement such traversal as follows:iex> users = [%{name: "john", age: 27}, %{name: "meg", age: 23}] iex> all = fn :get, data, next -> Enum.map(data, next) end iex> get_in(users, [all, :age]) [27, 23]The Access module ships with many convenience accessor functions. See Access.all/0, Access.key/2, and others as examples.Working with structsBy default, structs do not implement the Access behaviour required by this function. Therefore, you can't do this:get_in(some_struct, [:some_key, :nested_key])There are two alternatives. Given structs have predefined keys, we can use the struct.field notation:some_struct.some_key.nested_keyHowever, the code above will fail if any of the values return nil. If you also want to handle nil values, you can use get_in/1:get_in(some_struct.some_key.nested_key)Pattern-matching is another option for handling such cases, which can be especially useful if you want to match on several fields at once or provide custom return values:case some_struct do %{some_key: %{nested_key: value}} -> value %{} -> nil end if(condition, clauses) (macro) Provides an if/2 macro.This macro expects the first argument to be a condition and the second argument to be a keyword list. Generally speaking, Elixir developers prefer to use pattern matching and guards in function definitions and case/2, as they are succinct and precise. However, not all conditions can be expressed through patterns and guards, which makes if/2 a viable alternative.Similar to case/2, any assignment in the condition will be available on both clauses, as well as after the if expression.One-liner examplesiex> if 7 > 5, do: "yes" "yes" iex> if "truthy value", do: "yes" "yes"In the examples above, the do clause is evaluated and "yes" will be returned because the condition evaluates to a truthy value (neither false nor nil). Otherwise, the clause is not evaluated and nil will be returned:iex> if 3 > 5, do: "yes" nil iex> if nil, do: IO.puts("this won't be printed") nilAn else option can be given to specify the opposite:iex> if 3 > 5, do: "yes", else: "no" "no"Blocks examplesIt's also possible to pass a block to the if/2 macro. The first example above would be translated to:iex> if 7 > 5 do ...> "yes" ...> end "yes"Note that do-end become delimiters. The third example would translate to:iex> if 3 > 5 do ...> "yes" ...> else ...> "no" ...> end "no"If you find yourself nesting conditionals inside conditionals, consider using cond/1.Variables scopeVariables set within do/else blocks do not leak to the outer context:x = 1 if x > 0 do x = x + 1 IO.puts(x) # prints 2 end x # 1Variables set in the condition are available in the outer context:fruits = %{oranges: 3} if count = fruits[:apples] do # won't be evaluated IO.puts(count + 1) end count # nil inspect(term, opts \\ []) @spec inspect(Inspect.t(), [Inspect.Opts.new_opt()]) :: String.t() Inspects the given argument according to the Inspect protocol. The second argument is a keyword list with options to control inspection.Optionsinspect/2 accepts a list of options that are internally translated to an Inspect.Opts struct. Check the docs for Inspect.Opts to see the supported options.Examplesiex> inspect(:foo) ":foo" iex> inspect([1, 2, 3, 4, 5], limit: 3) "[1, 2, 3, ...]" iex> inspect([1, 2, 3], pretty: true, width: 0) "[1,\n 2,\n 3]" iex> inspect("olá" <> <<0>>) "<<111, 108, 195, 161, 0>>" iex> inspect("olá" <> <<0>>, binaries: :as_strings) "\"olá\\0\"" iex> inspect("olá", binaries: :as_binaries) "<<111, 108, 195, 161>>" iex> inspect(~c"bar") "~c\"bar\"" iex> inspect([0 | ~c"bar"]) "[0, 98, 97, 114]" iex> inspect(100, base: :octal) "0o144" iex> inspect(100, base: :hex) "0x64"Note that the Inspect protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with #. For example, inspecting a function will return:inspect(fn a, b -> a + b end) #=> #Function<...>The Inspect protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the "Deriving" section of the documentation of the Inspect protocol for more information. macro_exported?(module, macro, arity) @spec macro_exported?(module(), atom(), arity()) :: boolean() Returns true if module is loaded and contains a public macro with the given arity, otherwise false.Note that this function does not load the module in case it is not loaded. See the notes under function_exported?/3 for more information.If module is an Erlang module (as opposed to an Elixir module), this function always returns false.Examplesiex> Code.ensure_loaded?(Kernel) and macro_exported?(Kernel, :use, 2) true iex> Code.ensure_loaded?(:erlang) and macro_exported?(:erlang, :abs, 1) false make_ref() @spec make_ref() :: reference() Returns an almost unique reference.The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.Inlined by the compiler.Examplesmake_ref() #=> #Reference<0.0.0.135> match?(pattern, expr) (macro) A convenience macro that checks if the right side (an expression) matches the left side (a pattern).Examplesiex> match?(1, 1) true iex> match?({1, _}, {1, 2}) true iex> map = %{a: 1, b: 2} iex> match?(%{a: _}, map) true iex> a = 1 iex> match?(^a, 1) truematch?/2 is very useful when filtering or finding a value in an enumerable:iex> list = [a: 1, b: 2, a: 3] iex> Enum.filter(list, &match?({:a, _}, &1)) [a: 1, a: 3]Guard clauses can also be given to the match:iex> list = [a: 1, b: 2, a: 3] iex> Enum.filter(list, &match?({:a, x} when x < 2, &1)) [a: 1]Variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the = operator):iex> match?(_x, 1) true iex> binding() []Values vs patternsRemember the pin operator matches values, not patterns. Passing a variable as the pattern will always return true and will result in a warning that the variable is unused. Don't do this:pattern = %{a: :a} match?(pattern, %{b: :b}) #=> trueSimilarly, moving an expression out the pattern may no longer preserve its semantics. For example:iex> match?([_ | _], [1, 2, 3]) true pattern = [_ | _] match?(pattern, [1, 2, 3]) ** (CompileError) invalid use of _. _ can only be used inside patterns to ignore values and cannot be used in expressions. Make sure you are inside a pattern or change it accordinglyAnother example is that a map as a pattern performs a subset match, but not once assigned to a variable:iex> match?(%{x: 1}, %{x: 1, y: 2}) true iex> attrs = %{x: 1} iex> match?(^attrs, %{x: 1, y: 2}) falseThe pin operator will check if the values are equal, using ===/2, while patterns have their own rules when matching maps, lists, and so forth. Such behavior is not specific to match?/2. The following code also throws an exception:attrs = %{x: 1} ^attrs = %{x: 1, y: 2} #=> (MatchError) no match of right hand side value: %{x: 1, y: 2} pop_in(path) (macro) Pops a key from the nested structure via the given path.This is similar to pop_in/2, except the path is extracted via a macro rather than passing a list. For example:pop_in(opts[:foo][:bar])Is equivalent to:pop_in(opts, [:foo, :bar])Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> pop_in(users["john"][:age]) {27, %{"john" => %{}, "meg" => %{age: 23}}} iex> users = %{john: %{age: 27}, meg: %{age: 23}} iex> pop_in(users.john[:age]) {27, %{john: %{}, meg: %{age: 23}}}In case any entry returns nil, its key will be removed and the deletion will be considered a success. pop_in(data, keys) @spec pop_in(data, [Access.get_and_update_fun(term(), data) | term(), ...]) :: {term(), data} when data: Access.container() Pops a key from the given nested structure.Uses the Access protocol to traverse the structures according to the given keys, unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> pop_in(users, ["john", :age]) {27, %{"john" => %{}, "meg" => %{age: 23}}}In case any entry returns nil, its key will be removed and the deletion will be considered a success.iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> pop_in(users, ["jane", :age]) {nil, %{"john" => %{age: 27}, "meg" => %{age: 23}}} put_elem(tuple, index, value) @spec put_elem(tuple(), non_neg_integer(), term()) :: tuple() Puts value at the given zero-based index in tuple.Inlined by the compiler.Examplesiex> tuple = {:foo, :bar, 3} iex> put_elem(tuple, 0, :baz) {:baz, :bar, 3} put_in(path, value) (macro) Puts a value in a nested structure via the given path.This is similar to put_in/3, except the path is extracted via a macro rather than passing a list. For example:put_in(opts[:foo][:bar], :baz)Is equivalent to:put_in(opts, [:foo, :bar], :baz)This also works with nested structs and the struct.path.to.value way to specify paths:put_in(struct.foo.bar, :baz)Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> put_in(users["john"][:age], 28) %{"john" => %{age: 28}, "meg" => %{age: 23}} iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> put_in(users["john"].age, 28) %{"john" => %{age: 28}, "meg" => %{age: 23}} put_in(data, keys, value) @spec put_in(Access.t(), [term(), ...], term()) :: Access.t() Puts a value in a nested structure.Uses the Access module to traverse the structures according to the given keys, unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> put_in(users, ["john", :age], 28) %{"john" => %{age: 28}, "meg" => %{age: 23}}If any of the intermediate values are nil, it will raise:iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> put_in(users, ["jane", :age], "oops") ** (ArgumentError) could not put/update key :age on a nil value raise(message) (macro) Raises an exception.If message is a string, it raises a RuntimeError exception with it.If message is an atom, it just calls raise/2 with the atom as the first argument and [] as the second one.If message is an exception struct, it is raised as is.If message is anything else, raise will fail with an ArgumentError exception.Examplesiex> raise "oops" ** (RuntimeError) oops try do 1 + :foo rescue x in [ArithmeticError] -> IO.puts("that was expected") raise x end raise(exception, attributes) (macro) Raises an exception.Calls the exception/1 function on the given argument (which has to be a module name like ArgumentError or RuntimeError) passing attributes in order to retrieve the exception struct.Any module that contains a call to the defexception/1 macro automatically implements the Exception.exception/1 callback expected by raise/2. For more information, see defexception/1.Examplesiex> raise(ArgumentError, "Sample") ** (ArgumentError) Sample reraise(message, stacktrace) (macro) Raises an exception preserving a previous stacktrace.Works like raise/1 but does not generate a new stacktrace.Note that __STACKTRACE__ can be used inside catch/rescue to retrieve the current stacktrace.Examplesiex> try do ...> raise "oops" ...> rescue ...> exception -> ...> reraise exception, __STACKTRACE__ ...> end ** (RuntimeError) oops reraise(exception, attributes, stacktrace) (macro) Raises an exception preserving a previous stacktrace.reraise/3 works like reraise/2, except it passes arguments to the exception/1 function as explained in raise/2.Examplestry do raise "oops" rescue exception -> reraise WrapperError, [exception: exception], __STACKTRACE__ end send(dest, message) @spec send(dest :: Process.dest(), message) :: message when message: any() Sends a message to the given dest and returns the message.dest may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node.For additional documentation, see the ! operator Erlang documentation.Inlined by the compiler.Examplesiex> send(self(), :hello) :hello sigil_C(term, modifiers) (macro) Handles the sigil ~C for charlists.It returns a charlist without interpolations and without escape characters.A charlist is a list of integers where all the integers are valid code points. The three expressions below are equivalent:~C"foo\n" [?f, ?o, ?o, ?\\, ?n] [102, 111, 111, 92, 110]In practice, charlists are mostly used in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments.Examplesiex> ~C(foo) ~c"foo" iex> ~C(f#{o}o) ~c"f\#{o}o" iex> ~C(foo\n) ~c"foo\\n" sigil_c(term, modifiers) (macro) Handles the sigil ~c for charlists.It returns a charlist, unescaping characters and replacing interpolations.A charlist is a list of integers where all the integers are valid code points. The three expressions below are equivalent:~c"foo" [?f, ?o, ?o] [102, 111, 111]In practice, charlists are mostly used in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments.Examplesiex> ~c(foo) ~c"foo" iex> ~c(f#{:o}o) ~c"foo" iex> ~c(f\#{:o}o) ~c"f\#{:o}o"The list is only printed as a ~c sigil if all code points are within the ASCII range:iex> ~c"hełło" [104, 101, 322, 322, 111] iex> [104, 101, 108, 108, 111] ~c"hello"See Inspect.Opts for more information. sigil_D(date_string, modifiers) (macro) Handles the sigil ~D for dates.By default, this sigil uses the built-in Calendar.ISO, which requires dates to be written in the ISO8601 format:~D[yyyy-mm-dd]such as:~D[2015-01-13]If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:~D[SOME-REPRESENTATION My.Alternative.Calendar]The lower case ~d variant does not exist as interpolation and escape characters are not useful for date sigils.More information on dates can be found in the Date module.Examplesiex> ~D[2015-01-13] ~D[2015-01-13] sigil_N(naive_datetime_string, modifiers) (macro) Handles the sigil ~N for naive date times.By default, this sigil uses the built-in Calendar.ISO, which requires naive date times to be written in the ISO8601 format:~N[yyyy-mm-dd hh:mm:ss] ~N[yyyy-mm-dd hh:mm:ss.ssssss] ~N[yyyy-mm-ddThh:mm:ss.ssssss]such as:~N[2015-01-13 13:00:07] ~N[2015-01-13T13:00:07.123]If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:~N[SOME-REPRESENTATION My.Alternative.Calendar]The lower case ~n variant does not exist as interpolation and escape characters are not useful for date time sigils.More information on naive date times can be found in the NaiveDateTime module.Examplesiex> ~N[2015-01-13 13:00:07] ~N[2015-01-13 13:00:07] iex> ~N[2015-01-13T13:00:07.001] ~N[2015-01-13 13:00:07.001] sigil_r(term, modifiers) (macro) Handles the sigil ~r for regular expressions.It returns a regular expression pattern, unescaping characters and replacing interpolations.More information on regular expressions can be found in the Regex module.Examplesiex> Regex.match?(~r/foo/, "foo") true iex> Regex.match?(~r/a#{:b}c/, "abc") trueWhile the ~r sigil allows parens and brackets to be used as delimiters, it is preferred to use " or / to avoid escaping conflicts with reserved regex characters. sigil_S(term, modifiers) (macro) Handles the sigil ~S for strings.It returns a string without interpolations and without escape characters.Examplesiex> ~S(foo) "foo" iex> ~S(f#{o}o) "f\#{o}o" iex> ~S(\o/) "\\o/" sigil_s(term, modifiers) (macro) Handles the sigil ~s for strings.It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.Examplesiex> ~s(foo) "foo" iex> ~s(f#{:o}o) "foo" iex> ~s(f\#{:o}o) "f\#{:o}o" sigil_T(time_string, modifiers) (macro) Handles the sigil ~T for times.By default, this sigil uses the built-in Calendar.ISO, which requires times to be written in the ISO8601 format:~T[hh:mm:ss] ~T[hh:mm:ss.ssssss]such as:~T[13:00:07] ~T[13:00:07.123]If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:~T[SOME-REPRESENTATION My.Alternative.Calendar]The lower case ~t variant does not exist as interpolation and escape characters are not useful for time sigils.More information on times can be found in the Time module.Examplesiex> ~T[13:00:07] ~T[13:00:07] iex> ~T[13:00:07.001] ~T[13:00:07.001] sigil_U(datetime_string, modifiers) (since 1.9.0) (macro) Handles the sigil ~U to create a UTC DateTime.By default, this sigil uses the built-in Calendar.ISO, which requires UTC date times to be written in the ISO8601 format:~U[yyyy-mm-dd hh:mm:ssZ] ~U[yyyy-mm-dd hh:mm:ss.ssssssZ] ~U[yyyy-mm-ddThh:mm:ss.ssssss+00:00]such as:~U[2015-01-13 13:00:07Z] ~U[2015-01-13T13:00:07.123+00:00]If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:~U[SOME-REPRESENTATION My.Alternative.Calendar]The given datetime_string must include "Z" or "00:00" offset which marks it as UTC, otherwise an error is raised.The lower case ~u variant does not exist as interpolation and escape characters are not useful for date time sigils.More information on date times can be found in the DateTime module.Examplesiex> ~U[2015-01-13 13:00:07Z] ~U[2015-01-13 13:00:07Z] iex> ~U[2015-01-13T13:00:07.001+00:00] ~U[2015-01-13 13:00:07.001Z] sigil_W(term, modifiers) (macro) Handles the sigil ~W for list of words.It returns a list of "words" split by whitespace without interpolations and without escape characters.Modifierss: words in the list are strings (default)a: words in the list are atomsc: words in the list are charlistsExamplesiex> ~W(foo #{bar} baz) ["foo", "\#{bar}", "baz"] sigil_w(term, modifiers) (macro) Handles the sigil ~w for list of words.It returns a list of "words" split by whitespace. Character unescaping and interpolation happens for each word.Modifierss: words in the list are strings (default)a: words in the list are atomsc: words in the list are charlistsExamplesiex> ~w(foo #{:bar} baz) ["foo", "bar", "baz"] iex> ~w(foo #{" bar baz "}) ["foo", "bar", "baz"] iex> ~w(--source test/enum_test.exs) ["--source", "test/enum_test.exs"] iex> ~w(foo bar baz)a [:foo, :bar, :baz] iex> ~w(foo bar baz)c [~c"foo", ~c"bar", ~c"baz"] spawn(fun) @spec spawn((-> any())) :: pid() Spawns the given function and returns its PID.Typically developers do not use the spawn functions, instead they use abstractions such as Task, GenServer and Agent, built on top of spawn, that spawns processes with more conveniences in terms of introspection and debugging.Check the Process module for more process-related functions.The anonymous function receives 0 arguments, and may return any value.Inlined by the compiler.Examplesiex> current = self() iex> child = spawn(fn -> send(current, {self(), 1 + 2}) end) iex> receive do ...> {^child, 3} -> :ok ...> end :ok spawn(module, fun, args) @spec spawn(module(), atom(), list()) :: pid() Spawns the given function fun from the given module passing it the given args and returns its PID.Typically developers do not use the spawn functions, instead they use abstractions such as Task, GenServer and Agent, built on top of spawn, that spawns processes with more conveniences in terms of introspection and debugging.Check the Process module for more process-related functions.Inlined by the compiler.Examplesspawn(SomeModule, :function, [1, 2, 3]) spawn_link(fun) @spec spawn_link((-> any())) :: pid() Spawns the given function, links it to the current process, and returns its PID.Typically developers do not use the spawn functions, instead they use abstractions such as Task, GenServer and Agent, built on top of spawn, that spawns processes with more conveniences in terms of introspection and debugging.Check the Process module for more process-related functions. For more information on linking, check Process.link/1.The anonymous function receives 0 arguments, and may return any value.Inlined by the compiler.Examplesiex> current = self() iex> child = spawn_link(fn -> send(current, {self(), 1 + 2}) end) iex> receive do ...> {^child, 3} -> :ok ...> end :ok spawn_link(module, fun, args) @spec spawn_link(module(), atom(), list()) :: pid() Spawns the given function fun from the given module passing it the given args, links it to the current process, and returns its PID.Typically developers do not use the spawn functions, instead they use abstractions such as Task, GenServer and Agent, built on top of spawn, that spawns processes with more conveniences in terms of introspection and debugging.Check the Process module for more process-related functions. For more information on linking, check Process.link/1.Inlined by the compiler.Examplesspawn_link(SomeModule, :function, [1, 2, 3]) spawn_monitor(fun) @spec spawn_monitor((-> any())) :: {pid(), reference()} Spawns the given function, monitors it and returns its PID and monitoring reference.Typically developers do not use the spawn functions, instead they use abstractions such as Task, GenServer and Agent, built on top of spawn, that spawns processes with more conveniences in terms of introspection and debugging.Check the Process module for more process-related functions.The anonymous function receives 0 arguments, and may return any value.Inlined by the compiler.Examplesiex> current = self() iex> {child, _ref} = spawn_monitor(fn -> send(current, {self(), 1 + 2}) end) iex> receive do ...> {^child, 3} -> :ok ...> end :ok spawn_monitor(module, fun, args) @spec spawn_monitor(module(), atom(), list()) :: {pid(), reference()} Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference.Typically developers do not use the spawn functions, instead they use abstractions such as Task, GenServer and Agent, built on top of spawn, that spawns processes with more conveniences in terms of introspection and debugging.Check the Process module for more process-related functions.Inlined by the compiler.Examplesspawn_monitor(SomeModule, :function, [1, 2, 3]) struct(struct, fields \\ []) @spec struct(module() | struct(), Enumerable.t()) :: struct() Creates and updates a struct.The struct argument may be an atom (which defines defstruct) or a struct itself. The second argument is any Enumerable that emits two-element tuples (key-value pairs) during enumeration.Keys in the Enumerable that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct. If there are duplicate keys in the Enumerable, the last entry will be taken (same behavior as Map.new/1).This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate :__struct__ field into the map may not be enough and struct/2 should be used instead.Examplesdefmodule User do defstruct name: "john" end struct(User) #=> %User{name: "john"} opts = [name: "meg"] user = struct(User, opts) #=> %User{name: "meg"} struct(user, unknown: "value") #=> %User{name: "meg"} struct(User, %{name: "meg"}) #=> %User{name: "meg"} # String keys are ignored struct(User, %{"name" => "meg"}) #=> %User{name: "john"} struct!(struct, fields \\ []) @spec struct!(module() | struct(), Enumerable.t()) :: struct() Similar to struct/2 but checks for key validity.The function struct!/2 emulates the compile time behavior of structs. This means that:when building a struct, as in struct!(SomeStruct, key: :value), it is equivalent to %SomeStruct{key: :value} and therefore this function will check if every given key-value belongs to the struct. If the struct is enforcing any key via @enforce_keys, those will be enforced as well;when updating a struct, as in struct!(%SomeStruct{}, key: :value), it is equivalent to %SomeStruct{struct | key: :value} and therefore this function will check if every given key-value belongs to the struct. tap(value, fun) (since 1.12.0) (macro) Pipes the first argument, value, into the second argument, a function fun, and returns value itself.Useful for running synchronous side effects in a pipeline, using the |>/2 operator.Examplesiex> tap(1, fn x -> x + 1 end) 1Most commonly, this is used in pipelines, using the |>/2 operator. For example, let's suppose you want to inspect part of a data structure. You could write:%{a: 1} |> Map.update!(:a, & &1 + 2) |> tap(&IO.inspect(&1.a)) |> Map.update!(:a, & &1 * 2) then(value, fun) (since 1.12.0) (macro) Pipes the first argument, value, into the second argument, a function fun, and returns the result of calling fun.In other words, it invokes the function fun with value as argument, and returns its result.This is most commonly used in pipelines, using the |>/2 operator, allowing you to pipe a value to a function outside of its first argument.Examplesiex> 1 |> then(fn x -> x * 2 end) 2 iex> 1 |> then(fn x -> Enum.drop(["a", "b", "c"], x) end) ["b", "c"] throw(term) @spec throw(term()) :: no_return() A non-local return from a function.Using throw/1 is generally discouraged, as it allows a function to escape from its regular execution flow, which can make the code harder to read. Furthermore, all thrown values must be caught by try/catch. See try/1 for more information.Inlined by the compiler. to_charlist(term) (macro) Converts the given term to a charlist according to the List.Chars protocol.Examplesiex> to_charlist(:foo) ~c"foo" to_string(term) (macro) Converts the argument to a string according to the String.Chars protocol.This is invoked when there is string interpolation.Examplesiex> to_string(:foo) "foo" to_timeout(duration) (since 1.17.0) @spec to_timeout([{unit, non_neg_integer()}] | timeout() | Duration.t()) :: timeout() when unit: :week | :day | :hour | :minute | :second | :millisecond Constructs a millisecond timeout from the given components, duration, or timeout.This function is useful for constructing timeouts to use in functions that expect timeout/0 values (such as Process.send_after/4 and many others).ArgumentThe duration argument can be one of a Duration, a timeout/0, or a list of components. Each of these is described below.Passing DurationsDuration.t/0 structs can be converted to timeouts. The given duration must have year and month fields set to 0, since those cannot be reliably converted to milliseconds (due to the varying number of days in a month and year).Microseconds in durations are converted to milliseconds (through System.convert_time_unit/3).Passing componentsThe duration argument can also be keyword list which can contain the following keys, each appearing at most once with a non-negative integer value::week - the number of weeks (a week is always 7 days):day - the number of days (a day is always 24 hours):hour - the number of hours:minute - the number of minutes:second - the number of seconds:millisecond - the number of millisecondsThe timeout is calculated as the sum of the components, each multiplied by the corresponding factor.Passing timeoutsYou can also pass timeouts directly to this functions, that is, milliseconds or the atom :infinity. In this case, this function just returns the given argument.ExamplesWith a keyword list:iex> to_timeout(hour: 1, minute: 30) 5400000With a duration:iex> to_timeout(%Duration{hour: 1, minute: 30}) 5400000With a timeout:iex> to_timeout(5400000) 5400000 iex> to_timeout(:infinity) :infinity unless(condition, clauses) (macro) This macro is deprecated. Use if/2 instead. Provides an unless macro.This macro evaluates and returns the do block passed in as the second argument if condition evaluates to a falsy value (false or nil). Otherwise, it returns the value of the else block if present or nil if not.See also if/2.Examplesiex> unless(Enum.empty?([]), do: "Hello") nil iex> unless(Enum.empty?([1, 2, 3]), do: "Hello") "Hello" iex> unless Enum.sum([2, 2]) == 5 do ...> "Math still works" ...> else ...> "Math is broken" ...> end "Math still works" update_in(path, fun) (macro) Updates a nested structure via the given path.This is similar to update_in/3, except the path is extracted via a macro rather than passing a list. For example:update_in(opts[:foo][:bar], &(&1 + 1))Is equivalent to:update_in(opts, [:foo, :bar], &(&1 + 1))This also works with nested structs and the struct.path.to.value way to specify paths:update_in(struct.foo.bar, &(&1 + 1))Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> update_in(users["john"][:age], &(&1 + 1)) %{"john" => %{age: 28}, "meg" => %{age: 23}} iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> update_in(users["john"].age, &(&1 + 1)) %{"john" => %{age: 28}, "meg" => %{age: 23}} update_in(data, keys, fun) @spec update_in(Access.t(), [term(), ...], (term() -> term())) :: Access.t() Updates a key in a nested structure.Uses the Access module to traverse the structures according to the given keys, unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3.data is a nested structure (that is, a map, keyword list, or struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present) and the result replaces the value in the structure.Examplesiex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> update_in(users, ["john", :age], &(&1 + 1)) %{"john" => %{age: 28}, "meg" => %{age: 23}}Note the current value given to the anonymous function may be nil. If any of the intermediate values are nil, it will raise:iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}} iex> update_in(users, ["jane", :age], & &1 + 1) ** (ArgumentError) could not put/update key :age on a nil value use(module, opts \\ []) (macro) Uses the given module in the current context.When calling:use MyModule, some: :optionsElixir will invoke MyModule.__using__/1 passing the second argument of use as its argument. Since __using__/1 is typically a macro, all the usual macro rules apply, and its return value should be quoted code that is then inserted where use/2 is called.Code injectionuse MyModule works as a code-injection point in the caller. Given the caller of use MyModule has little control over how the code is injected, use/2 should be used with care. If you can, avoid use in favor of import/2 or alias/2 whenever possible.ExamplesFor example, to write test cases using the ExUnit framework provided with Elixir, a developer should use the ExUnit.Case module:defmodule AssertionTest do use ExUnit.Case, async: true test "always pass" do assert true end endIn this example, Elixir will call the __using__/1 macro in the ExUnit.Case module with the keyword list [async: true] as its argument.In other words, use/2 translates to:defmodule AssertionTest do require ExUnit.Case ExUnit.Case.__using__(async: true) test "always pass" do assert true end endwhere ExUnit.Case defines the __using__/1 macro:defmodule ExUnit.Case do defmacro __using__(opts) do # do something with opts quote do # return some code to inject in the caller end end endBest practices__using__/1 is typically used when there is a need to set some state (via module attributes) or callbacks (like @before_compile, see the documentation for Module for more information) into the caller.__using__/1 may also be used to alias, require, or import functionality from different modules:defmodule MyModule do defmacro __using__(_opts) do quote do import MyModule.Foo import MyModule.Bar import MyModule.Baz alias MyModule.Repo end end endHowever, do not provide __using__/1 if all it does is to import, alias or require the module itself. For example, avoid this:defmodule MyModule do defmacro __using__(_opts) do quote do import MyModule end end endIn such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind use/2. Developers must also avoid defining functions inside __using__/1.Given use MyModule can generate any code, it may not be easy for developers to understand the impact of use MyModule.For this reason, to provide guidance and clarity, we recommend developers to include an admonition block in their @moduledoc that explains how use MyModule impacts their code. As an example, the GenServer documentation outlines:use GenServerWhen you use GenServer, the GenServer module will set @behaviour GenServer and define a child_spec/1 function, so your module can be used as a child in a supervision tree.This provides a quick summary of how using a module impacts the user code. Keep in mind to only list changes made to the public API of the module. For example, if use MyModule sets an internal attribute called @_my_module_info and this attribute is never meant to be public, it must not be listed.For convenience, the markup notation to generate the admonition block above is:> #### `use GenServer` {: .info} > > When you `use GenServer`, the GenServer module will > set `@behaviour GenServer` and define a `child_spec/1` > function, so your module can be used as a child > in a supervision tree. var!(var, context \\ nil) (macro) Marks that the given variable should not be hygienized.This macro expects a variable and it is typically invoked inside quote/2 to mark that a variable should not be hygienized. See quote/2 for more information.Examplesiex> Kernel.var!(example) = 1 1 iex> Kernel.var!(example) 1 left |> right (macro) Pipe operator.This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.Examplesiex> [1, [2], 3] |> List.flatten() [1, 2, 3]The example above is the same as calling List.flatten([1, [2], 3]).The |>/2 operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:iex> [1, [2], 3] |> List.flatten() |> Enum.map(fn x -> x * 2 end) [2, 4, 6]In the example above, the list [1, [2], 3] is passed as the first argument to the List.flatten/1 function, then the flattened list is passed as the first argument to the Enum.map/2 function which doubles each element of the list.In other words, the expression above simply translates to:Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)PitfallsThere are two common pitfalls when using the pipe operator.The first one is related to operator precedence. For example, the following expression:String.graphemes "Hello" |> Enum.reverseTranslates to:String.graphemes("Hello" |> Enum.reverse())which results in an error as the Enumerable protocol is not defined for binaries. Adding explicit parentheses resolves the ambiguity:String.graphemes("Hello") |> Enum.reverse()Or, even better:"Hello" |> String.graphemes() |> Enum.reverse()The second limitation is that Elixir always pipes to a function call. Therefore, to pipe into an anonymous function, you need to invoke it:iex> some_fun = &Regex.replace(~r/l/, &1, "L") iex> "Hello" |> some_fun.() "HeLLo"Alternatively, you can use then/2 for the same effect:iex> some_fun = &Regex.replace(~r/l/, &1, "L") iex> "Hello" |> then(some_fun) "HeLLo"then/2 is most commonly used when you want to pipe to a function but the value is expected outside of the first argument, such as above. By replacing some_fun by its value, we get:iex> "Hello" |> then(&Regex.replace(~r/l/, &1, "L")) "HeLLo" left || right (macro) Boolean "or" operator.Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either nil or false). Returns the first expression otherwise.Not allowed in guard clauses.Examplesiex> Enum.empty?([1]) || Enum.empty?([1]) false iex> List.first([]) || true true iex> Enum.empty?([1]) || 1 1 iex> Enum.empty?([]) || throw(:bad) trueNote that, unlike or/2, this operator accepts any expression as the first argument, not only booleans. Search HexDocs Download ePub version Built using ExDoc (v0.38.4) for the Elixir programming language

```
Kernel
```

**Pattern 2:** This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

```
when
```

**Pattern 3:** This means comparisons in Elixir are structural, as it has the goal of comparing data types as efficiently as possible to create flexible and performant data structures. This distinction is specially important for functions that provide ordering, such as >/2, </2, >=/2, <=/2, min/2, and max/2. For example:

```
>/2
```

**Pattern 4:** Elixir v1.19.0 Search documentation of Elixir Settings Changelog for Elixir v1.19 View Source Type system improvementsType checking of protocol dispatch and implementationsThis release also adds type checking when dispatching and implementing protocols.For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.Here is an example passing a range, which cannot be converted into a string, to an interpolation:defmodule Example do def my_code(first..last//step = range) do "hello #{range}" end endthe above emits the following warnings:warning: incompatible value given to string interpolation: data it has type: %Range{first: term(), last: term(), step: term()} but expected a type that implements the String.Chars protocol, it must be one of: dynamic( %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or %Version.Requirement{} ) or atom() or binary() or float() or integer() or list(term())Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:defmodule Example do def my_code(%Date{} = date) do for(x <- date, do: x) end endwill emit:warning: incompatible value given to for-comprehension: x <- date it has type: %Date{year: term(), month: term(), day: term(), calendar: term()} but expected a type that implements the Enumerable protocol, it must be one of: dynamic( %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or %IO.Stream{} or %MapSet{} or %Range{} or %Stream{} ) or fun() or list(term()) or non_struct_map()Type checking and inference of anonymous functionsElixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:defmodule Example do def run do fun = fn %{} -> :map end fun.("hello") end endThe example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed: warning: incompatible types given on function application: fun.("hello") given types: binary() but function has type: (dynamic(map()) -> :map) typing violation found at: │ 6 │ fun.("hello") │ ~ │ └─ mod.exs:6:8: Example.run/0Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.AcknowledgementsThe type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.Faster compile times in large projectsThis release includes two compiler improvements that can lead up to 4x faster builds in large codebases.While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.Code loading bottlenecksPrior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.There are two potential regressions with this approach. The first one happens if you spawn processes during compilation which invoke other modules defined within the same project. For example:defmodule MyLib.SomeModule do list = [...] Task.async_stream(list, fn item -> MyLib.SomeOtherModule.do_something(item) end) endBecause the spawned process is not visible to the compiler, it won't be able to load MyLib.SomeOtherModule. You have two options, either use Kernel.ParallelCompiler.pmap/2 or explicitly call Code.ensure_compiled!(MyLib.SomeOtherModule) before spawning the process that uses said module.The second one is related to @on_load callbacks (typically used for NIFs) that invoke other modules defined within the same project. For example:defmodule MyLib.SomeModule do @on_load :init def init do MyLib.AnotherModule.do_something() end def something_else do ... end end MyLib.SomeModule.something_else()The reason this fails is because @on_load callbacks are invoked within the code server and therefore they have limited ability to load additional modules. It is generally advisable to limit invocation of external modules during @on_load callbacks but, in case it is strictly necessary, you can set @compile {:autoload, true} in the invoked module to address this issue in a forward and backwards compatible manner.Both snippets above could actually lead to non-deterministic compilation failures in the past, and as a result of these changes, compiling these cases are now deterministic.Parallel compilation of dependenciesThis release introduces a variable called MIX_OS_DEPS_COMPILE_PARTITION_COUNT, which instructs mix deps.compile to compile dependencies in parallel.While fetching dependencies and compiling individual Elixir dependencies already happened in parallel, as outlined in the previous section, there were pathological cases where performance gains would be left on the table, such as when compiling dependencies with native code or dependencies where one or two large files would take most of the compilation time.By setting MIX_OS_DEPS_COMPILE_PARTITION_COUNT to a number greater than 1, Mix will now compile multiple dependencies at the same time, using separate OS processes. Empirical testing shows that setting it to half of the number of cores on your machine is enough to maximize resource usage. The exact speed up will depend on the number of dependencies and the number of machine cores, although some reports mention up to 4x faster compilation times. If you plan to enable it on CI or build servers, keep in mind it will most likely have a direct impact on memory usage too.Improved pretty printing algorithmElixir v1.19 ships with a new pretty printing implementation that tracks limits as a whole, instead of per depth. Previous versions would track limits per depth. For example, if you had a list of lists of 4 elements and a limit of 5, it would be pretty printed as follows:[ [1, 2, 3], [1, 2, ...], [1, ...], [...], ... ]This allows for more information to be shown at different nesting levels, which is useful for complex data structures. But it led to some pathological cases where the limit option had little effect on filtering the amount of data shown. The new implementation decouples the limit handling from depth, decreasing it as it goes. Therefore, the list above with the same limit in Elixir v1.19 is now printed as:[ [1, 2, 3], ... ]The outer list is the first element, the first nested list is the second, followed by three numbers, reaching the limit. This gives developers more precise control over pretty printing.Given this may reduce the amount of data printed by default, the default limit has also been increased from 50 to 100. We may further increase it in upcoming releases based on community feedback.Erlang/OTP 28 supportElixir v1.19 officially supports Erlang/OTP 28.1+ and later. In order to support the new Erlang/OTP 28 representation for regular expressions, structs can now control how they are escaped into abstract syntax trees by defining a __escape__/1 callback.On the other hand, the new representation for regular expressions implies they can no longer be used as default values for struct fields. Instead of this:defmodule Foo do defstruct regex: ~r/foo/ endYou must do this:defmodule Foo do defstruct [:regex] def new do %Foo{regex: ~r/foo/} end endOpenChain certificationElixir v1.19 is also our first release following OpenChain compliance, as previously announced. In a nutshell:Elixir releases now include a Source SBoM in CycloneDX 1.6 or later and SPDX 2.3 or later formats.Each release is attested along with the Source SBoM.These additions offer greater transparency into the components and licenses of each release, supporting more rigorous supply chain requirements.This work was performed by Jonatan Männchen and sponsored by the Erlang Ecosystem Foundation.v1.19.0 (2025-10-16)1. EnhancementsElixir[Access] Add Access.values/0 for traversing maps and keyword lists values[Base] Add functions to verify if an encoding is valid, such as valid16?, valid64?, and so forth[Calendar] Support 2-arity options for Calendar.strftime/3 which receives the whole data type[Code] Add :migrate_call_parens_on_pipe formatter option[Code] Add :indentation option to Code.string_to_quoted/2[Code.Fragment] Preserve more block content around cursor in container_cursor_to_quoted[Code.Fragment] Add :block_keyword_or_binary_operator to Code.Fragment for more precise suggestions after operators and closing terminators[Code.Fragment] Add Code.Fragment.lines/1[Enum] Provide more information on Enum.OutOfBoundsError[Inspect] Allow optional: :all when deriving Inspect[Inspect.Algebra] Add optimistic/pessimistic groups as a simplified implementation of next_break_fits[IO.ANSI] Add ANSI codes to turn off conceal and crossed_out[Kernel] Raise when U+2028 and U+2029 characters are present in comments and strings to avoid line spoofing attacks[Kernel] Include the line for the previous clause in errors/warnings related to conflicts between defaults on function definitions[Kernel] Support min/2 and max/2 as guards[Kernel.ParallelCompiler] Add each_long_verification_threshold which invokes a callback when type checking a module takes too long[Kernel.ParallelCompiler] Include lines in == Compilation error in file ... == slogans[Macro] Print debugging results from Macro.dbg/3 as they happen, instead of once at the end[Macro] Add __escape__/1 callback so structs can escape references and other runtime data types in Macro.escape/1[Module] Do not automatically load modules after their compilation, guaranteeing a more consistent compile time experience and drastically improving compilation times[OptionParser] Support the :regex type[OptionParser] Enhance parsing error to display available options[Protocol] Type checking of protocols dispatch and implementations[Regex] Add Regex.to_embed/2 which returns an embeddable representation of regex in another regex[Regex] Raise error message when regexes are used as default values in struct fields for compatibility with Erlang/OTP 28[Registry] Add key-based partitioning of duplicate registries[String] Add String.count/2 to count occurrences of a pattern[String] Update to Unicode 17.0.0ExUnit[ExUnit] Set a process label for each test[ExUnit.CaptureLog] Parallelize log dispatch when multiple processes are capturing log[ExUnit.Case] Add :test_group to the test context[ExUnit.Doctest] Support ellipsis in doctest exceptions to match the remaining of the exception[ExUnit.Doctest] Add :inspect_opts option for doctestIEx[IEx] Support multi-line prompts (due to this feature, :continuation_prompt and :alive_continuation_prompt are no longer supported as IEx configuration)[IEx.Autocomplete] Functions annotated with @doc group: "Name" metadata will appear within their own groups in autocompletionLogger[Logger] Accept any enumerable in Logger.metadata/1Mix[mix] Add support for MIX_PROFILE_FLAGS to configure MIX_PROFILE[mix compile] Debug the compiler and type checker PID when MIX_DEBUG=1 and compilation/verification thresholds are met[mix compile] Add Mix.Tasks.Compiler.reenable/1[mix deps.compile] Support MIX_OS_DEPS_COMPILE_PARTITION_COUNT for compiling deps concurrently across multiple operating system processes[mix help] Add mix help Mod, mix help :mod, mix help Mod.fun, mix help Mod.fun/arity, and mix help app:package[mix format] Add options to mix format to allow excluding of files[mix test] Add --name-pattern option to mix test[mix test] Allow to distinguish the exit status between warnings as errors and test failures[mix xref graph] Add support for --format json[mix xref graph] Emit a warning if --source is part of a cycle[Mix] Support the :compilers option[Mix.Task.Compiler] Add Mix.Task.Compiler.run/22. Bug fixesElixir[Code] Return error on invalid unicode sequences in Code.string_to_quoted/2 instead of raising[Code] Properly handle column annotation for in in not in expressions[DateTime] Do not truncate microseconds regardless of precision in DateTime.diff/3[Enum] Fix infinite loop on Enum.take/2 with negative index on empty enumerable[File] Properly handle permissions errors cascading from parent in File.mkdir_p/1[Inspect] Inspect ill-formed structs as maps[Kernel] Properly increment metadata newline when ? is followed by a literal newline character[Kernel] not_a_map.key now raises BadMapError for consistency with other map operations[Protocol] defstruct/1 and defexception/1 are now disabled inside defprotocol as to not allow defining structs/exceptions alongside a protocol[Regex] Fix Regex.split/2 returning too many results when the chunk being split on was empty (which can happen when using features such as /K)[Stream] Ensure Stream.transform/5 respects suspend command when its inner stream halts[URI] Several fixes to URI.merge/2 related to trailing slashes, trailing dots, and hostless base URIsExUnit[ExUnit.Assertions] Fix order of pinned variables in failure reports[ExUnit.Assertions] Raise if attempting to raise an assertion error with invalid message (not a binary)[ExUnit.Case] Do not crash on empty test unit groupsIEx[IEx] Abort pipelines when there is an error in any step along the wayMix[mix cmd] Preserve argument quoting in subcommands by no longer performing shell expansion. To revert to the previous behaviour, pass --shell before the command name[mix compile] Fix bug where reverting changes to an external resource (such as HEEx template) after a compilation error would make it so the source module would not be compiled[mix compile] Avoid failures when locking compilation across different users[mix compile] Fix race condition when renaming files used by the compilation lock[mix format] Ensure the formatter does not go over the specified limit in certain corner cases[mix release] Fix RELEASE_SYS_CONFIG for Windows 11[mix test] Ensure modules are preloaded in mix test --slowest-modules=N[mix xref graph] Provide more consistent output by considering strong connected components only when computing graphs3. Soft deprecations (no warnings emitted)Elixir[Inspect.Algebra] next_break_fits is deprecated in favor of optimistic/pessimistic groups[Node] Node.start/2-3 is deprecated in favor of Node.start/2 with a keyword listMix[mix compile] --no-protocol-consolidation is deprecated in favor of --no-consolidate-protocols for consistency with mix.exs configuration[mix compile.protocols] Protocol consolidation is now part of compile.elixir and the task itself has no effect4. Hard deprecationsElixir[Code] Warn if line-break characters outside of \r and \r\n are found in strings according to UX#55. This warning will be fast-tracked into an error for security reasons in Elixir v1.20, following a similar rule to bidirectional control characters. They will already raise if found in comments[Code] The on_undefined_variable: :warn is deprecated. Relying on undefined variables becoming function calls will not be supported in the future[File] Passing a callback as third argument to File.cp/3 is deprecated, pass it as a on_conflict: callback option instead[File] Passing a callback as third argument to File.cp_r/3 is deprecated, pass it as a on_conflict: callback option instead[Kernel] The struct update syntax, such as %URI{uri | path: "/foo/bar"}, now requires the given variable (or expression) to explicitly pattern match on the struct before it can be updated. This is because, thanks to the type system, pattern matching on structs can find more errors, more reliably, and we want to promote its usage. Once pattern matching is added, you may optionally convert the struct update syntax into the map update syntax %{uri | path: "/foo/bar"} with no less of typing guarantees[Kernel.ParallelCompiler] Passing return_diagnostics: true as an option is required on compile, compile_to_path and requireLogger[Logger] The :backends configuration is deprecated, either set the :default_handler to false or start backends in your application start callbackMix[mix] The :default_task, :preferred_cli_env, and :preferred_cli_target configuration inside def project in your mix.exs has been deprecated in favor of :default_task, :preferred_envs and :preferred_targets inside the def cli function[mix do] Using commas as task separator in mix do (such as mix do foo, bar) is deprecated, use + instead (as in mix do foo + bar)v1.18The CHANGELOG for v1.18 releases can be found in the v1.18 branch. Next Page → Introduction Search HexDocs Download ePub version Built using ExDoc (v0.38.4) for the Elixir programming language

```
String.Chars
```

**Pattern 5:** Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

```
defmodule Example do
  def run do
    fun = fn %{} -> :map end
    fun.("hello")
  end
end
```

**Pattern 6:** There are two potential regressions with this approach. The first one happens if you spawn processes during compilation which invoke other modules defined within the same project. For example:

```
defmodule MyLib.SomeModule do
  list = [...]

  Task.async_stream(list, fn item ->
    MyLib.SomeOtherModule.do_something(item)
  end)
end
```

**Pattern 7:** Elixir v1.19.0 Search documentation of Elixir Settings Kernel.SpecialForms (Elixir v1.19.0) View Source Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs. Summary Functions %struct{} Matches on or builds a struct. %{} Creates a map. &expr Capture operator. Captures or creates an anonymous function. left . right Dot operator. Defines a remote call, a call to an anonymous function, or an alias. __aliases__(args) Internal special form to hold aliases information. __block__(args) Internal special form for block expressions. __CALLER__ Returns the current calling environment as a Macro.Env struct. __cursor__(args) Internal special form for cursor position. __DIR__ Returns the absolute path of the directory of the current file as a binary. __ENV__ Returns the current environment information as a Macro.Env struct. __MODULE__ Returns the current module name as an atom or nil otherwise. __STACKTRACE__ Returns the stacktrace for the currently handled exception. left :: right Type operator. Used by types and bitstrings to specify types. <<args>> Defines a new bitstring. left = right Match operator. Matches the value on the right against the pattern on the left. alias(module, opts) alias/2 is used to set up aliases, often useful with modules' names. case(condition, clauses) Matches the given expression against the given clauses. cond(clauses) Evaluates the expression corresponding to the first clause that evaluates to a truthy value. fn(clauses) Defines an anonymous function. for(args) Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring. import(module, opts) Imports functions and macros from other modules. quote(opts, block) Gets the representation of any expression. receive(args) Checks if there is a message matching any of the given clauses in the current process mailbox. require(module, opts) Requires a module in order to use its macros. super(args) Calls the overridden function when overriding it with Kernel.defoverridable/1. try(args) Evaluates the given expressions and handles any error, exit, or throw that may have happened. unquote(expr) Unquotes the given expression inside a quoted expression. unquote_splicing(expr) Unquotes the given list expanding its arguments. with(args) Combine matching clauses. ^var Pin operator. Accesses an already bound variable in match clauses. {args} Creates a tuple. Functions %struct{} (macro) Matches on or builds a struct.A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.Structs are usually defined with the Kernel.defstruct/1 macro:defmodule User do defstruct name: "john", age: 27 endNow a struct can be created as follows:%User{}Underneath a struct is a map with a :__struct__ key pointing to the User module, where the keys are validated at compile-time:%User{} == %{__struct__: User, name: "john", age: 27}The struct fields can be given when building the struct:%User{age: 31} #=> %{__struct__: User, name: "john", age: 31}Or also on pattern matching to extract values out:%User{age: age} = userThe advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key :full_name in the User struct:%User{full_name: "john doe"}The map update syntax can also be used for updating structs:%{user | age: 28}Pattern matching on struct namesBesides allowing pattern matching on struct fields, such as:%User{age: age} = userStructs also allow pattern matching on the struct name:%struct_name{} = user struct_name #=> UserYou can also assign the struct name to _ when you want to check if something is a struct but you are not interested in its name:%_{} = user %{} (macro) Creates a map.See the Map module for more information about maps, their syntax, and ways to access and manipulate them.AST representationRegardless of whether => or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:iex> quote do ...> %{"a" => :b, c: :d} ...> end {:%{}, [], [{"a", :b}, {:c, :d}]} &expr (macro) Capture operator. Captures or creates an anonymous function.CaptureThe capture operator is most commonly used to capture a function with given name and arity from a module:iex> fun = &Kernel.is_atom/1 iex> fun.(:atom) true iex> fun.("string") falseIn the example above, we captured Kernel.is_atom/1 as an anonymous function and then invoked it.The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:&local_function/1Note that &local_function/1 creates a local capture, but &__MODULE__.local_function/1 or &imported_function/1 create a remote capture. For more information, refer to the "Functions" section in the Erlang Reference Manual.Whether a capture is local or remote has implications when using hot code reloading: local captures dispatch to the version of the module that existed at the time they were created, while remote captures dispatch to the current version of the module.See also Function.capture/3.Anonymous functionsThe capture operator can also be used to partially apply functions, where &1, &2 and so on can be used as value placeholders. For example:iex> double = &(&1 * 2) iex> double.(2) 4In other words, &(&1 * 2) is equivalent to fn x -> x * 2 end.We can partially apply a remote function with placeholder:iex> take_five = &Enum.take(&1, 5) iex> take_five.(1..10) [1, 2, 3, 4, 5]Another example while using an imported or local function:iex> first_elem = &elem(&1, 0) iex> first_elem.({0, 1}) 0The & operator can be used with more complex expressions:iex> fun = &(&1 + &2 + &3) iex> fun.(1, 2, 3) 6As well as with lists and tuples:iex> fun = &{&1, &2} iex> fun.(1, 2) {1, 2} iex> fun = &[&1 | &2] iex> fun.(1, [2, 3]) [1, 2, 3]The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &1, and that block expressions are not supported:# No placeholder, fails to compile. &(:foo) # Block expression, fails to compile. &(&1; &2) left . right (macro) Dot operator. Defines a remote call, a call to an anonymous function, or an alias.The dot (.) in Elixir can be used for remote calls:iex> String.downcase("FOO") "foo"In this example above, we have used . to invoke downcase in the String module, passing "FOO" as argument.The dot may be used to invoke anonymous functions too:iex> (fn n -> n end).(7) 7in which case there is a function on the left hand side.We can also use the dot for creating aliases:iex> Hello.World Hello.WorldThis time, we have joined two aliases, defining the final alias Hello.World.SyntaxThe right side of . may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:iex> Kernel.Sample Kernel.Sample iex> Kernel.length([1, 2, 3]) 3 iex> Kernel.+(1, 2) 3 iex> Kernel."+"(1, 2) 3Wrapping the function name in single- or double-quotes is always a remote call. Therefore Kernel."Foo" will attempt to call the function "Foo" and not return the alias Kernel.Foo. This is done by design as module names are more strict than function names.When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation:iex> negate = fn n -> -n end iex> negate.(7) -7Quoted expressionWhen . is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore):iex> quote do ...> String.downcase("FOO") ...> end {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}Note that we have an inner tuple, containing the atom :. representing the dot as first element:{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias String and the atom :downcase. The second argument in a remote call is always an atom.In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:iex> quote do ...> negate.(0) ...> end {{:., [], [{:negate, [], __MODULE__}]}, [], [0]}When the right side is an alias (i.e. starts with uppercase), we get instead:iex> quote do ...> Hello.World ...> end {:__aliases__, [alias: false], [:Hello, :World]}We go into more details about aliases in the __aliases__/1 special form documentation.UnquotingWe can also use unquote to generate a remote call in a quoted expression:iex> x = :downcase iex> quote do ...> String.unquote(x)("FOO") ...> end {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}Similar to Kernel."FUNCTION_NAME", unquote(x) will always generate a remote call, independent of the value of x. To generate an alias via the quoted expression, one needs to rely on Module.concat/2:iex> x = Sample iex> quote do ...> Module.concat(String, unquote(x)) ...> end {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [], [{:__aliases__, [alias: false], [:String]}, Sample]} __aliases__(args) (macro) Internal special form to hold aliases information.It is usually compiled to an atom:iex> quote do ...> Foo.Bar ...> end {:__aliases__, [alias: false], [:Foo, :Bar]}Elixir represents Foo.Bar as __aliases__ so calls can be unambiguously identified by the operator :.. For example:iex> quote do ...> Foo.bar() ...> end {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}Whenever an expression iterator sees a :. as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom.On the other hand, aliases hold some properties:The head element of aliases can be any term that must expand to an atom at compilation time.The tail elements of aliases are guaranteed to always be atoms.When the head element of aliases is the atom :Elixir, no expansion happens. __block__(args) (macro) Internal special form for block expressions.This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:iex> quote do ...> 1 ...> 2 ...> 3 ...> end {:__block__, [], [1, 2, 3]} __CALLER__ (macro) Returns the current calling environment as a Macro.Env struct.In the environment you can access the filename, line numbers, set up aliases, the function and others. __cursor__(args) (macro) Internal special form for cursor position.This is the special form used whenever we need to represent the cursor position in Elixir's AST. See Code.Fragment for more information. __DIR__ (macro) Returns the absolute path of the directory of the current file as a binary.Although the directory can be accessed as Path.dirname(__ENV__.file), this macro is a convenient shortcut. __ENV__ (macro) Returns the current environment information as a Macro.Env struct.In the environment you can access the current filename, line numbers, set up aliases, the current function and others. __MODULE__ (macro) Returns the current module name as an atom or nil otherwise.Although the module can be accessed in the __ENV__/0, this macro is a convenient shortcut. __STACKTRACE__ (since 1.7.0) (macro) Returns the stacktrace for the currently handled exception.It is available only in the catch and rescue clauses of try/1 expressions and function definitions.To retrieve the stacktrace of the current process, use Process.info(self(), :current_stacktrace) instead. left :: right (macro) Type operator. Used by types and bitstrings to specify types.This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:@type number :: integer | float @spec add(number, number) :: numberIt may also be used in bit strings to specify the type of a given bit segment:<<int::integer-little, rest::bits>> = bitsRead the documentation on the Typespecs page and <<>>/1 for more information on typespecs and bitstrings respectively. <<args>> (macro) Defines a new bitstring.Examplesiex> <<1, 2, 3>> <<1, 2, 3>>TypesA bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:integerfloatbits (alias for bitstring)bitstringbinarybytes (alias for binary)utf8utf16utf32When no type is specified, the default is integer:iex> <<1, 2, 3>> <<1, 2, 3>>Elixir also accepts by default the segment to be a literal string which expands to integers:iex> <<0, "foo">> <<0, 102, 111, 111>>You can use one of utf8 (the default), utf16, and utf32 to control how the string is encoded:iex> <<"foo"::utf16>> <<0, 102, 0, 111, 0, 111>>Which is equivalent to writing:iex> <<?f::utf16, ?o::utf16, ?o::utf16>> <<0, 102, 0, 111, 0, 111>>At runtime, binaries need to be explicitly tagged as binary:iex> rest = "oo" iex> <<102, rest::binary>> "foo"Otherwise we get an ArgumentError when constructing the binary:rest = "oo" <<102, rest>> ** (ArgumentError) argument errorOptionsMany options can be given by using - as separator. Order is arbitrary, so the following are all equivalent:<<102::integer-native, rest::binary>> <<102::native-integer, rest::binary>> <<102::unsigned-big-integer, rest::binary>> <<102::unsigned-big-integer-size(8), rest::binary>> <<102::unsigned-big-integer-8, rest::binary>> <<102::8-integer-big-unsigned, rest::binary>> <<102, rest::binary>>Unit and SizeThe length of the match is equal to the unit (a number of bits) times the size (the number of repeated segments of length unit).TypeDefault Unitinteger1 bitfloat1 bitbinary8 bitsSizes for types are a bit more nuanced. The default size for integers is 8.For floats, it is 64. For floats, size * unit must result in 16, 32, or 64, corresponding to IEEE 754 binary16, binary32, and binary64, respectively.For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:iex> <<name::binary-size(5), " the ", species::binary>> = <<"Frank the Walrus">> "Frank the Walrus" iex> {name, species} {"Frank", "Walrus"}The size can be a variable or any valid guard expression:iex> name_size = 5 iex> <<name::binary-size(^name_size), " the ", species::binary>> = <<"Frank the Walrus">> iex> {name, species} {"Frank", "Walrus"}The size can access prior variables defined in the binary itself:iex> <<name_size::size(8), name::binary-size(name_size), " the ", species::binary>> = <<5, "Frank the Walrus">> iex> {name, species} {"Frank", "Walrus"}However, it cannot access variables defined in the match outside of the binary/bitstring:{name_size, <<name::binary-size(name_size), _rest::binary>>} = {5, <<"Frank the Walrus">>} ** (CompileError): undefined variable "name_size" in bitstring segmentFailing to specify the size for the non-last causes compilation to fail:<<name::binary, " the ", species::binary>> = <<"Frank the Walrus">> ** (CompileError): a binary field without size is only allowed at the end of a binary patternShortcut SyntaxSize and unit can also be specified using a syntax shortcut when passing integer values:iex> x = 1 iex> <<x::8>> == <<x::size(8)>> true iex> <<x::8*4>> == <<x::size(8)-unit(4)>> trueThis syntax reflects the fact the effective size is given by multiplying the size by the unit.ModifiersSome types have associated modifiers to clear up ambiguity in byte representation.ModifierRelevant Type(s)signedintegerunsigned (default)integerlittleinteger, float, utf16, utf32big (default)integer, float, utf16, utf32nativeinteger, float, utf16, utf32SignIntegers can be signed or unsigned, defaulting to unsigned.iex> <<int::integer>> = <<-100>> <<156>> iex> int 156 iex> <<int::integer-signed>> = <<-100>> <<156>> iex> int -100signed and unsigned are only used for matching binaries (see below) and are only used for integers.iex> <<-100::signed, _rest::binary>> = <<-100, "foo">> <<156, 102, 111, 111>>EndiannessElixir has three options for endianness: big, little, and native. The default is big:iex> <<number::little-integer-size(16)>> = <<0, 1>> <<0, 1>> iex> number 256 iex> <<number::big-integer-size(16)>> = <<0, 1>> <<0, 1>> iex> number 1native is determined by the VM at startup and will depend on the host operating system.Binary/Bitstring MatchingBinary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching.Binary matching can be used by itself to extract information from binaries:iex> <<"Hello, ", place::binary>> = "Hello, World" "Hello, World" iex> place "World"Or as a part of function definitions to pattern match:defmodule ImageType do @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8), 13::size(8), 10::size(8), 26::size(8), 10::size(8)>> @jpg_signature <<255::size(8), 216::size(8)>> def type(<<@png_signature, _rest::binary>>), do: :png def type(<<@jpg_signature, _rest::binary>>), do: :jpg def type(_), do: :unknown endPerformance & OptimizationsThe Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the bin_opt_info compiler option:ERL_COMPILER_OPTIONS=bin_opt_info mix compileTo learn more about specific optimizations and performance considerations, check out the "Constructing and matching binaries" chapter of the Erlang's Efficiency Guide. left = right (macro) Match operator. Matches the value on the right against the pattern on the left. alias(module, opts) (macro) alias/2 is used to set up aliases, often useful with modules' names.Examplesalias/2 can be used to set up an alias for any module:defmodule Math do alias MyKeyword, as: Keyword endIn the example above, we have set up MyKeyword to be aliased as Keyword. So now, any reference to Keyword will be automatically replaced by MyKeyword.In case one wants to access the original Keyword, it can be done by accessing Elixir:Keyword.values #=> uses MyKeyword.values Elixir.Keyword.values #=> uses Keyword.valuesNote that calling alias without the :as option automatically sets an alias based on the last part of the module. For example:alias Foo.Bar.BazIs the same as:alias Foo.Bar.Baz, as: BazWe can also alias multiple modules in one line:alias Foo.{Bar, Baz, Biz}Is the same as:alias Foo.Bar alias Foo.Baz alias Foo.BizLexical scopeimport/2, require/2 and alias/2 are called directives and all have lexical scope. This means you can set up aliases inside specific functions and it won't affect the overall scope.WarningsIf you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.Both warning behaviors could be changed by explicitly setting the :warn option to true or false. case(condition, clauses) (macro) Matches the given expression against the given clauses.case/2 relies on pattern matching and guards to choose which clause to execute. If your logic cannot be expressed within patterns and guards, consider using if/2 or cond/1 instead.Examplesiex> string_date = "2015-01-23" iex> case Date.from_iso8601(string_date) do ...> {:ok, date} -> date ...> {:error, _reason} -> Date.utc_today() ...> end ~D[2015-01-23]In the example above, we match the result of Date.from_iso8601/1 against each clause "head" and execute the clause "body" corresponding to the first clause that matches. In our case string_date contains a string with a valid ISO 8601 representation of date. The function returns {:ok, ~D[2015-01-23]}, so the {:ok, date} clause is matched.If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like _) which will always match.iex> x = 10 iex> case x do ...> 0 -> "This clause won't match" ...> _ -> "This clause would match any value (x = #{x})" ...> end "This clause would match any value (x = 10)"If you find yourself nesting case expressions inside case expressions, consider using with/1.Variable handlingNote that variables bound in a clause do not leak to the outer context:iex> case {:ok, 7} do ...> {:ok, value} -> value ...> :error -> nil ...> end ...> value ** (CompileError) undefined variable "value"Variables in the outer context cannot be overridden either:iex> value = 7 iex> case 3 > 5 do ...> false -> ...> value = 3 ...> value + 2 ...> true -> ...> 3 ...> end iex> value 7In the example above, value is going to be 7 regardless of which clause matched. The variable value bound in the clause and the variable value bound in the outer context are two entirely separate variables.If you want to pattern match against an existing variable, you need to use the ^/1 operator:iex> x = 1 iex> case 10 do ...> ^x -> "Won't match" ...> _ -> "Will match" ...> end "Will match"Using guards to match against multiple valuesWhile it is not possible to match against multiple patterns in a single clause, it's possible to match against multiple values by using guards:iex> case :two do ...> value when value in [:one, :two] -> ...> "#{value} has been matched" ...> :three -> ...> "three has been matched" ...> end "two has been matched" cond(clauses) (macro) Evaluates the expression corresponding to the first clause that evaluates to a truthy value.ExamplesThe following example has a single clause that always evaluates to true:iex> cond do ...> hd([1, 2, 3]) -> "1 is considered as true" ...> end "1 is considered as true"If all clauses evaluate to nil or false, cond raises an error. For this reason, it may be necessary to add a final always-truthy condition (anything non-false and non-nil), which will always match:iex> cond do ...> 1 + 1 == 1 -> "This will never match" ...> 2 * 2 != 4 -> "Nor this" ...> true -> "This will" ...> end "This will"If your cond has two clauses, and the last one falls back to true, you may consider using if/2 instead. fn(clauses) (macro) Defines an anonymous function.See Function for more information.Examplesiex> add = fn a, b -> a + b end iex> add.(1, 2) 3Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:iex> negate = fn ...> true -> false ...> false -> true ...> end iex> negate.(false) true for(args) (macro) Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.Let's start with an example:iex> for n <- [1, 2, 3, 4], do: n * 2 [2, 4, 6, 8]A comprehension accepts many generators and filters. for uses the <- operator to extract values from the enumerable on its right side and match them against the pattern on the left. We call them generators:# A list generator: iex> for n <- [1, 2, 3, 4], do: n * 2 [2, 4, 6, 8] # A comprehension with two generators iex> for x <- [1, 2], y <- [2, 3], do: x * y [2, 3, 4, 6]Filters can also be given:# A comprehension with a generator and a filter iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n [2, 4, 6]Filters must evaluate to truthy values (everything but nil and false). If a filter is falsy, then the current value is discarded.Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of <-:iex> users = [user: "john", admin: "meg", guest: "barbara"] iex> for {type, name} when type != :guest <- users do ...> String.upcase(name) ...> end ["JOHN", "MEG"]Bitstring generators are also supported and are very useful when you need to organize bitstring streams:iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>> iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b} [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.Variable assignments inside filters must still return a truthy value, otherwise values are discarded. Let's see an example. Imagine you have a keyword list where the key is a programming language and the value is its direct parent. Then let's try to compute the grandparent of each language. You could try this:iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil] iex> for {language, parent} <- languages, grandparent = languages[parent], do: {language, grandparent} [elixir: :prolog]Given the grandparents of Erlang and Prolog were nil, those values were filtered out. If you don't want this behavior, a simple option is to move the filter inside the do-block:iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil] iex> for {language, parent} <- languages do ...> grandparent = languages[parent] ...> {language, grandparent} ...> end [elixir: :prolog, erlang: nil, prolog: nil]However, such option is not always available, as you may have further filters. An alternative is to convert the filter into a generator by wrapping the right side of = in a list:iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil] iex> for {language, parent} <- languages, grandparent <- [languages[parent]], do: {language, grandparent} [elixir: :prolog, erlang: nil, prolog: nil]The :into and :uniq optionsIn the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an :into option, that accepts any structure as long as it implements the Collectable protocol.For example, we can use bitstring generators with the :into option to easily remove all spaces in a string:iex> for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>> "helloworld"The IO module provides streams, that are both Enumerable and Collectable, here is an upcase echo server using comprehensions:for line <- IO.stream(), into: IO.stream() do String.upcase(line) endSimilarly, uniq: true can also be given to comprehensions to guarantee the results are only added to the collection if they were not returned before. For example:iex> for x <- [1, 1, 2, 3], uniq: true, do: x * 2 [2, 4, 6] iex> for <<x <- "abcabc">>, uniq: true, into: "", do: <<x - 32>> "ABC"The :reduce optionAvailable since Elixir v1.8.While the :into option allows us to customize the comprehension behavior to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough.For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string "AbCabCABc", we want to return the map %{"a" => 1, "b" => 2, "c" => 1}.If we were to use :into, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke Enum.reduce/3 to build a map, for example:iex> letters = for <<x <- "AbCabCABc">>, x in ?a..?z, do: <<x>> iex> Enum.reduce(letters, %{}, fn x, acc -> Map.update(acc, x, 1, & &1 + 1) end) %{"a" => 1, "b" => 2, "c" => 1}While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive.Luckily, comprehensions also support the :reduce option, which would allow us to fuse both steps above into a single step:iex> for <<x <- "AbCabCABc">>, x in ?a..?z, reduce: %{} do ...> acc -> Map.update(acc, <<x>>, 1, & &1 + 1) ...> end %{"a" => 1, "b" => 2, "c" => 1}When the :reduce key is given, its value is used as the initial accumulator and the do block must be changed to use -> clauses, where the left side of -> receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned. import(module, opts) (macro) Imports functions and macros from other modules.import/2 allows one to easily access functions or macros from other modules without using the qualified name.ExamplesIf you are using several functions from a given module, you can import those functions and reference them as local functions, for example:iex> import List iex> flatten([1, [2], 3]) [1, 2, 3]SelectorBy default, Elixir imports functions and macros from the given module, except the ones starting with an underscore (which are usually callbacks):import ListA developer can filter to import only functions, macros, or sigils (which can be functions or macros) via the :only option:import List, only: :functions import List, only: :macros import Kernel, only: :sigilsAlternatively, Elixir allows a developer to pass pairs of name/arities to :only or :except as a fine grained control on what to import (or not):import List, only: [flatten: 1] import String, except: [split: 2]Importing the same module again will erase the previous imports, except when the except option is used, which is always exclusive on a previously declared import/2. If there is no previous import, then it applies to all functions and macros in the module. For example:import List, only: [flatten: 1, keyfind: 4] import List, except: [flatten: 1]After the two import calls above, only List.keyfind/4 will be imported.Underscore functionsBy default functions starting with _ are not imported. If you really want to import a function starting with _ you must explicitly include it in the :only selector.import File.Stream, only: [__build__: 3]Lexical scopeIt is important to note that import/2 is lexical. This means you can import specific macros inside specific functions:defmodule Math do def some_function do # 1) Disable "if/2" from Kernel import Kernel, except: [if: 2] # 2) Require the new "if/2" macro from MyMacros import MyMacros # 3) Use the new macro if do_something, it_works end endIn the example above, we imported macros from MyMacros, replacing the original if/2 implementation by our own within that specific function. All other functions in that module will still be able to use the original one.WarningsIf you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.Both warning behaviors could be changed by explicitly setting the :warn option to true or false.Ambiguous function/macro namesIf two modules A and B are imported and they both contain a foo function with an arity of 1, an error is only emitted if an ambiguous call to foo/1 is actually made; that is, the errors are emitted lazily, not eagerly. quote(opts, block) (macro) Gets the representation of any expression.Examplesiex> quote do ...> sum(1, 2, 3) ...> end {:sum, [], [1, 2, 3]}Elixir's AST (Abstract Syntax Tree)Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example:{:sum, [], [1, 2, 3]}The tuple above represents a function call to sum passing 1, 2 and 3 as arguments. The tuple elements are:The first element of the tuple is always an atom or another tuple in the same representation.The second element of the tuple represents metadata.The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).Besides the tuple described above, Elixir has a few literals that are also part of its AST. Those literals return themselves when quoted. They are::sum #=> Atoms 1 #=> Integers 2.0 #=> Floats [1, 2] #=> Lists "strings" #=> Strings {key, value} #=> Tuples with two elementsAny other value, such as a map or a four-element tuple, must be escaped (Macro.escape/1) before being introduced into an AST.Options:bind_quoted - passes a binding to the macro. Whenever a binding is given, unquote/1 is automatically disabled.:context - sets the resolution context.:generated - marks the given chunk as generated so it does not emit warnings. It is also useful to prevent the type system or dialyzer from reporting errors when macros generate unused clauses.:file - sets the quoted expressions to have the given file.:line - sets the quoted expressions to have the given line.:location - when set to :keep, keeps the current line and file from quote. Read the "Stacktrace information" section below for more information.:unquote - when false, disables unquoting. This means any unquote call will be kept as is in the AST, instead of replaced by the unquote arguments. For example:iex> quote do ...> unquote("hello") ...> end "hello" iex> quote unquote: false do ...> unquote("hello") ...> end {:unquote, [], ["hello"]}Quote and macrosquote/2 is commonly used with macros for code generation. As an exercise, let's define a macro that multiplies a number by itself (squared). In practice, there is no reason to define such a macro (and it would actually be seen as a bad practice), but it is simple enough that it allows us to focus on the important aspects of quotes and macros:defmodule Math do defmacro squared(x) do quote do unquote(x) * unquote(x) end end endWe can invoke it as:import Math IO.puts("Got #{squared(5)}")At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, squared(5) becomes 5 * 5. The argument 5 is duplicated in the produced code, we can see this behavior in practice though because our macro actually has a bug:import Math my_number = fn -> IO.puts("Returning 5") 5 end IO.puts("Got #{squared(my_number.())}")The example above will print:Returning 5 Returning 5 Got 25Notice how "Returning 5" was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:squared(my_number.())Actually expands to:my_number.() * my_number.()Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behavior, and that's why one of the first things you need to keep in mind when it comes to macros is to not unquote the same value more than once.Let's fix our macro:defmodule Math do defmacro squared(x) do quote do x = unquote(x) x * x end end endNow invoking squared(my_number.()) as before will print the value just once.In fact, this pattern is so common that most of the times you will want to use the bind_quoted option with quote/2:defmodule Math do defmacro squared(x) do quote bind_quoted: [x: x] do x * x end end end:bind_quoted will translate to the same code as the example above. :bind_quoted can be used in many cases and is seen as good practice, not only because it helps prevent us from running into common mistakes, but also because it allows us to leverage other tools exposed by macros, such as unquote fragments discussed in some sections below.Before we finish this brief introduction, you will notice that, even though we defined a variable x inside our quote:quote do x = unquote(x) x * x endWhen we call:import Math squared(5) x ** (CompileError) undefined variable "x"We can see that x did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well.Hygiene in variablesConsider the following example:defmodule Hygiene do defmacro no_interference do quote do a = 1 end end end require Hygiene a = 10 Hygiene.no_interference() a #=> 10In the example above, a returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the var! macro:defmodule NoHygiene do defmacro interference do quote do var!(a) = 1 end end end require NoHygiene a = 10 NoHygiene.interference() a #=> 1You cannot even access variables defined in the same module unless you explicitly give it a context:defmodule Hygiene do defmacro write do quote do a = 1 end end defmacro read do quote do a end end end require Hygiene Hygiene.write() Hygiene.read() ** (CompileError) undefined variable "a" (context Hygiene)For such, you can explicitly pass the current module scope as argument:defmodule ContextHygiene do defmacro write do quote do var!(a, ContextHygiene) = 1 end end defmacro read do quote do var!(a, ContextHygiene) end end end require ContextHygiene ContextHygiene.write() ContextHygiene.read() #=> 1The contexts of a variable is identified by the third element of the tuple. The default context is nil and quote assigns another context to all variables within:quote(do: var) #=> {:var, [], Elixir}In case of variables returned by macros, there may also be a :counter key in the metadata, which is used to further refine its contexts and guarantee isolation between macro invocations as seen in the previous example.Hygiene in aliasesAliases inside quote are hygienic by default. Consider the following example:defmodule Hygiene do alias Map, as: M defmacro no_interference do quote do M.new() end end end require Hygiene Hygiene.no_interference() #=> %{}Note that, even though the alias M is not available in the context the macro is expanded, the code above works because M still expands to Map.Similarly, even if we defined an alias with the same name before invoking a macro, it won't affect the macro's result:defmodule Hygiene do alias Map, as: M defmacro no_interference do quote do M.new() end end end require Hygiene alias SomethingElse, as: M Hygiene.no_interference() #=> %{}In some cases, you want to access an alias or a module defined in the caller. For such, you can use the alias! macro:defmodule Hygiene do # This will expand to Elixir.Nested.hello() defmacro no_interference do quote do Nested.hello() end end # This will expand to Nested.hello() for # whatever is Nested in the caller defmacro interference do quote do alias!(Nested).hello() end end end defmodule Parent do defmodule Nested do def hello, do: "world" end require Hygiene Hygiene.no_interference() ** (UndefinedFunctionError) ... Hygiene.interference() #=> "world" endHygiene in importsSimilar to aliases, imports in Elixir are hygienic. Consider the following code:defmodule Hygiene do defmacrop get_length do quote do length([1, 2, 3]) end end def return_length do import Kernel, except: [length: 1] get_length end end Hygiene.return_length() #=> 3Notice how Hygiene.return_length/0 returns 3 even though the Kernel.length/1 function is not imported. In fact, even if return_length/0 imported a function with the same name and arity from another module, it wouldn't affect the function result:def return_length do import String, only: [length: 1] get_length endCalling this new return_length/0 will still return 3 as result.Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call length([1, 2, 3]) inside quote, but no length/1 function is available, it is then expanded in the caller:defmodule Lazy do defmacrop get_length do import Kernel, except: [length: 1] quote do length("hello") end end def return_length do import Kernel, except: [length: 1] import String, only: [length: 1] get_length end end Lazy.return_length() #=> 5Stacktrace informationWhen defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example:# adder.ex defmodule Adder do @doc "Defines a function that adds two numbers" defmacro defadd do quote location: :keep do def add(a, b), do: a + b end end end # sample.ex defmodule Sample do import Adder defadd end require Sample Sample.add(:one, :two) ** (ArithmeticError) bad argument in arithmetic expression adder.ex:5: Sample.add/2When using location: :keep and invalid arguments are given to Sample.add/2, the stacktrace information will point to the file and line inside the quote. Without location: :keep, the error is reported to where defadd was invoked. location: :keep affects only definitions inside the quote.location: :keep and unquoteDo not use location: :keep if the function definition also unquotes some of the macro arguments. If you do so, Elixir will store the file definition of the current location but the unquoted arguments may contain line information of the macro caller, leading to erroneous stacktraces.Binding and unquote fragmentsElixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:kv = [foo: 1, bar: 2] Enum.each(kv, fn {k, v} -> def unquote(k)(), do: unquote(v) end)In the example above, we have generated the functions foo/0 and bar/0 dynamically. Note the parentheses in unquote(k)() are important, otherwise we would try to define a function as def :foo instead of def foo().Now, imagine that we want to convert this functionality into a macro:defmacro defkv(kv) do Enum.map(kv, fn {k, v} -> quote do def unquote(k)(), do: unquote(v) end end) endWe can invoke this macro as:defkv [foo: 1, bar: 2]However, we can't invoke it as follows:kv = [foo: 1, bar: 2] defkv kvThis is because the macro is expecting its arguments to be a keyword list at compilation time. Since in the example above we are passing the representation of the variable kv, our code fails.This is actually a common pitfall when developing macros. We are assuming a particular shape at compilation time, within the macro implementation. One may try to work around it by unquoting the variable inside the quoted expression:defmacro defkv(kv) do quote do Enum.each(unquote(kv), fn {k, v} -> def unquote(k)(), do: unquote(v) end) end endIf you try to run our new macro, you will notice it won't even compile, complaining that the variables k and v do not exist. This is because the two unquotes in the call above are meant to run at distinct moments: unquote(kv) applies to the immediate quote, unquote(k) is an unquote fragment.One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the kv representation into the tree. That's when the :bind_quoted option comes to the rescue (again!). By using :bind_quoted, we can automatically disable unquoting while still injecting the desired variables into the tree:defmacro defkv(kv) do quote bind_quoted: [kv: kv] do Enum.each(kv, fn {k, v} -> def unquote(k)(), do: unquote(v) end) end endIn fact, the :bind_quoted option is recommended every time one desires to inject a value into the quote. receive(args) (macro) Checks if there is a message matching any of the given clauses in the current process mailbox.If there is no matching message, the current process waits until a matching message arrives or until after a given timeout value.Any new and existing messages that do not match will remain in the mailbox.Examplesiex> send(self(), {:selector, 5, :quantity}) iex> receive do ...> {:selector, number, name} when is_integer(number) -> ...> name ...> name when is_atom(name) -> ...> name ...> _ -> ...> IO.puts(:stderr, "Unexpected message received") ...> end :quantityAn optional after clause can be given in case no matching message is received during the given timeout period, specified in milliseconds:iex> receive do ...> {:selector, number, name} when is_integer(number) -> ...> name ...> name when is_atom(name) -> ...> name ...> _ -> ...> IO.puts(:stderr, "Unexpected message received") ...> after ...> 10 -> ...> "No message in 10 milliseconds" ...> end "No message in 10 milliseconds"The after clause can be specified even if there are no match clauses. The timeout value given to after can be any expression evaluating to one of the allowed values::infinity - the process should wait indefinitely for a matching message, this is the same as not using the after clause0 - if there is no matching message in the mailbox, the timeout will occur immediatelypositive integer smaller than or equal to 4_294_967_295 (0xFFFFFFFF in hexadecimal notation) - it should be possible to represent the timeout value as an unsigned 32-bit integer.Variable handlingThe receive/1 special form handles variables exactly as the case/2 special macro. For more information, check the docs for case/2. require(module, opts) (macro) Requires a module in order to use its macros.ExamplesPublic functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.Let's suppose you created your own if/2 implementation in the module MyMacros. If you want to invoke it, you need to first explicitly require the MyMacros:defmodule Math do require MyMacros MyMacros.if do_something, it_works endAn attempt to call a macro that was not loaded will raise an error.Alias shortcutrequire/2 also accepts :as as an option so it automatically sets up an alias. Please check alias/2 for more information. super(args) (macro) Calls the overridden function when overriding it with Kernel.defoverridable/1.See Kernel.defoverridable/1 for more information and documentation. try(args) (macro) Evaluates the given expressions and handles any error, exit, or throw that may have happened.Examplestry do do_something_that_may_fail(some_arg) rescue ArgumentError -> IO.puts("Invalid argument given") catch value -> IO.puts("Caught #{inspect(value)}") else value -> IO.puts("Success! The result was #{inspect(value)}") after IO.puts("This is printed regardless if it failed or succeeded") endThe rescue clause is used to handle exceptions while the catch clause can be used to catch thrown values and exits. The else clause can be used to control flow based on the result of the expression. catch, rescue, and else clauses work based on pattern matching (similar to the case special form).Calls inside try/1 are not tail recursive since the VM needs to keep the stacktrace in case an exception happens. To retrieve the stacktrace, access __STACKTRACE__/0 inside the rescue or catch clause.rescue clausesBesides relying on pattern matching, rescue clauses provide some conveniences around exceptions that allow one to rescue an exception by its name. All the following formats are valid patterns in rescue clauses:Rescue a single exception without binding the exception to a variable:iex> try do ...> 1 / 0 ...> rescue ...> ArithmeticError -> :rescued ...> end :rescuedRescue any of the given exception without binding:iex> try do ...> 1 / 0 ...> rescue ...> [ArithmeticError, ArgumentError] -> :rescued ...> end :rescuedRescue and bind the exception to the variable x:iex> try do ...> 1 / 0 ...> rescue ...> x in [ArithmeticError] -> [:rescued, is_exception(x)] ...> end [:rescued, true]Rescue different errors with separate clauses:iex> try do ...> 1 / 0 ...> rescue ...> ArgumentError -> :rescued_argument_error ...> ArithmeticError -> :rescued_arithmetic_error ...> end :rescued_arithmetic_errorRescue all kinds of exceptions and bind the rescued exception to the variable x:iex> try do ...> 1 / 0 ...> rescue ...> x -> [:rescued, is_exception(x)] ...> end [:rescued, true]Erlang errorsErlang errors are transformed into Elixir ones when rescuing:iex> try do ...> :erlang.error(:badarg) ...> rescue ...> ArgumentError -> :rescued ...> end :rescuedThe most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic ErlangError:iex> try do ...> :erlang.error(:unknown) ...> rescue ...> ErlangError -> :rescued ...> end :rescuedIn fact, ErlangError can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier :badarg error too, prior to transformation:iex> try do ...> :erlang.error(:badarg) ...> rescue ...> ErlangError -> :rescued ...> end :rescuedcatch clausesThe catch clause can be used to catch thrown values, exits, and errors.Catching thrown valuescatch can be used to catch values thrown by Kernel.throw/1:iex> try do ...> throw(:some_value) ...> catch ...> thrown_value -> ...> "Thrown value: #{inspect(thrown_value)}" ...> end "Thrown value: :some_value"Catching values of any kindThe catch clause also supports catching exits and errors. To do that, it allows matching on both the kind of the caught value as well as the value itself:iex> try do ...> exit(:shutdown) ...> catch ...> :exit, value -> ...> "Exited with value #{inspect(value)}" ...> end "Exited with value :shutdown" iex> try do ...> exit(:shutdown) ...> catch ...> kind, value when kind in [:exit, :throw] -> ...> "Caught exit or throw with value #{inspect(value)}" ...> end "Caught exit or throw with value :shutdown"The catch clause also supports :error alongside :exit and :throw as in Erlang, although this is commonly avoided in favor of raise/rescue control mechanisms. One reason for this is that when catching :error, the error is not automatically transformed into an Elixir error:iex> try do ...> :erlang.error(:badarg) ...> catch ...> :error, :badarg -> :rescued ...> end :rescuedafter clausesAn after clause allows you to define cleanup logic that will be invoked both when the block of code passed to try/1 succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the after clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.File.write!("tmp/story.txt", "Hello, World") try do do_something_with("tmp/story.txt") after File.rm("tmp/story.txt") endAlthough after clauses are invoked whether or not there was an error, they do not modify the return value. Both of the following examples print a message to STDOUT and return :returned:try do :returned after IO.puts("This message will be printed") :not_returned end #=> :returned try do raise "boom" rescue _ -> :returned after IO.puts("This message will be printed") :not_returned end #=> :returnedelse clauseselse clauses allow the result of the body passed to try/1 to be pattern matched on:iex> x = 2 ...> try do ...> 1 / x ...> rescue ...> ArithmeticError -> :infinity ...> else ...> y when y < 1 and y > -1 -> :small ...> _ -> :large ...> end :smallIf an else clause is not present and no exceptions are raised, the result of the expression will be returned:iex> x = 5 iex> try do ...> 1 / x ...> rescue ...> ArithmeticError -> :infinity ...> end 0.2However, when an else clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a catch or rescue in the same try:iex> x = 1 iex> try do ...> try do ...> 1 / x ...> rescue ...> # The TryClauseError cannot be rescued here: ...> TryClauseError -> :error_a ...> else ...> 0.5 -> :small ...> end ...> rescue ...> # The TryClauseError is rescued here: ...> TryClauseError -> :error_b ...> end :error_bSimilarly, an exception inside an else clause is not caught or rescued inside the same try:iex> x = 1 iex> try do ...> try do ...> 1 / x ...> catch ...> # The exit(1) call below can not be caught here: ...> :exit, _ -> :exit_a ...> else ...> _ -> exit(1) ...> end ...> catch ...> # The exit is caught here: ...> :exit, _ -> :exit_b ...> end :exit_bThis means the VM no longer needs to keep the stacktrace once inside an else clause and so tail recursion is possible when using a try with a tail call as the final call inside an else clause. The same is true for rescue and catch clauses.Only the result of the tried expression falls down to the else clause. If the try ends up in the rescue or catch clauses, their result will not fall down to else:iex> try do ...> throw(:catch_this) ...> catch ...> :throw, :catch_this -> :it_was_caught ...> else ...> # :it_was_caught will not fall down to this "else" clause. ...> other -> {:else, other} ...> end :it_was_caughtVariable handlingSince an expression inside try may not have been evaluated due to an exception, any variable created inside try cannot be accessed externally. For instance:try do x = 1 do_something_that_may_fail(same_arg) :ok catch _, _ -> :failed end x #=> unbound variable "x"In the example above, x cannot be accessed since it was defined inside the try clause. A common practice to address this issue is to return the variables defined inside try:x = try do x = 1 do_something_that_may_fail(same_arg) x catch _, _ -> :failed end unquote(expr) (macro) Unquotes the given expression inside a quoted expression.This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to unquote any value, such as a map or a four-element tuple, you should call Macro.escape/1 before unquoting.ExamplesImagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:value = quote do 13 end quote do sum(1, value, 3) endWhich the argument for the :sum function call is not the expected result:{:sum, [], [1, {:value, [], Elixir}, 3]}For this, we use unquote:iex> value = ...> quote do ...> 13 ...> end iex> quote do ...> sum(1, unquote(value), 3) ...> end {:sum, [], [1, 13, 3]}If you want to unquote a value that is not a quoted expression, such as a map, you need to call Macro.escape/1 before:iex> value = %{foo: :bar} iex> quote do ...> process_map(unquote(Macro.escape(value))) ...> end {:process_map, [], [{:%{}, [], [foo: :bar]}]}If you forget to escape it, Elixir will raise an error when compiling the code. unquote_splicing(expr) (macro) Unquotes the given list expanding its arguments.Similar to unquote/1.Examplesiex> values = [2, 3, 4] iex> quote do ...> sum(1, unquote_splicing(values), 5) ...> end {:sum, [], [1, 2, 3, 4, 5]}Also can be used in block context, outside of function arguments. Though, it is still required to be wrapped into parentheses.iex> requires = for module <- [Integer, Logger] do ...> quote do ...> require unquote(module) ...> end ...> end iex> block = quote do: (unquote_splicing(requires)) iex> Macro.to_string(block) "require Integer\nrequire Logger" with(args) (macro) Combine matching clauses.One of the ways to understand with is to show which code patterns it improves. Imagine you have a map where the fields width and height are optional and you want to compute its area, as {:ok, area} or return :error. We could implement this function as:def area(opts) do case Map.fetch(opts, :width) do {:ok, width} -> case Map.fetch(opts, :height) do {:ok, height} -> {:ok, width * height} :error -> :error end :error -> :error end endwhen called as area(%{width: 10, height: 15}), it should return {:ok, 150}. If any of the fields are missing, it returns :error.While the code above works, it is quite verbose. Using with, we could rewrite it as:def area(opts) do with {:ok, width} <- Map.fetch(opts, :width), {:ok, height} <- Map.fetch(opts, :height) do {:ok, width * height} end endInstead of defining nested cases with clauses, we use with alongside the PATTERN <- EXPRESSION operator to match expressions on its right side against the pattern on the left. Consider <- as a sibling to =, except that, while = raises in case of not matches, <- will simply abort the with chain and return the non-matched value.Let's give it a try on IEx:iex> opts = %{width: 10, height: 15} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, width * height} ...> end {:ok, 150}If all clauses match, the do block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:iex> opts = %{width: 10} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, width * height} ...> end :errorGuards can be used in patterns as well:iex> users = %{"melany" => "guest", "bob" => :admin} iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, "bob") do ...> {:ok, to_string(role)} ...> end {:ok, "admin"}As in for/1, variables bound inside with/1 won't be accessible outside of with/1.Expressions without <- may also be used in clauses. For instance, you can perform regular matches with the = operator:iex> width = nil iex> opts = %{width: 10, height: 15} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> double_width = width * 2, ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, double_width * height} ...> end {:ok, 300} iex> width nilThe behavior of any expression in a clause is the same as if it was written outside of with. For example, = will raise a MatchError instead of returning the non-matched value:with :foo = :bar, do: :ok ** (MatchError) no match of right hand side value: :barAs with any other function or macro call in Elixir, explicit parens can also be used around the arguments before the do-end block:iex> opts = %{width: 10, height: 15} iex> with( ...> {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) ...> ) do ...> {:ok, width * height} ...> end {:ok, 150}The choice between parens and no parens is a matter of preference.Else clausesAn else option can be given to modify what is being returned from with in the case of a failed match:iex> opts = %{width: 10} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, width * height} ...> else ...> :error -> ...> {:error, :wrong_data} ...> ...> _other_error -> ...> :unexpected_error ...> end {:error, :wrong_data}The else block works like a case: it can have multiple clauses, and the first match will be used. Variables bound inside with (such as width in this example) are not available in the else block.If an else block is used and there are no matching clauses, a WithClauseError exception is raised.Beware!Keep in mind that, one of potential drawback of with is that all failure clauses are flattened into a single else block. For example, take this code that checks if a given path points to an Elixir file and that it exists before creating a backup copy:with ".ex" <- Path.extname(path), true <- File.exists?(path) do backup_path = path <> ".backup" File.cp!(path, backup_path) {:ok, backup_path} else binary when is_binary(binary) -> {:error, :invalid_extension} false -> {:error, :missing_file} endNote how we are having to reconstruct the result types of Path.extname/1 and File.exists?/1 to build error messages. In this case, it is better to refactor the code so each <- already return the desired format in case of errors, like this:with :ok <- validate_extension(path), :ok <- validate_exists(path) do backup_path = path <> ".backup" File.cp!(path, backup_path) {:ok, backup_path} end defp validate_extension(path) do if Path.extname(path) == ".ex", do: :ok, else: {:error, :invalid_extension} end defp validate_exists(path) do if File.exists?(path), do: :ok, else: {:error, :missing_file} endNote how the code above is better organized and clearer once we make sure each <- in with returns a normalized format. ^var (macro) Pin operator. Accesses an already bound variable in match clauses.ExamplesElixir allows variables to be rebound via static single assignment:iex> x = 1 iex> x = x + 1 iex> x 2However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the ^ special form, colloquially known as the pin operator:iex> x = 1 iex> ^x = List.first([1]) iex> ^x = List.first([2]) ** (MatchError) no match of right hand side value: ...Note that ^x always refers to the value of x prior to the match. The following example will match:iex> x = 0 iex> {x, ^x} = {1, 0} iex> x 1 {args} (macro) Creates a tuple.More information about the tuple data type and about functions to manipulate tuples can be found in the Tuple module; some functions for working with tuples are also available in Kernel (such as Kernel.elem/2 or Kernel.tuple_size/1).AST representationOnly two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the :{} special form.iex> quote do ...> {1, 2} ...> end {1, 2} iex> quote do ...> {1, 2, 3} ...> end {:{}, [], [1, 2, 3]} Search HexDocs Download ePub version Built using ExDoc (v0.38.4) for the Elixir programming language

```
Kernel.SpecialForms
```

**Pattern 8:** %struct{} (macro) Matches on or builds a struct.A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.Structs are usually defined with the Kernel.defstruct/1 macro:defmodule User do defstruct name: "john", age: 27 endNow a struct can be created as follows:%User{}Underneath a struct is a map with a :__struct__ key pointing to the User module, where the keys are validated at compile-time:%User{} == %{__struct__: User, name: "john", age: 27}The struct fields can be given when building the struct:%User{age: 31} #=> %{__struct__: User, name: "john", age: 31}Or also on pattern matching to extract values out:%User{age: age} = userThe advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key :full_name in the User struct:%User{full_name: "john doe"}The map update syntax can also be used for updating structs:%{user | age: 28}Pattern matching on struct namesBesides allowing pattern matching on struct fields, such as:%User{age: age} = userStructs also allow pattern matching on the struct name:%struct_name{} = user struct_name #=> UserYou can also assign the struct name to _ when you want to check if something is a struct but you are not interested in its name:%_{} = user %{} (macro) Creates a map.See the Map module for more information about maps, their syntax, and ways to access and manipulate them.AST representationRegardless of whether => or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:iex> quote do ...> %{"a" => :b, c: :d} ...> end {:%{}, [], [{"a", :b}, {:c, :d}]} &expr (macro) Capture operator. Captures or creates an anonymous function.CaptureThe capture operator is most commonly used to capture a function with given name and arity from a module:iex> fun = &Kernel.is_atom/1 iex> fun.(:atom) true iex> fun.("string") falseIn the example above, we captured Kernel.is_atom/1 as an anonymous function and then invoked it.The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:&local_function/1Note that &local_function/1 creates a local capture, but &__MODULE__.local_function/1 or &imported_function/1 create a remote capture. For more information, refer to the "Functions" section in the Erlang Reference Manual.Whether a capture is local or remote has implications when using hot code reloading: local captures dispatch to the version of the module that existed at the time they were created, while remote captures dispatch to the current version of the module.See also Function.capture/3.Anonymous functionsThe capture operator can also be used to partially apply functions, where &1, &2 and so on can be used as value placeholders. For example:iex> double = &(&1 * 2) iex> double.(2) 4In other words, &(&1 * 2) is equivalent to fn x -> x * 2 end.We can partially apply a remote function with placeholder:iex> take_five = &Enum.take(&1, 5) iex> take_five.(1..10) [1, 2, 3, 4, 5]Another example while using an imported or local function:iex> first_elem = &elem(&1, 0) iex> first_elem.({0, 1}) 0The & operator can be used with more complex expressions:iex> fun = &(&1 + &2 + &3) iex> fun.(1, 2, 3) 6As well as with lists and tuples:iex> fun = &{&1, &2} iex> fun.(1, 2) {1, 2} iex> fun = &[&1 | &2] iex> fun.(1, [2, 3]) [1, 2, 3]The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &1, and that block expressions are not supported:# No placeholder, fails to compile. &(:foo) # Block expression, fails to compile. &(&1; &2) left . right (macro) Dot operator. Defines a remote call, a call to an anonymous function, or an alias.The dot (.) in Elixir can be used for remote calls:iex> String.downcase("FOO") "foo"In this example above, we have used . to invoke downcase in the String module, passing "FOO" as argument.The dot may be used to invoke anonymous functions too:iex> (fn n -> n end).(7) 7in which case there is a function on the left hand side.We can also use the dot for creating aliases:iex> Hello.World Hello.WorldThis time, we have joined two aliases, defining the final alias Hello.World.SyntaxThe right side of . may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:iex> Kernel.Sample Kernel.Sample iex> Kernel.length([1, 2, 3]) 3 iex> Kernel.+(1, 2) 3 iex> Kernel."+"(1, 2) 3Wrapping the function name in single- or double-quotes is always a remote call. Therefore Kernel."Foo" will attempt to call the function "Foo" and not return the alias Kernel.Foo. This is done by design as module names are more strict than function names.When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation:iex> negate = fn n -> -n end iex> negate.(7) -7Quoted expressionWhen . is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore):iex> quote do ...> String.downcase("FOO") ...> end {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}Note that we have an inner tuple, containing the atom :. representing the dot as first element:{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias String and the atom :downcase. The second argument in a remote call is always an atom.In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:iex> quote do ...> negate.(0) ...> end {{:., [], [{:negate, [], __MODULE__}]}, [], [0]}When the right side is an alias (i.e. starts with uppercase), we get instead:iex> quote do ...> Hello.World ...> end {:__aliases__, [alias: false], [:Hello, :World]}We go into more details about aliases in the __aliases__/1 special form documentation.UnquotingWe can also use unquote to generate a remote call in a quoted expression:iex> x = :downcase iex> quote do ...> String.unquote(x)("FOO") ...> end {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}Similar to Kernel."FUNCTION_NAME", unquote(x) will always generate a remote call, independent of the value of x. To generate an alias via the quoted expression, one needs to rely on Module.concat/2:iex> x = Sample iex> quote do ...> Module.concat(String, unquote(x)) ...> end {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [], [{:__aliases__, [alias: false], [:String]}, Sample]} __aliases__(args) (macro) Internal special form to hold aliases information.It is usually compiled to an atom:iex> quote do ...> Foo.Bar ...> end {:__aliases__, [alias: false], [:Foo, :Bar]}Elixir represents Foo.Bar as __aliases__ so calls can be unambiguously identified by the operator :.. For example:iex> quote do ...> Foo.bar() ...> end {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}Whenever an expression iterator sees a :. as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom.On the other hand, aliases hold some properties:The head element of aliases can be any term that must expand to an atom at compilation time.The tail elements of aliases are guaranteed to always be atoms.When the head element of aliases is the atom :Elixir, no expansion happens. __block__(args) (macro) Internal special form for block expressions.This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:iex> quote do ...> 1 ...> 2 ...> 3 ...> end {:__block__, [], [1, 2, 3]} __CALLER__ (macro) Returns the current calling environment as a Macro.Env struct.In the environment you can access the filename, line numbers, set up aliases, the function and others. __cursor__(args) (macro) Internal special form for cursor position.This is the special form used whenever we need to represent the cursor position in Elixir's AST. See Code.Fragment for more information. __DIR__ (macro) Returns the absolute path of the directory of the current file as a binary.Although the directory can be accessed as Path.dirname(__ENV__.file), this macro is a convenient shortcut. __ENV__ (macro) Returns the current environment information as a Macro.Env struct.In the environment you can access the current filename, line numbers, set up aliases, the current function and others. __MODULE__ (macro) Returns the current module name as an atom or nil otherwise.Although the module can be accessed in the __ENV__/0, this macro is a convenient shortcut. __STACKTRACE__ (since 1.7.0) (macro) Returns the stacktrace for the currently handled exception.It is available only in the catch and rescue clauses of try/1 expressions and function definitions.To retrieve the stacktrace of the current process, use Process.info(self(), :current_stacktrace) instead. left :: right (macro) Type operator. Used by types and bitstrings to specify types.This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:@type number :: integer | float @spec add(number, number) :: numberIt may also be used in bit strings to specify the type of a given bit segment:<<int::integer-little, rest::bits>> = bitsRead the documentation on the Typespecs page and <<>>/1 for more information on typespecs and bitstrings respectively. <<args>> (macro) Defines a new bitstring.Examplesiex> <<1, 2, 3>> <<1, 2, 3>>TypesA bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:integerfloatbits (alias for bitstring)bitstringbinarybytes (alias for binary)utf8utf16utf32When no type is specified, the default is integer:iex> <<1, 2, 3>> <<1, 2, 3>>Elixir also accepts by default the segment to be a literal string which expands to integers:iex> <<0, "foo">> <<0, 102, 111, 111>>You can use one of utf8 (the default), utf16, and utf32 to control how the string is encoded:iex> <<"foo"::utf16>> <<0, 102, 0, 111, 0, 111>>Which is equivalent to writing:iex> <<?f::utf16, ?o::utf16, ?o::utf16>> <<0, 102, 0, 111, 0, 111>>At runtime, binaries need to be explicitly tagged as binary:iex> rest = "oo" iex> <<102, rest::binary>> "foo"Otherwise we get an ArgumentError when constructing the binary:rest = "oo" <<102, rest>> ** (ArgumentError) argument errorOptionsMany options can be given by using - as separator. Order is arbitrary, so the following are all equivalent:<<102::integer-native, rest::binary>> <<102::native-integer, rest::binary>> <<102::unsigned-big-integer, rest::binary>> <<102::unsigned-big-integer-size(8), rest::binary>> <<102::unsigned-big-integer-8, rest::binary>> <<102::8-integer-big-unsigned, rest::binary>> <<102, rest::binary>>Unit and SizeThe length of the match is equal to the unit (a number of bits) times the size (the number of repeated segments of length unit).TypeDefault Unitinteger1 bitfloat1 bitbinary8 bitsSizes for types are a bit more nuanced. The default size for integers is 8.For floats, it is 64. For floats, size * unit must result in 16, 32, or 64, corresponding to IEEE 754 binary16, binary32, and binary64, respectively.For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:iex> <<name::binary-size(5), " the ", species::binary>> = <<"Frank the Walrus">> "Frank the Walrus" iex> {name, species} {"Frank", "Walrus"}The size can be a variable or any valid guard expression:iex> name_size = 5 iex> <<name::binary-size(^name_size), " the ", species::binary>> = <<"Frank the Walrus">> iex> {name, species} {"Frank", "Walrus"}The size can access prior variables defined in the binary itself:iex> <<name_size::size(8), name::binary-size(name_size), " the ", species::binary>> = <<5, "Frank the Walrus">> iex> {name, species} {"Frank", "Walrus"}However, it cannot access variables defined in the match outside of the binary/bitstring:{name_size, <<name::binary-size(name_size), _rest::binary>>} = {5, <<"Frank the Walrus">>} ** (CompileError): undefined variable "name_size" in bitstring segmentFailing to specify the size for the non-last causes compilation to fail:<<name::binary, " the ", species::binary>> = <<"Frank the Walrus">> ** (CompileError): a binary field without size is only allowed at the end of a binary patternShortcut SyntaxSize and unit can also be specified using a syntax shortcut when passing integer values:iex> x = 1 iex> <<x::8>> == <<x::size(8)>> true iex> <<x::8*4>> == <<x::size(8)-unit(4)>> trueThis syntax reflects the fact the effective size is given by multiplying the size by the unit.ModifiersSome types have associated modifiers to clear up ambiguity in byte representation.ModifierRelevant Type(s)signedintegerunsigned (default)integerlittleinteger, float, utf16, utf32big (default)integer, float, utf16, utf32nativeinteger, float, utf16, utf32SignIntegers can be signed or unsigned, defaulting to unsigned.iex> <<int::integer>> = <<-100>> <<156>> iex> int 156 iex> <<int::integer-signed>> = <<-100>> <<156>> iex> int -100signed and unsigned are only used for matching binaries (see below) and are only used for integers.iex> <<-100::signed, _rest::binary>> = <<-100, "foo">> <<156, 102, 111, 111>>EndiannessElixir has three options for endianness: big, little, and native. The default is big:iex> <<number::little-integer-size(16)>> = <<0, 1>> <<0, 1>> iex> number 256 iex> <<number::big-integer-size(16)>> = <<0, 1>> <<0, 1>> iex> number 1native is determined by the VM at startup and will depend on the host operating system.Binary/Bitstring MatchingBinary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching.Binary matching can be used by itself to extract information from binaries:iex> <<"Hello, ", place::binary>> = "Hello, World" "Hello, World" iex> place "World"Or as a part of function definitions to pattern match:defmodule ImageType do @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8), 13::size(8), 10::size(8), 26::size(8), 10::size(8)>> @jpg_signature <<255::size(8), 216::size(8)>> def type(<<@png_signature, _rest::binary>>), do: :png def type(<<@jpg_signature, _rest::binary>>), do: :jpg def type(_), do: :unknown endPerformance & OptimizationsThe Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the bin_opt_info compiler option:ERL_COMPILER_OPTIONS=bin_opt_info mix compileTo learn more about specific optimizations and performance considerations, check out the "Constructing and matching binaries" chapter of the Erlang's Efficiency Guide. left = right (macro) Match operator. Matches the value on the right against the pattern on the left. alias(module, opts) (macro) alias/2 is used to set up aliases, often useful with modules' names.Examplesalias/2 can be used to set up an alias for any module:defmodule Math do alias MyKeyword, as: Keyword endIn the example above, we have set up MyKeyword to be aliased as Keyword. So now, any reference to Keyword will be automatically replaced by MyKeyword.In case one wants to access the original Keyword, it can be done by accessing Elixir:Keyword.values #=> uses MyKeyword.values Elixir.Keyword.values #=> uses Keyword.valuesNote that calling alias without the :as option automatically sets an alias based on the last part of the module. For example:alias Foo.Bar.BazIs the same as:alias Foo.Bar.Baz, as: BazWe can also alias multiple modules in one line:alias Foo.{Bar, Baz, Biz}Is the same as:alias Foo.Bar alias Foo.Baz alias Foo.BizLexical scopeimport/2, require/2 and alias/2 are called directives and all have lexical scope. This means you can set up aliases inside specific functions and it won't affect the overall scope.WarningsIf you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.Both warning behaviors could be changed by explicitly setting the :warn option to true or false. case(condition, clauses) (macro) Matches the given expression against the given clauses.case/2 relies on pattern matching and guards to choose which clause to execute. If your logic cannot be expressed within patterns and guards, consider using if/2 or cond/1 instead.Examplesiex> string_date = "2015-01-23" iex> case Date.from_iso8601(string_date) do ...> {:ok, date} -> date ...> {:error, _reason} -> Date.utc_today() ...> end ~D[2015-01-23]In the example above, we match the result of Date.from_iso8601/1 against each clause "head" and execute the clause "body" corresponding to the first clause that matches. In our case string_date contains a string with a valid ISO 8601 representation of date. The function returns {:ok, ~D[2015-01-23]}, so the {:ok, date} clause is matched.If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like _) which will always match.iex> x = 10 iex> case x do ...> 0 -> "This clause won't match" ...> _ -> "This clause would match any value (x = #{x})" ...> end "This clause would match any value (x = 10)"If you find yourself nesting case expressions inside case expressions, consider using with/1.Variable handlingNote that variables bound in a clause do not leak to the outer context:iex> case {:ok, 7} do ...> {:ok, value} -> value ...> :error -> nil ...> end ...> value ** (CompileError) undefined variable "value"Variables in the outer context cannot be overridden either:iex> value = 7 iex> case 3 > 5 do ...> false -> ...> value = 3 ...> value + 2 ...> true -> ...> 3 ...> end iex> value 7In the example above, value is going to be 7 regardless of which clause matched. The variable value bound in the clause and the variable value bound in the outer context are two entirely separate variables.If you want to pattern match against an existing variable, you need to use the ^/1 operator:iex> x = 1 iex> case 10 do ...> ^x -> "Won't match" ...> _ -> "Will match" ...> end "Will match"Using guards to match against multiple valuesWhile it is not possible to match against multiple patterns in a single clause, it's possible to match against multiple values by using guards:iex> case :two do ...> value when value in [:one, :two] -> ...> "#{value} has been matched" ...> :three -> ...> "three has been matched" ...> end "two has been matched" cond(clauses) (macro) Evaluates the expression corresponding to the first clause that evaluates to a truthy value.ExamplesThe following example has a single clause that always evaluates to true:iex> cond do ...> hd([1, 2, 3]) -> "1 is considered as true" ...> end "1 is considered as true"If all clauses evaluate to nil or false, cond raises an error. For this reason, it may be necessary to add a final always-truthy condition (anything non-false and non-nil), which will always match:iex> cond do ...> 1 + 1 == 1 -> "This will never match" ...> 2 * 2 != 4 -> "Nor this" ...> true -> "This will" ...> end "This will"If your cond has two clauses, and the last one falls back to true, you may consider using if/2 instead. fn(clauses) (macro) Defines an anonymous function.See Function for more information.Examplesiex> add = fn a, b -> a + b end iex> add.(1, 2) 3Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:iex> negate = fn ...> true -> false ...> false -> true ...> end iex> negate.(false) true for(args) (macro) Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.Let's start with an example:iex> for n <- [1, 2, 3, 4], do: n * 2 [2, 4, 6, 8]A comprehension accepts many generators and filters. for uses the <- operator to extract values from the enumerable on its right side and match them against the pattern on the left. We call them generators:# A list generator: iex> for n <- [1, 2, 3, 4], do: n * 2 [2, 4, 6, 8] # A comprehension with two generators iex> for x <- [1, 2], y <- [2, 3], do: x * y [2, 3, 4, 6]Filters can also be given:# A comprehension with a generator and a filter iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n [2, 4, 6]Filters must evaluate to truthy values (everything but nil and false). If a filter is falsy, then the current value is discarded.Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of <-:iex> users = [user: "john", admin: "meg", guest: "barbara"] iex> for {type, name} when type != :guest <- users do ...> String.upcase(name) ...> end ["JOHN", "MEG"]Bitstring generators are also supported and are very useful when you need to organize bitstring streams:iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>> iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b} [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.Variable assignments inside filters must still return a truthy value, otherwise values are discarded. Let's see an example. Imagine you have a keyword list where the key is a programming language and the value is its direct parent. Then let's try to compute the grandparent of each language. You could try this:iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil] iex> for {language, parent} <- languages, grandparent = languages[parent], do: {language, grandparent} [elixir: :prolog]Given the grandparents of Erlang and Prolog were nil, those values were filtered out. If you don't want this behavior, a simple option is to move the filter inside the do-block:iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil] iex> for {language, parent} <- languages do ...> grandparent = languages[parent] ...> {language, grandparent} ...> end [elixir: :prolog, erlang: nil, prolog: nil]However, such option is not always available, as you may have further filters. An alternative is to convert the filter into a generator by wrapping the right side of = in a list:iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil] iex> for {language, parent} <- languages, grandparent <- [languages[parent]], do: {language, grandparent} [elixir: :prolog, erlang: nil, prolog: nil]The :into and :uniq optionsIn the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an :into option, that accepts any structure as long as it implements the Collectable protocol.For example, we can use bitstring generators with the :into option to easily remove all spaces in a string:iex> for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>> "helloworld"The IO module provides streams, that are both Enumerable and Collectable, here is an upcase echo server using comprehensions:for line <- IO.stream(), into: IO.stream() do String.upcase(line) endSimilarly, uniq: true can also be given to comprehensions to guarantee the results are only added to the collection if they were not returned before. For example:iex> for x <- [1, 1, 2, 3], uniq: true, do: x * 2 [2, 4, 6] iex> for <<x <- "abcabc">>, uniq: true, into: "", do: <<x - 32>> "ABC"The :reduce optionAvailable since Elixir v1.8.While the :into option allows us to customize the comprehension behavior to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough.For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string "AbCabCABc", we want to return the map %{"a" => 1, "b" => 2, "c" => 1}.If we were to use :into, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke Enum.reduce/3 to build a map, for example:iex> letters = for <<x <- "AbCabCABc">>, x in ?a..?z, do: <<x>> iex> Enum.reduce(letters, %{}, fn x, acc -> Map.update(acc, x, 1, & &1 + 1) end) %{"a" => 1, "b" => 2, "c" => 1}While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive.Luckily, comprehensions also support the :reduce option, which would allow us to fuse both steps above into a single step:iex> for <<x <- "AbCabCABc">>, x in ?a..?z, reduce: %{} do ...> acc -> Map.update(acc, <<x>>, 1, & &1 + 1) ...> end %{"a" => 1, "b" => 2, "c" => 1}When the :reduce key is given, its value is used as the initial accumulator and the do block must be changed to use -> clauses, where the left side of -> receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned. import(module, opts) (macro) Imports functions and macros from other modules.import/2 allows one to easily access functions or macros from other modules without using the qualified name.ExamplesIf you are using several functions from a given module, you can import those functions and reference them as local functions, for example:iex> import List iex> flatten([1, [2], 3]) [1, 2, 3]SelectorBy default, Elixir imports functions and macros from the given module, except the ones starting with an underscore (which are usually callbacks):import ListA developer can filter to import only functions, macros, or sigils (which can be functions or macros) via the :only option:import List, only: :functions import List, only: :macros import Kernel, only: :sigilsAlternatively, Elixir allows a developer to pass pairs of name/arities to :only or :except as a fine grained control on what to import (or not):import List, only: [flatten: 1] import String, except: [split: 2]Importing the same module again will erase the previous imports, except when the except option is used, which is always exclusive on a previously declared import/2. If there is no previous import, then it applies to all functions and macros in the module. For example:import List, only: [flatten: 1, keyfind: 4] import List, except: [flatten: 1]After the two import calls above, only List.keyfind/4 will be imported.Underscore functionsBy default functions starting with _ are not imported. If you really want to import a function starting with _ you must explicitly include it in the :only selector.import File.Stream, only: [__build__: 3]Lexical scopeIt is important to note that import/2 is lexical. This means you can import specific macros inside specific functions:defmodule Math do def some_function do # 1) Disable "if/2" from Kernel import Kernel, except: [if: 2] # 2) Require the new "if/2" macro from MyMacros import MyMacros # 3) Use the new macro if do_something, it_works end endIn the example above, we imported macros from MyMacros, replacing the original if/2 implementation by our own within that specific function. All other functions in that module will still be able to use the original one.WarningsIf you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.Both warning behaviors could be changed by explicitly setting the :warn option to true or false.Ambiguous function/macro namesIf two modules A and B are imported and they both contain a foo function with an arity of 1, an error is only emitted if an ambiguous call to foo/1 is actually made; that is, the errors are emitted lazily, not eagerly. quote(opts, block) (macro) Gets the representation of any expression.Examplesiex> quote do ...> sum(1, 2, 3) ...> end {:sum, [], [1, 2, 3]}Elixir's AST (Abstract Syntax Tree)Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example:{:sum, [], [1, 2, 3]}The tuple above represents a function call to sum passing 1, 2 and 3 as arguments. The tuple elements are:The first element of the tuple is always an atom or another tuple in the same representation.The second element of the tuple represents metadata.The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).Besides the tuple described above, Elixir has a few literals that are also part of its AST. Those literals return themselves when quoted. They are::sum #=> Atoms 1 #=> Integers 2.0 #=> Floats [1, 2] #=> Lists "strings" #=> Strings {key, value} #=> Tuples with two elementsAny other value, such as a map or a four-element tuple, must be escaped (Macro.escape/1) before being introduced into an AST.Options:bind_quoted - passes a binding to the macro. Whenever a binding is given, unquote/1 is automatically disabled.:context - sets the resolution context.:generated - marks the given chunk as generated so it does not emit warnings. It is also useful to prevent the type system or dialyzer from reporting errors when macros generate unused clauses.:file - sets the quoted expressions to have the given file.:line - sets the quoted expressions to have the given line.:location - when set to :keep, keeps the current line and file from quote. Read the "Stacktrace information" section below for more information.:unquote - when false, disables unquoting. This means any unquote call will be kept as is in the AST, instead of replaced by the unquote arguments. For example:iex> quote do ...> unquote("hello") ...> end "hello" iex> quote unquote: false do ...> unquote("hello") ...> end {:unquote, [], ["hello"]}Quote and macrosquote/2 is commonly used with macros for code generation. As an exercise, let's define a macro that multiplies a number by itself (squared). In practice, there is no reason to define such a macro (and it would actually be seen as a bad practice), but it is simple enough that it allows us to focus on the important aspects of quotes and macros:defmodule Math do defmacro squared(x) do quote do unquote(x) * unquote(x) end end endWe can invoke it as:import Math IO.puts("Got #{squared(5)}")At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, squared(5) becomes 5 * 5. The argument 5 is duplicated in the produced code, we can see this behavior in practice though because our macro actually has a bug:import Math my_number = fn -> IO.puts("Returning 5") 5 end IO.puts("Got #{squared(my_number.())}")The example above will print:Returning 5 Returning 5 Got 25Notice how "Returning 5" was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:squared(my_number.())Actually expands to:my_number.() * my_number.()Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behavior, and that's why one of the first things you need to keep in mind when it comes to macros is to not unquote the same value more than once.Let's fix our macro:defmodule Math do defmacro squared(x) do quote do x = unquote(x) x * x end end endNow invoking squared(my_number.()) as before will print the value just once.In fact, this pattern is so common that most of the times you will want to use the bind_quoted option with quote/2:defmodule Math do defmacro squared(x) do quote bind_quoted: [x: x] do x * x end end end:bind_quoted will translate to the same code as the example above. :bind_quoted can be used in many cases and is seen as good practice, not only because it helps prevent us from running into common mistakes, but also because it allows us to leverage other tools exposed by macros, such as unquote fragments discussed in some sections below.Before we finish this brief introduction, you will notice that, even though we defined a variable x inside our quote:quote do x = unquote(x) x * x endWhen we call:import Math squared(5) x ** (CompileError) undefined variable "x"We can see that x did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well.Hygiene in variablesConsider the following example:defmodule Hygiene do defmacro no_interference do quote do a = 1 end end end require Hygiene a = 10 Hygiene.no_interference() a #=> 10In the example above, a returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the var! macro:defmodule NoHygiene do defmacro interference do quote do var!(a) = 1 end end end require NoHygiene a = 10 NoHygiene.interference() a #=> 1You cannot even access variables defined in the same module unless you explicitly give it a context:defmodule Hygiene do defmacro write do quote do a = 1 end end defmacro read do quote do a end end end require Hygiene Hygiene.write() Hygiene.read() ** (CompileError) undefined variable "a" (context Hygiene)For such, you can explicitly pass the current module scope as argument:defmodule ContextHygiene do defmacro write do quote do var!(a, ContextHygiene) = 1 end end defmacro read do quote do var!(a, ContextHygiene) end end end require ContextHygiene ContextHygiene.write() ContextHygiene.read() #=> 1The contexts of a variable is identified by the third element of the tuple. The default context is nil and quote assigns another context to all variables within:quote(do: var) #=> {:var, [], Elixir}In case of variables returned by macros, there may also be a :counter key in the metadata, which is used to further refine its contexts and guarantee isolation between macro invocations as seen in the previous example.Hygiene in aliasesAliases inside quote are hygienic by default. Consider the following example:defmodule Hygiene do alias Map, as: M defmacro no_interference do quote do M.new() end end end require Hygiene Hygiene.no_interference() #=> %{}Note that, even though the alias M is not available in the context the macro is expanded, the code above works because M still expands to Map.Similarly, even if we defined an alias with the same name before invoking a macro, it won't affect the macro's result:defmodule Hygiene do alias Map, as: M defmacro no_interference do quote do M.new() end end end require Hygiene alias SomethingElse, as: M Hygiene.no_interference() #=> %{}In some cases, you want to access an alias or a module defined in the caller. For such, you can use the alias! macro:defmodule Hygiene do # This will expand to Elixir.Nested.hello() defmacro no_interference do quote do Nested.hello() end end # This will expand to Nested.hello() for # whatever is Nested in the caller defmacro interference do quote do alias!(Nested).hello() end end end defmodule Parent do defmodule Nested do def hello, do: "world" end require Hygiene Hygiene.no_interference() ** (UndefinedFunctionError) ... Hygiene.interference() #=> "world" endHygiene in importsSimilar to aliases, imports in Elixir are hygienic. Consider the following code:defmodule Hygiene do defmacrop get_length do quote do length([1, 2, 3]) end end def return_length do import Kernel, except: [length: 1] get_length end end Hygiene.return_length() #=> 3Notice how Hygiene.return_length/0 returns 3 even though the Kernel.length/1 function is not imported. In fact, even if return_length/0 imported a function with the same name and arity from another module, it wouldn't affect the function result:def return_length do import String, only: [length: 1] get_length endCalling this new return_length/0 will still return 3 as result.Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call length([1, 2, 3]) inside quote, but no length/1 function is available, it is then expanded in the caller:defmodule Lazy do defmacrop get_length do import Kernel, except: [length: 1] quote do length("hello") end end def return_length do import Kernel, except: [length: 1] import String, only: [length: 1] get_length end end Lazy.return_length() #=> 5Stacktrace informationWhen defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example:# adder.ex defmodule Adder do @doc "Defines a function that adds two numbers" defmacro defadd do quote location: :keep do def add(a, b), do: a + b end end end # sample.ex defmodule Sample do import Adder defadd end require Sample Sample.add(:one, :two) ** (ArithmeticError) bad argument in arithmetic expression adder.ex:5: Sample.add/2When using location: :keep and invalid arguments are given to Sample.add/2, the stacktrace information will point to the file and line inside the quote. Without location: :keep, the error is reported to where defadd was invoked. location: :keep affects only definitions inside the quote.location: :keep and unquoteDo not use location: :keep if the function definition also unquotes some of the macro arguments. If you do so, Elixir will store the file definition of the current location but the unquoted arguments may contain line information of the macro caller, leading to erroneous stacktraces.Binding and unquote fragmentsElixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:kv = [foo: 1, bar: 2] Enum.each(kv, fn {k, v} -> def unquote(k)(), do: unquote(v) end)In the example above, we have generated the functions foo/0 and bar/0 dynamically. Note the parentheses in unquote(k)() are important, otherwise we would try to define a function as def :foo instead of def foo().Now, imagine that we want to convert this functionality into a macro:defmacro defkv(kv) do Enum.map(kv, fn {k, v} -> quote do def unquote(k)(), do: unquote(v) end end) endWe can invoke this macro as:defkv [foo: 1, bar: 2]However, we can't invoke it as follows:kv = [foo: 1, bar: 2] defkv kvThis is because the macro is expecting its arguments to be a keyword list at compilation time. Since in the example above we are passing the representation of the variable kv, our code fails.This is actually a common pitfall when developing macros. We are assuming a particular shape at compilation time, within the macro implementation. One may try to work around it by unquoting the variable inside the quoted expression:defmacro defkv(kv) do quote do Enum.each(unquote(kv), fn {k, v} -> def unquote(k)(), do: unquote(v) end) end endIf you try to run our new macro, you will notice it won't even compile, complaining that the variables k and v do not exist. This is because the two unquotes in the call above are meant to run at distinct moments: unquote(kv) applies to the immediate quote, unquote(k) is an unquote fragment.One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the kv representation into the tree. That's when the :bind_quoted option comes to the rescue (again!). By using :bind_quoted, we can automatically disable unquoting while still injecting the desired variables into the tree:defmacro defkv(kv) do quote bind_quoted: [kv: kv] do Enum.each(kv, fn {k, v} -> def unquote(k)(), do: unquote(v) end) end endIn fact, the :bind_quoted option is recommended every time one desires to inject a value into the quote. receive(args) (macro) Checks if there is a message matching any of the given clauses in the current process mailbox.If there is no matching message, the current process waits until a matching message arrives or until after a given timeout value.Any new and existing messages that do not match will remain in the mailbox.Examplesiex> send(self(), {:selector, 5, :quantity}) iex> receive do ...> {:selector, number, name} when is_integer(number) -> ...> name ...> name when is_atom(name) -> ...> name ...> _ -> ...> IO.puts(:stderr, "Unexpected message received") ...> end :quantityAn optional after clause can be given in case no matching message is received during the given timeout period, specified in milliseconds:iex> receive do ...> {:selector, number, name} when is_integer(number) -> ...> name ...> name when is_atom(name) -> ...> name ...> _ -> ...> IO.puts(:stderr, "Unexpected message received") ...> after ...> 10 -> ...> "No message in 10 milliseconds" ...> end "No message in 10 milliseconds"The after clause can be specified even if there are no match clauses. The timeout value given to after can be any expression evaluating to one of the allowed values::infinity - the process should wait indefinitely for a matching message, this is the same as not using the after clause0 - if there is no matching message in the mailbox, the timeout will occur immediatelypositive integer smaller than or equal to 4_294_967_295 (0xFFFFFFFF in hexadecimal notation) - it should be possible to represent the timeout value as an unsigned 32-bit integer.Variable handlingThe receive/1 special form handles variables exactly as the case/2 special macro. For more information, check the docs for case/2. require(module, opts) (macro) Requires a module in order to use its macros.ExamplesPublic functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.Let's suppose you created your own if/2 implementation in the module MyMacros. If you want to invoke it, you need to first explicitly require the MyMacros:defmodule Math do require MyMacros MyMacros.if do_something, it_works endAn attempt to call a macro that was not loaded will raise an error.Alias shortcutrequire/2 also accepts :as as an option so it automatically sets up an alias. Please check alias/2 for more information. super(args) (macro) Calls the overridden function when overriding it with Kernel.defoverridable/1.See Kernel.defoverridable/1 for more information and documentation. try(args) (macro) Evaluates the given expressions and handles any error, exit, or throw that may have happened.Examplestry do do_something_that_may_fail(some_arg) rescue ArgumentError -> IO.puts("Invalid argument given") catch value -> IO.puts("Caught #{inspect(value)}") else value -> IO.puts("Success! The result was #{inspect(value)}") after IO.puts("This is printed regardless if it failed or succeeded") endThe rescue clause is used to handle exceptions while the catch clause can be used to catch thrown values and exits. The else clause can be used to control flow based on the result of the expression. catch, rescue, and else clauses work based on pattern matching (similar to the case special form).Calls inside try/1 are not tail recursive since the VM needs to keep the stacktrace in case an exception happens. To retrieve the stacktrace, access __STACKTRACE__/0 inside the rescue or catch clause.rescue clausesBesides relying on pattern matching, rescue clauses provide some conveniences around exceptions that allow one to rescue an exception by its name. All the following formats are valid patterns in rescue clauses:Rescue a single exception without binding the exception to a variable:iex> try do ...> 1 / 0 ...> rescue ...> ArithmeticError -> :rescued ...> end :rescuedRescue any of the given exception without binding:iex> try do ...> 1 / 0 ...> rescue ...> [ArithmeticError, ArgumentError] -> :rescued ...> end :rescuedRescue and bind the exception to the variable x:iex> try do ...> 1 / 0 ...> rescue ...> x in [ArithmeticError] -> [:rescued, is_exception(x)] ...> end [:rescued, true]Rescue different errors with separate clauses:iex> try do ...> 1 / 0 ...> rescue ...> ArgumentError -> :rescued_argument_error ...> ArithmeticError -> :rescued_arithmetic_error ...> end :rescued_arithmetic_errorRescue all kinds of exceptions and bind the rescued exception to the variable x:iex> try do ...> 1 / 0 ...> rescue ...> x -> [:rescued, is_exception(x)] ...> end [:rescued, true]Erlang errorsErlang errors are transformed into Elixir ones when rescuing:iex> try do ...> :erlang.error(:badarg) ...> rescue ...> ArgumentError -> :rescued ...> end :rescuedThe most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic ErlangError:iex> try do ...> :erlang.error(:unknown) ...> rescue ...> ErlangError -> :rescued ...> end :rescuedIn fact, ErlangError can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier :badarg error too, prior to transformation:iex> try do ...> :erlang.error(:badarg) ...> rescue ...> ErlangError -> :rescued ...> end :rescuedcatch clausesThe catch clause can be used to catch thrown values, exits, and errors.Catching thrown valuescatch can be used to catch values thrown by Kernel.throw/1:iex> try do ...> throw(:some_value) ...> catch ...> thrown_value -> ...> "Thrown value: #{inspect(thrown_value)}" ...> end "Thrown value: :some_value"Catching values of any kindThe catch clause also supports catching exits and errors. To do that, it allows matching on both the kind of the caught value as well as the value itself:iex> try do ...> exit(:shutdown) ...> catch ...> :exit, value -> ...> "Exited with value #{inspect(value)}" ...> end "Exited with value :shutdown" iex> try do ...> exit(:shutdown) ...> catch ...> kind, value when kind in [:exit, :throw] -> ...> "Caught exit or throw with value #{inspect(value)}" ...> end "Caught exit or throw with value :shutdown"The catch clause also supports :error alongside :exit and :throw as in Erlang, although this is commonly avoided in favor of raise/rescue control mechanisms. One reason for this is that when catching :error, the error is not automatically transformed into an Elixir error:iex> try do ...> :erlang.error(:badarg) ...> catch ...> :error, :badarg -> :rescued ...> end :rescuedafter clausesAn after clause allows you to define cleanup logic that will be invoked both when the block of code passed to try/1 succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the after clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.File.write!("tmp/story.txt", "Hello, World") try do do_something_with("tmp/story.txt") after File.rm("tmp/story.txt") endAlthough after clauses are invoked whether or not there was an error, they do not modify the return value. Both of the following examples print a message to STDOUT and return :returned:try do :returned after IO.puts("This message will be printed") :not_returned end #=> :returned try do raise "boom" rescue _ -> :returned after IO.puts("This message will be printed") :not_returned end #=> :returnedelse clauseselse clauses allow the result of the body passed to try/1 to be pattern matched on:iex> x = 2 ...> try do ...> 1 / x ...> rescue ...> ArithmeticError -> :infinity ...> else ...> y when y < 1 and y > -1 -> :small ...> _ -> :large ...> end :smallIf an else clause is not present and no exceptions are raised, the result of the expression will be returned:iex> x = 5 iex> try do ...> 1 / x ...> rescue ...> ArithmeticError -> :infinity ...> end 0.2However, when an else clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a catch or rescue in the same try:iex> x = 1 iex> try do ...> try do ...> 1 / x ...> rescue ...> # The TryClauseError cannot be rescued here: ...> TryClauseError -> :error_a ...> else ...> 0.5 -> :small ...> end ...> rescue ...> # The TryClauseError is rescued here: ...> TryClauseError -> :error_b ...> end :error_bSimilarly, an exception inside an else clause is not caught or rescued inside the same try:iex> x = 1 iex> try do ...> try do ...> 1 / x ...> catch ...> # The exit(1) call below can not be caught here: ...> :exit, _ -> :exit_a ...> else ...> _ -> exit(1) ...> end ...> catch ...> # The exit is caught here: ...> :exit, _ -> :exit_b ...> end :exit_bThis means the VM no longer needs to keep the stacktrace once inside an else clause and so tail recursion is possible when using a try with a tail call as the final call inside an else clause. The same is true for rescue and catch clauses.Only the result of the tried expression falls down to the else clause. If the try ends up in the rescue or catch clauses, their result will not fall down to else:iex> try do ...> throw(:catch_this) ...> catch ...> :throw, :catch_this -> :it_was_caught ...> else ...> # :it_was_caught will not fall down to this "else" clause. ...> other -> {:else, other} ...> end :it_was_caughtVariable handlingSince an expression inside try may not have been evaluated due to an exception, any variable created inside try cannot be accessed externally. For instance:try do x = 1 do_something_that_may_fail(same_arg) :ok catch _, _ -> :failed end x #=> unbound variable "x"In the example above, x cannot be accessed since it was defined inside the try clause. A common practice to address this issue is to return the variables defined inside try:x = try do x = 1 do_something_that_may_fail(same_arg) x catch _, _ -> :failed end unquote(expr) (macro) Unquotes the given expression inside a quoted expression.This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to unquote any value, such as a map or a four-element tuple, you should call Macro.escape/1 before unquoting.ExamplesImagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:value = quote do 13 end quote do sum(1, value, 3) endWhich the argument for the :sum function call is not the expected result:{:sum, [], [1, {:value, [], Elixir}, 3]}For this, we use unquote:iex> value = ...> quote do ...> 13 ...> end iex> quote do ...> sum(1, unquote(value), 3) ...> end {:sum, [], [1, 13, 3]}If you want to unquote a value that is not a quoted expression, such as a map, you need to call Macro.escape/1 before:iex> value = %{foo: :bar} iex> quote do ...> process_map(unquote(Macro.escape(value))) ...> end {:process_map, [], [{:%{}, [], [foo: :bar]}]}If you forget to escape it, Elixir will raise an error when compiling the code. unquote_splicing(expr) (macro) Unquotes the given list expanding its arguments.Similar to unquote/1.Examplesiex> values = [2, 3, 4] iex> quote do ...> sum(1, unquote_splicing(values), 5) ...> end {:sum, [], [1, 2, 3, 4, 5]}Also can be used in block context, outside of function arguments. Though, it is still required to be wrapped into parentheses.iex> requires = for module <- [Integer, Logger] do ...> quote do ...> require unquote(module) ...> end ...> end iex> block = quote do: (unquote_splicing(requires)) iex> Macro.to_string(block) "require Integer\nrequire Logger" with(args) (macro) Combine matching clauses.One of the ways to understand with is to show which code patterns it improves. Imagine you have a map where the fields width and height are optional and you want to compute its area, as {:ok, area} or return :error. We could implement this function as:def area(opts) do case Map.fetch(opts, :width) do {:ok, width} -> case Map.fetch(opts, :height) do {:ok, height} -> {:ok, width * height} :error -> :error end :error -> :error end endwhen called as area(%{width: 10, height: 15}), it should return {:ok, 150}. If any of the fields are missing, it returns :error.While the code above works, it is quite verbose. Using with, we could rewrite it as:def area(opts) do with {:ok, width} <- Map.fetch(opts, :width), {:ok, height} <- Map.fetch(opts, :height) do {:ok, width * height} end endInstead of defining nested cases with clauses, we use with alongside the PATTERN <- EXPRESSION operator to match expressions on its right side against the pattern on the left. Consider <- as a sibling to =, except that, while = raises in case of not matches, <- will simply abort the with chain and return the non-matched value.Let's give it a try on IEx:iex> opts = %{width: 10, height: 15} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, width * height} ...> end {:ok, 150}If all clauses match, the do block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:iex> opts = %{width: 10} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, width * height} ...> end :errorGuards can be used in patterns as well:iex> users = %{"melany" => "guest", "bob" => :admin} iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, "bob") do ...> {:ok, to_string(role)} ...> end {:ok, "admin"}As in for/1, variables bound inside with/1 won't be accessible outside of with/1.Expressions without <- may also be used in clauses. For instance, you can perform regular matches with the = operator:iex> width = nil iex> opts = %{width: 10, height: 15} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> double_width = width * 2, ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, double_width * height} ...> end {:ok, 300} iex> width nilThe behavior of any expression in a clause is the same as if it was written outside of with. For example, = will raise a MatchError instead of returning the non-matched value:with :foo = :bar, do: :ok ** (MatchError) no match of right hand side value: :barAs with any other function or macro call in Elixir, explicit parens can also be used around the arguments before the do-end block:iex> opts = %{width: 10, height: 15} iex> with( ...> {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) ...> ) do ...> {:ok, width * height} ...> end {:ok, 150}The choice between parens and no parens is a matter of preference.Else clausesAn else option can be given to modify what is being returned from with in the case of a failed match:iex> opts = %{width: 10} iex> with {:ok, width} <- Map.fetch(opts, :width), ...> {:ok, height} <- Map.fetch(opts, :height) do ...> {:ok, width * height} ...> else ...> :error -> ...> {:error, :wrong_data} ...> ...> _other_error -> ...> :unexpected_error ...> end {:error, :wrong_data}The else block works like a case: it can have multiple clauses, and the first match will be used. Variables bound inside with (such as width in this example) are not available in the else block.If an else block is used and there are no matching clauses, a WithClauseError exception is raised.Beware!Keep in mind that, one of potential drawback of with is that all failure clauses are flattened into a single else block. For example, take this code that checks if a given path points to an Elixir file and that it exists before creating a backup copy:with ".ex" <- Path.extname(path), true <- File.exists?(path) do backup_path = path <> ".backup" File.cp!(path, backup_path) {:ok, backup_path} else binary when is_binary(binary) -> {:error, :invalid_extension} false -> {:error, :missing_file} endNote how we are having to reconstruct the result types of Path.extname/1 and File.exists?/1 to build error messages. In this case, it is better to refactor the code so each <- already return the desired format in case of errors, like this:with :ok <- validate_extension(path), :ok <- validate_exists(path) do backup_path = path <> ".backup" File.cp!(path, backup_path) {:ok, backup_path} end defp validate_extension(path) do if Path.extname(path) == ".ex", do: :ok, else: {:error, :invalid_extension} end defp validate_exists(path) do if File.exists?(path), do: :ok, else: {:error, :missing_file} endNote how the code above is better organized and clearer once we make sure each <- in with returns a normalized format. ^var (macro) Pin operator. Accesses an already bound variable in match clauses.ExamplesElixir allows variables to be rebound via static single assignment:iex> x = 1 iex> x = x + 1 iex> x 2However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the ^ special form, colloquially known as the pin operator:iex> x = 1 iex> ^x = List.first([1]) iex> ^x = List.first([2]) ** (MatchError) no match of right hand side value: ...Note that ^x always refers to the value of x prior to the match. The following example will match:iex> x = 0 iex> {x, ^x} = {1, 0} iex> x 1 {args} (macro) Creates a tuple.More information about the tuple data type and about functions to manipulate tuples can be found in the Tuple module; some functions for working with tuples are also available in Kernel (such as Kernel.elem/2 or Kernel.tuple_size/1).AST representationOnly two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the :{} special form.iex> quote do ...> {1, 2} ...> end {1, 2} iex> quote do ...> {1, 2, 3} ...> end {:{}, [], [1, 2, 3]}

```
Kernel.defstruct/1
```

## Reference Files

This skill includes comprehensive documentation in `references/`:

- **elixir.md** - Elixir documentation
- **other.md** - Other documentation

Use `view` to read specific reference files when detailed information is needed.

## Working with This Skill

### For Beginners
Start with the getting_started or tutorials reference files for foundational concepts.

### For Specific Features
Use the appropriate category reference file (api, guides, etc.) for detailed information.

### For Code Examples
The quick reference section above contains common patterns extracted from the official docs.

## Resources

### references/
Organized documentation extracted from official sources. These files contain:
- Detailed explanations
- Code examples with language annotations
- Links to original documentation
- Table of contents for quick navigation

### scripts/
Add helper scripts here for common automation tasks.

### assets/
Add templates, boilerplate, or example projects here.

## Notes

- This skill was automatically generated from official documentation
- Reference files preserve the structure and examples from source docs
- Code examples include language detection for better syntax highlighting
- Quick reference patterns are extracted from common usage examples in the docs

## Updating

To refresh this skill with updated documentation:
1. Re-run the scraper with the same configuration
2. The skill will be rebuilt with the latest information
