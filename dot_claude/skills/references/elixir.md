# Elixir - Elixir

**Pages:** 503

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defprotocol/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2-paths

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#===/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.ParallelCompiler (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html#pmap/2

**Contents:**
- Kernel.ParallelCompiler (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- compile_opts()
- error()
- info()
- require_opts()
- warning()

A module responsible for compiling and requiring files in parallel.

Options for parallel compilation functions.

Options for requiring files in parallel.

Starts a task for parallel compilation.

Compiles the given files.

Compiles the given files and writes resulting BEAM files into path.

Perform parallel compilation of collection with fun.

Requires the given files in parallel.

Options for parallel compilation functions.

Options for requiring files in parallel.

Starts a task for parallel compilation.

Compiles the given files.

Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved.

It must be invoked with return_diagnostics: true as option, so it returns {:ok, modules, warnings_info} or {:error, errors, warnings_info}, where warnings_info has the shape:

:after_compile - invoked after all modules are compiled, but before they are verified. If the files are being written to disk, such as in compile_to_path/3, this will be invoked after the files are written

:each_file - for each file compiled, invokes the callback passing the file

:each_long_compilation - for each file that takes more than a given timeout (see the :long_compilation_threshold option) to compile, invoke this callback passing the file as its argument (and optionally the PID of the process compiling the file)

:each_long_verification (since v1.19.0) - for each file that takes more than a given timeout (see the :long_verification_threshold option) to compile, invoke this callback passing the module as its argument (and optionally the PID of the process verifying the module)

:each_module - for each module compiled, invokes the callback passing the file, module and the module bytecode

:each_cycle - after the given files are compiled, invokes this function that should return the following values:

:long_compilation_threshold - the timeout (in seconds) to check for files taking too long to compile. For each file that exceeds the threshold, the :each_long_compilation callback is invoked. Defaults to 10 seconds.

:long_verification_threshold (since v1.19.0) - the timeout (in seconds) to check for modules taking too long to compile. For each module that exceeds the threshold, the :each_long_verification callback is invoked. Defaults to 10 seconds.

:verification (since v1.19.0) - if code verification, such as unused functions, deprecation warnings, and ty

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
%{
  runtime_warnings: [warning],
  compile_warnings: [warning]
}
```

Example 2 (unknown):
```unknown
%{
  runtime_warnings: [warning],
  compile_warnings: [warning]
}
```

---

## Operators reference

**URL:** https://hexdocs.pm/elixir/operators.html

**Contents:**
- Operators reference
- Operator precedence and associativity
- General operators
- Comparison operators
- Custom and overridden operators
  - Defining custom operators

This document is a complete reference of operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.

The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:

Elixir provides the following built-in operators:

Many of those can be used in guards; consult the list of allowed guard functions and operators.

Additionally, there are a few other operators that Elixir parses but doesn't actually use. See Custom and overridden operators below for a list and for guidelines about their use.

Some other operators are special forms and cannot be overridden:

Finally, these operators appear in the precedence table above but are only meaningful within certain constructs:

Elixir provides the following built-in comparison operators (all of which can be used in guards):

The only difference between == and === is that === is strict when it comes to comparing integers and floats:

!= and !== act as the negation of == and ===, respectively.

Elixir is capable of parsing a predefined set of operators. It's not possible to define new operators (as supported by some languages). However, not all operators that Elixir can parse are used by Elixir: for example, + and || are used by Elixir for addition and boolean or, but <~> is not used (but valid).

To define an operator, you can use the usual def* constructs (def, defp, defmacro, and so on) but with a syntax similar to how the operator is used:

To use the newly defined operators, you have to import the module that defines them:

The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:

The following operators are used by the Bitwise module when imported: &&&, <<<, >>>, and |||. See the Bitwise documentation for more information.

Note that the Elixir community generally discourages custom operators. They can be hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices.

It is also possible to replace predefined operators, such as +, but doing so is extremely discouraged.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> 1 == 1.0
true
iex> 1 === 1.0
false
```

Example 2 (python):
```python
defmodule MyOperators do
  # We define ~> to return the maximum of the given two numbers,
  # and <~ to return the minimum.

  def a ~> b, do: max(a, b)
  def a <~ b, do: min(a, b)
end
```

Example 3 (unknown):
```unknown
iex> import MyOperators
iex> 1 ~> 2
2
iex> 1 <~ 2
1
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#parallel-compilation-of-dependencies

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_bitstring/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#code-loading-bottlenecks

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_pid/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defguardp/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#values/0

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#@/1-attention-multiple-references-of-the-same-attribute

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#case/2

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#send/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Function (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Function.html

**Contents:**
- Function (Elixir v1.19.0)
- The capture operator
- Internal and external functions
- Summary
- Types
- Functions
- Types
- information()
- Functions
- capture(module, function_name, arity)

A set of functions for working with functions.

Anonymous functions are typically created by using fn:

Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:

It is also possible to capture public module functions and pass them around as if they were anonymous functions by using the capture operator &/1:

To capture a definition within the current module, you can skip the module prefix, such as &my_fun/2. In those cases, the captured function can be public (def) or private (defp).

The capture operator can also be used to create anonymous functions that expect at least one argument:

In such cases, using the capture operator is no different than using fn.

We say that functions that point to definitions residing in modules, such as &String.length/1, are external functions. All other functions are local and they are always bound to the file or module that defined them.

Besides the functions in this module to work with functions, Kernel also has an apply/2 function that invokes a function with a dynamic number of arguments, as well as is_function/1 and is_function/2, to check respectively if a given value is a function or a function of a given arity.

Captures the given function.

Returns its input value. This function can be passed as an anonymous function to transformation functions.

Returns a keyword list with information about a function.

Returns a specific information about the function.

Captures the given function.

Inlined by the compiler.

Returns its input value. This function can be passed as an anonymous function to transformation functions.

Returns a keyword list with information about a function.

The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following:

:type - :local (for anonymous functions) or :external (for named functions).

:module - an atom which is the module where the function is defined when anonymous or the module which the function refers to when it's a named function.

:arity - (integer) the number of arguments the function is to be called with.

:name - (atom) the name of the function.

:env - a list of the environment or free variables. For named functions, the returned list is always empty.

When fun is an anonymous function (that is, the type is :local), the following additional keys are returned:

:pid - PID of the process that originally created the function.

:index - (integer) an index into the mod

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> add = fn a, b -> a + b end
iex> add.(1, 2)
3
```

Example 2 (unknown):
```unknown
iex> negate = fn
...>   true -> false
...>   false -> true
...> end
iex> negate.(false)
true
```

Example 3 (unknown):
```unknown
iex> add = &Kernel.+/2
iex> add.(1, 2)
3

iex> length = &String.length/1
iex> length.("hello")
5
```

Example 4 (unknown):
```unknown
iex> add = &(&1 + &2)
iex> add.(1, 2)
3
```

---

## Macro.Env (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Macro.Env.html

**Contents:**
- Macro.Env (Elixir v1.19.0)
- Struct fields
- Summary
- Types
- Functions
- Types
- context()
- context_modules()
- define_alias_opts()
- define_import_opts()

A struct that holds compile time environment information.

The current environment can be accessed at any time as __ENV__/0. Inside macros, the caller environment can be accessed as __CALLER__/0.

The majority of the functions in this module are provided for low-level tools, which need to integrate with the Elixir compiler, such as language servers and embedded languages. For regular usage in Elixir code and macros, you must use the Macro module instead. In particular, avoid modifying the Macro.Env struct directly and prefer to use high-level constructs, such as a import, aliases, and so forth to build your own environment. For example, to build a custom environment, you can define a function such as:

The Macro.Env struct contains the following fields:

The following fields are private to Elixir's macro expansion mechanism and must not be accessed directly:

Defines the given as an alias to module in the environment.

Defines the given module as imported in the environment.

Defines the given module as required in the environment.

Expands an alias given by the alias segments.

Expands an import given by name and arity.

Expands a require given by module, name, and arity.

Checks if a variable belongs to the environment.

Returns whether the compilation environment is currently inside a guard.

Returns whether the compilation environment is currently inside a match clause.

Returns a keyword list containing the file and line information as keys.

Returns the names of any aliases for the given module or atom.

Returns the modules from which the given {name, arity} was imported.

Prepend a tracer to the list of tracers in the environment.

Prunes compile information from the environment.

Returns true if the given module has been required.

Returns the environment stacktrace.

Returns an environment in the guard context.

Returns an environment in the match context.

Returns a list of variables in the current environment.

Defines the given as an alias to module in the environment.

This is used by tools which need to mimic the Elixir compiler. The appropriate :alias compiler tracing event will be emitted.

It accepts the same options as Kernel.SpecialForm.alias/2 plus:

If no :as option is given, the alias will be inferred from the module:

If it is not possible to infer one, an error is returned:

Defines the given module as imported in the environment.

It assumes module is available. This is used by tools which need to mimic the Elixir compiler. The app

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def make_custom_env do
  import SomeModule, only: [some_function: 2], warn: false
  alias A.B.C, warn: false
  __ENV__
end
```

Example 2 (unknown):
```unknown
iex> env = __ENV__
iex> Macro.Env.expand_alias(env, [], [:Baz])
:error
iex> {:ok, env} = Macro.Env.define_alias(env, [line: 10], Foo.Bar, as: Baz)
iex> Macro.Env.expand_alias(env, [], [:Baz])
{:alias, Foo.Bar}
iex> Macro.Env.expand_alias(env, [], [:Baz, :Bat])
{:alias, Foo.Bar.Bat}
```

Example 3 (unknown):
```unknown
iex> env = __ENV__
iex> {:ok, env} = Macro.Env.define_alias(env, [line: 10], Foo.Bar)
iex> Macro.Env.expand_alias(env, [], [:Bar])
{:alias, Foo.Bar}
```

Example 4 (unknown):
```unknown
iex> Macro.Env.define_alias(__ENV__, [line: 10], :an_atom)
{:error,
 "alias cannot be inferred automatically for module: :an_atom, " <>
   "please use the :as option. Implicit aliasing is only supported with Elixir modules"}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_bitstring/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Duration (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Duration.html

**Contents:**
- Duration (Elixir v1.19.0)
- Shifting
- Intervals
- Comparing durations
- Summary
- Types
- Functions
- Types
- duration()
- t()

Struct and functions for handling durations.

A Duration struct represents a collection of time scale units, allowing for manipulation and calculation of durations.

Date and time scale units are represented as integers, allowing for both positive and negative values.

Microseconds are represented using a tuple {microsecond, precision}. This ensures compatibility with other calendar types implementing time, such as Time, DateTime, and NaiveDateTime.

The most common use of durations in Elixir's standard library is to "shift" the calendar types.

In the example above, Date.shift/2 automatically converts the units into a Duration struct, although one can also be given directly:

It is important to note that shifting is not an arithmetic operation. For example, adding date + 1 month + 1 month does not yield the same result as date + 2 months. Let's see an example:

As you can see above, the results differ, which explains why operations with durations are called "shift" rather than "add". This happens because, once we add one month to 2016-01-31, we get 2016-02-29. Then adding one extra month gives us 2016-03-29 instead of 2016-03-31.

In particular, when applying durations to Calendar.ISO types:

larger units (such as years and months) are applied before smaller ones (such as weeks, hours, days, and so on)

units are collapsed into months (:year and :month), seconds (:week, :day, :hour, :minute, :second) and microseconds (:microsecond) before they are applied

1 year is equivalent to 12 months, 1 week is equivalent to 7 days. Therefore, 4 weeks are not equivalent to 1 month

in case of non-existing dates, the results are rounded down to the nearest valid date

As the shift/2 functions are calendar aware, they are guaranteed to return valid date/times, considering leap years as well as DST in applicable time zones.

Durations in Elixir can be combined with stream operations to build intervals. For example, to retrieve the next three Wednesdays starting from 17th April, 2024:

However, once again, it is important to remember that shifting a duration is not arithmetic, so you may want to use the functions in this module depending on what you to achieve. Compare the results of both examples below:

The second example consistently points to the last day of the month, as it performs operations on the duration, rather than shifting date after date.

In order to accurately compare durations, you need to either compare only certain fields or use a reference time insta

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Date.shift(~D[2016-01-03], month: 2)
~D[2016-03-03]
```

Example 2 (unknown):
```unknown
iex> Date.shift(~D[2016-01-03], Duration.new!(month: 2))
~D[2016-03-03]
```

Example 3 (unknown):
```unknown
iex> ~D[2016-01-31] |> Date.shift(month: 1) |> Date.shift(month: 1)
~D[2016-03-29]

iex> ~D[2016-01-31] |> Date.shift(month: 2)
~D[2016-03-31]
```

Example 4 (unknown):
```unknown
iex> ~D[2024-04-17] |> Stream.iterate(&Date.shift(&1, week: 1)) |> Enum.take(3)
[~D[2024-04-17], ~D[2024-04-24], ~D[2024-05-01]]
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#key/2

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Map (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Map.html

**Contents:**
- Map (Elixir v1.19.0)
    - Avoid parentheses
- Summary
- Types
- Functions
- Types
- key()
- value()
- Functions
- delete(map, key)

Maps are the "go to" key-value data structure in Elixir.

Maps can be created with the %{} syntax, and key-value pairs can be expressed as key => value:

Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).

Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicate keys. Keys are compared using the exact-equality operator (===/2). If colliding keys are defined in a map literal, the last one prevails.

When the key in a key-value pair is an atom, the key: value shorthand syntax can be used (as in many other special forms):

If you want to mix the shorthand syntax with =>, the shorthand syntax must come at the end:

Keys in maps can be accessed through some of the functions in this module (such as Map.get/3 or Map.fetch/2) or through the map[] syntax provided by the Access module:

To access atom keys, one may also use the map.key notation. Note that map.key will raise a KeyError if the map doesn't contain the key :key, compared to map[:key], that would return nil.

Do not add parentheses when accessing fields, such as in data.key(). If parentheses are used, Elixir will expect data to be an atom representing a module and attempt to call the function key/0 in it.

The two syntaxes for accessing keys reveal the dual nature of maps. The map[key] syntax is used for dynamically created maps that may have any key, of any type. map.key is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via defstruct/1, are one example of such "static maps", where the keys can also be checked during compile time.

Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.

But this will raise a MatchError exception:

Variables can be used as map keys both when writing map literals as well as when matching:

Maps also support a specific update syntax to update the value stored under existing keys. You can update using the atom keys syntax:

When a key that does not exist in the map is updated a KeyError exception will be raised:

The functions in this module that need to find a specific key work in logarithmic time. This me

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> %{}
%{}
iex> %{"one" => :two, 3 => "four"}
%{3 => "four", "one" => :two}
```

Example 2 (unknown):
```unknown
iex> %{a: 1, b: 2}
%{a: 1, b: 2}
```

Example 3 (javascript):
```javascript
iex> %{"hello" => "world", a: 1, b: 2}
%{:a => 1, :b => 2, "hello" => "world"}
```

Example 4 (unknown):
```unknown
iex> map = %{a: 1, b: 2}
iex> Map.fetch(map, :a)
{:ok, 1}
iex> map[:b]
2
iex> map["non_existing_key"]
nil
```

---

## Enum (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enum.html#map/2

**Contents:**
- Enum (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- acc()
- default()
- element()
- index()
- t()

Functions for working with collections (known as enumerables).

In Elixir, an enumerable is any data type that implements the Enumerable protocol. Lists ([1, 2, 3]), Maps (%{foo: 1, bar: 2}) and Ranges (1..3) are common data types used as enumerables:

Many other enumerables exist in the language, such as MapSets and the data type returned by File.stream!/3 which allows a file to be traversed as if it was an enumerable.

For a general overview of all functions in the Enum module, see the Enum cheatsheet.

The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as Enum.map/2. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.

This linear behavior should also be expected on operations like count/1, member?/2, at/2 and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the Enum module is meant to work with a large variety of data types and not all data types can provide optimized behavior.

Finally, note the functions in the Enum module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the Stream module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the Stream module for examples and documentation.

Zero-based index. It can also be a negative integer.

Returns true if all elements in enumerable are truthy.

Returns true if fun.(element) is truthy for all elements in enumerable.

Returns true if at least one element in enumerable is truthy.

Returns true if fun.(element) is truthy for at least one element in enumerable.

Finds the element at the given index (zero-based).

Splits enumerable on every element for which fun returns a new value.

Shortcut to chunk_every(enumerable, count, count).

Returns list of lists containing count elements each, where each new chunk starts step elements into the enumerable.

Chunks the enumerable with fine grained control when every chunk is emitted.

Given an enumerable of enumerables, concatenates the enumerables into a single list.

Concatenates the enumerable on the right with the 

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> Enum.map([1, 2, 3], fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum([1, 2, 3])
6

iex> Enum.map(1..3, fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum(1..3)
6

iex> map = %{"a" => 1, "b" => 2}
iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)
[{"a", 2}, {"b", 4}]
```

Example 2 (unknown):
```unknown
iex> Enum.all?([1, 2, 3])
true

iex> Enum.all?([1, nil, 3])
false

iex> Enum.all?([])
true
```

Example 3 (unknown):
```unknown
iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)
true

iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)
false

iex> Enum.all?([], fn _ -> nil end)
true
```

Example 4 (unknown):
```unknown
iex> Enum.any?([false, false, false])
false

iex> Enum.any?([false, true, false])
true

iex> Enum.any?([])
false
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_string/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-process-based-and-application-centric-functionality

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Exception behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Exception.html#c:message/1

**Contents:**
- Exception behaviour (Elixir v1.19.0)
- Formatting functions
- Summary
- Types
- Callbacks
- Functions
- Types
- arity_or_args()
- kind()
- location()

Functions for dealing with throw/catch/exit and exceptions.

This module also defines the behaviour required by custom exceptions. To define your own, see defexception/1.

Several functions in this module help format exceptions. Some of these functions expect the stacktrace as argument. The stacktrace is typically available inside catch and rescue by using the __STACKTRACE__/0 variable.

Do not rely on the particular format returned by the functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.

The kind handled by formatting functions

Called from Exception.blame/3 to augment the exception struct.

Receives the arguments given to raise/2 and returns the exception struct.

Receives the exception struct and must return its message.

Attaches information to throws/errors/exits for extra debugging.

Blames the invocation of the given module, function and arguments.

Normalizes and formats throws/errors/exits and stacktraces.

Normalizes and formats any throw/error/exit.

Formats an exit. It returns a string.

Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.

Formats the given file and line as shown in stacktraces.

Formats the given file, line, and column as shown in stacktraces.

Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.

Formats the stacktrace.

Receives a stacktrace entry and formats it into a string.

Gets the message for an exception.

Normalizes an exception, converting Erlang exceptions to Elixir exceptions.

The kind handled by formatting functions

Called from Exception.blame/3 to augment the exception struct.

Can be used to collect additional information about the exception or do some additional expensive computation.

Receives the arguments given to raise/2 and returns the exception struct.

The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message.

Receives the exception struct and must return its message.

Many exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented.

Attaches information to t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
Exception.format_fa(fn -> nil end, 1)
#=> "#Function<...>/1"
```

Example 2 (unknown):
```unknown
iex> Exception.format_file_line("foo", 1)
"foo:1:"

iex> Exception.format_file_line("foo", nil)
"foo:"

iex> Exception.format_file_line(nil, nil)
""
```

Example 3 (unknown):
```unknown
iex> Exception.format_file_line_column("foo", 1, 2)
"foo:1:2:"

iex> Exception.format_file_line_column("foo", 1, nil)
"foo:1:"

iex> Exception.format_file_line_column("foo", nil, nil)
"foo:"

iex> Exception.format_file_line_column("foo", nil, 2)
"foo:"

iex> Exception.format_file_line_column(nil, nil, nil)
""
```

Example 4 (unknown):
```unknown
iex> Exception.format_mfa(Foo, :bar, 1)
"Foo.bar/1"

iex> Exception.format_mfa(Foo, :bar, [])
"Foo.bar()"

iex> Exception.format_mfa(nil, :bar, [])
"nil.bar()"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_link/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## List (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/List.html

**Contents:**
- List (Elixir v1.19.0)
- Charlists
- Summary
- Functions
- Functions
- ascii_printable?(list, limit \\ :infinity)
- Examples
- delete(list, element)
- Examples
- delete_at(list, index)

Linked lists hold zero, one, or more elements in the chosen order.

Lists in Elixir are specified between square brackets:

Two lists can be concatenated and subtracted using the ++/2 and --/2 operators:

An element can be prepended to a list using |:

Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:

Similarly, we could write the list [1, 2, 3] using only such pairs (called cons cells):

Some lists, called improper lists, do not have an empty list as the second element in the last cons cell:

Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the IO module).

Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time):

Most of the functions in this module work in linear time. This means that the time it takes to perform an operation grows at the same rate as the length of the list. For example length/1 and last/1 will run in linear time because they need to iterate through every element of the list, but first/1 will run in constant time because it only needs the first element.

Lists also implement the Enumerable protocol, so many functions to work with lists are found in the Enum module. Additionally, the following functions and operators for lists are found in Kernel:

If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:

Elixir uses the ~c sigil to define charlists:

In particular, charlists will be printed back by default with the ~c sigil if they contain only printable ASCII characters:

Even though the representation changed, the raw data does remain a list of integers, which can be handled as such:

You can use the IEx.Helpers.i/1 helper to get a condensed rundown on charlists in IEx when you encounter them, which shows you the type, description and also the raw representation in one single summary.

The rationale behind this behavior is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is Application.loaded_applications/0:

A list can be checked if it is made of only printable ASCII charact

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> [1, "two", 3, :four]
[1, "two", 3, :four]
```

Example 2 (unknown):
```unknown
iex> [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex> [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]
```

Example 3 (unknown):
```unknown
iex> new = 0
iex> list = [1, 2, 3]
iex> [new | list]
[0, 1, 2, 3]
```

Example 4 (unknown):
```unknown
iex> [head | tail] = [1, 2, 3]
iex> head
1
iex> tail
[2, 3]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#put_elem/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%25/2

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Enumerable protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enumerable.html

**Contents:**
- Enumerable protocol (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- acc()
- continuation()
- reducer()
- result()
- slicing_fun()

Enumerable protocol used by Enum and Stream modules.

When you invoke a function in the Enum module, the first argument is usually a collection that must implement this protocol. For example, the expression Enum.map([1, 2, 3], &(&1 * 2)) invokes Enumerable.reduce/3 to perform the reducing operation that builds a mapped list by calling the mapping function &(&1 * 2) on every element in the collection and consuming the element with an accumulated list.

Internally, Enum.map/2 is implemented as follows:

Note that the user-supplied function is wrapped into a reducer/0 function. The reducer/0 function must return a tagged tuple after each step, as described in the acc/0 type. At the end, Enumerable.reduce/3 returns result/0.

This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the zip/1 and zip/2 functions).

This protocol requires four functions to be implemented, reduce/3, count/1, member?/2, and slice/1. The core of the protocol is the reduce/3 function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.

The accumulator value for each step.

A partially applied reduce function.

The reducer function.

The result of the reduce operation.

A slicing function that receives the initial position, the number of elements in the slice, and the step.

All the types that implement this protocol.

An enumerable of elements of type element.

Receives an enumerable and returns a list.

Retrieves the number of elements in the enumerable.

Checks if an element exists within the enumerable.

Reduces the enumerable into an element.

Returns a function that slices the data structure contiguously.

The accumulator value for each step.

It must be a tagged tuple with one of the following "tags":

Depending on the accumulator value, the result returned by Enumerable.reduce/3 will change. Please check the result/0 type documentation for more information.

In case a reducer/0 function returns a :suspend accumulator, it must be explicitly handled by the caller and never leak.

A partially applied reduce function.

The continuati

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def map(enumerable, fun) do
  reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end
  Enumerable.reduce(enumerable, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()
end
```

Example 2 (python):
```python
@spec integers_to_strings(Enumerable.t(integer())) :: Enumerable.t(String.t())
def integers_to_strings(integers) do
  Stream.map(integers, &Integer.to_string/1)
end
```

Example 3 (python):
```python
def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}
def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}
def reduce([], {:cont, acc}, _fun), do: {:done, acc}
def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#or/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#var!/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## DateTime (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/DateTime.html

**Contents:**
- DateTime (Elixir v1.19.0)
- Time zone database
- Datetimes as snapshots
- Converting between timezones
- Summary
- Types
- Functions
- Types
- t()
- Functions

A datetime implementation with a time zone.

This datetime can be seen as a snapshot of a date and time at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes. Note future datetimes are not necessarily guaranteed to exist, as time zones may change any time in the future due to geopolitical reasons. See the "Datetimes as snapshots" section for more information.

Remember, comparisons in Elixir using ==/2, >/2, </2 and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the compare/2, after?/2 and before?/2 functions. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum datetime of an Enum. For example:

Developers should avoid creating the DateTime struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.

Many functions in this module require a time zone database. A time zone database is a record of the UTC offsets that its locales have used at various times in the past, are using, and are expected to use in the future. Because those plans can change, it needs to be periodically updated.

By default, DateTime uses the default time zone database returned by Calendar.get_time_zone_database/0, which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles "Etc/UTC" datetimes and returns {:error, :utc_only_time_zone_database} for any other time zone.

Other time zone databases can also be configured. Here are some available options and libraries:

To use one of them, first make sure it is added as a dependency in mix.exs. It can then be configured either via configuration:

or by calling Calendar.put_time_zone_database/1:

See the proper names in the library installation instructions.

In the first section, we described datetimes as a "snapshot of a date and time at a given time zone". To understand precisely what we mean, let's see an example.

Imagine someone in Poland who wants to schedule a meeting with someone in Brazil in the next year. The meeting will happen at 2:30 AM in the Polish time zone. At what time will the meeting happen in Brazil?

You can consult the time zone database today, one year before, using the API in this module and it will give you an answer that is valid right now. However, this answer may not be vali

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Enum.min([~U[2022-01-12 00:01:00.00Z], ~U[2021-01-12 00:01:00.00Z]], DateTime)
~U[2021-01-12 00:01:00.00Z]
```

Example 2 (unknown):
```unknown
config :elixir, :time_zone_database, Tz.TimeZoneDatabase
```

Example 3 (unknown):
```unknown
Calendar.put_time_zone_database(Tz.TimeZoneDatabase)
```

Example 4 (javascript):
```javascript
# Local time to UTC
new_york = DateTime.from_naive!(~N[2023-06-26T09:30:00], "America/New_York")
#=> #DateTime<2023-06-26 09:30:00-04:00 EDT America/New_York>

utc = DateTime.shift_zone!(new_york, "Etc/UTC")
#=> ~U[2023-06-26 13:30:00Z]

# UTC to local time
DateTime.shift_zone!(utc, "Europe/Paris")
#=> #DateTime<2023-06-26 15:30:00+02:00 CEST Europe/Paris>
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#min/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_in/2-working-with-structs

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#trunc/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmacro/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#div/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_charlist/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#unless/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmacro/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html#our-first-project

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#4-hard-deprecations

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-term-ordering

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-data-types

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_list/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Module behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Module.html#register_attribute/3

**Contents:**
- Module behaviour (Elixir v1.19.0)
- Module attributes
  - @after_compile
  - @after_verify (since v1.14.0)
  - @before_compile
  - @behaviour
  - @impl (since v1.5.0)
  - @compile
  - @deprecated (since v1.6.0)
  - @doc and @typedoc

Provides functions to deal with modules during compilation time.

It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.

After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the __info__/1 function attached to each compiled module.

Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir:

A hook that will be invoked right after the current module is compiled. Accepts a module or a {module, function_name}. See the "Compile callbacks" section below.

A hook that will be invoked right after the current module is verified for undefined functions, deprecations, etc. Accepts a module or a {module, function_name}. See the "Compile callbacks" section below.

A hook that will be invoked before the module is compiled. Accepts a module or a {module, function_or_macro_name} tuple. See the "Compile callbacks" section below.

Note the British spelling!

Behaviours can be referenced by modules to ensure they implement required specific function signatures defined by @callback.

For example, you could specify a URI.Parser behaviour as follows:

And then a module may use it as:

If the behaviour changes or URI.HTTP does not implement one of the callbacks, a warning will be raised.

For detailed documentation, see the behaviour typespec documentation.

To aid in the correct implementation of behaviours, you may optionally declare @impl for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases:

if you mark a function with @impl when that function is not a callback.

if you don't mark a function with @impl when other functions are marked with @impl. If you mark one function with @impl, you must mark all other callbacks for that behaviour as @impl.

@impl works on a per-context basis. If you generate a function through a macro and mark it with @impl, that won't affect the module where that function is generated in.

@impl also helps with maintainability by making it clear to other developers that the function is implementing a callback.

Using @impl, the example above can be rewritten as:

You may pass either false, true, or a specific behaviour to @impl.

The code is now more readable, as it is now clear which functions are part of yo

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule URI.Parser do
  @doc "Defines a default port"
  @callback default_port() :: integer

  @doc "Parses the given URL"
  @callback parse(uri_info :: URI.t()) :: URI.t()
end
```

Example 2 (python):
```python
defmodule URI.HTTP do
  @behaviour URI.Parser
  def default_port(), do: 80
  def parse(info), do: info
end
```

Example 3 (python):
```python
defmodule URI.HTTP do
  @behaviour URI.Parser

  @impl true
  def default_port(), do: 80

  @impl true
  def parse(info), do: info
end
```

Example 4 (python):
```python
defmodule Foo do
  @behaviour Bar
  @behaviour Baz

  # Will warn if neither Bar nor Baz specify a callback named bar/0.
  @impl true
  def bar(), do: :ok

  # Will warn if Baz does not specify a callback named baz/0.
  @impl Baz
  def baz(), do: :ok
end
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html#environments

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#exit/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_nil/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3C=/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_binary/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Time (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Time.html

**Contents:**
- Time (Elixir v1.19.0)
- Comparing times
- Summary
- Types
- Functions
- Types
- t()
- Functions
- add(time, amount_to_add, unit \\ :second)
    - Prefer shift/2

A Time struct and functions.

The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the new/4 function or using the ~T (see sigil_T/2) sigil:

Both new/4 and sigil return a struct where the time fields can be accessed directly:

The functions on this module work with the Time struct as well as any struct that contains the same fields as the Time struct, such as NaiveDateTime and DateTime. Such functions expect Calendar.time/0 in their typespecs (instead of t/0).

Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.

Comparisons in Elixir using ==/2, >/2, </2 and similar are structural and based on the Time struct fields. For proper comparison between times, use the compare/2, after?/2 and before?/2 functions. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum time of an Enum. For example:

Adds the amount_to_add of units to the given time.

Returns true if the first time is strictly later than the second.

Returns true if the first time is strictly earlier than the second.

Compares two time structs.

Converts given time to a different calendar.

Similar to Time.convert/2, but raises an ArgumentError if the conversion between the two calendars is not possible.

Returns the difference between two times, considering only the hour, minute, second and microsecond.

Converts an Erlang time tuple to a Time struct.

Converts an Erlang time tuple to a Time struct.

Parses the extended "Local time" format described by ISO 8601:2019.

Parses the extended "Local time" format described by ISO 8601:2019.

Converts a number of seconds after midnight to a Time struct.

Shifts given time by duration according to its calendar.

Converts given time to an Erlang time tuple.

Converts the given time to ISO 8601:2019.

Converts a Time struct to a number of seconds after midnight.

Converts the given time to a string.

Returns the given time with the microsecond field truncated to the given precision (:microsecond, millisecond or :second).

Returns the current time in UTC.

Returns the current time in UTC, supporting a precision and a specific calendar.

Adds the amount_to_add of units to the given time.

Prefer shift/2 over add/3, as it offers a more ergonomic API.

add/3 always considers the unit to be computed according to

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> ~T[23:00:07.001]
~T[23:00:07.001]
```

Example 2 (unknown):
```unknown
iex> time = ~T[23:00:07.001]
iex> time.hour
23
iex> time.microsecond
{1000, 3}
```

Example 3 (unknown):
```unknown
iex> Enum.min([~T[23:00:07.001], ~T[10:00:07.001]], Time)
~T[10:00:07.001]
```

Example 4 (unknown):
```unknown
iex> Time.add(~T[10:00:00], 27000)
~T[17:30:00]
iex> Time.add(~T[11:00:00.005], 2400)
~T[11:40:00.005]
iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)
~T[23:59:59.999]
```

---

## Basic types

**URL:** https://hexdocs.pm/elixir/basic-types.html

**Contents:**
- Basic types
- Basic arithmetic
- Booleans and nil
- Atoms
- Strings
- Structural comparison

In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, and strings. Other data types, such as lists and tuples, will be explored in the next chapter.

Open up iex and type the following expressions:

Notice that 10 / 2 returned a float 5.0 instead of an integer 5. This is expected. In Elixir, the operator / always returns a float. If you want to do integer division or get the division remainder, you can invoke the div and rem functions:

Notice that Elixir allows you to drop the parentheses when invoking functions that expect one or more arguments. This feature gives a cleaner syntax when writing declarations and control-flow constructs. However, Elixir developers generally prefer to use parentheses.

Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:

Float numbers require a dot followed by at least one digit and also support e for scientific notation:

Floats in Elixir are 64-bit precision.

You can invoke the round function to get the closest integer to a given float, or the trunc function to get the integer part of a float.

Finally, we work with different data types, we will learn Elixir provides several predicate functions to check for the type of a value. For example, is_integer can be used to check if a value is an integer or not:

You can also use is_float or is_number to check, respectively, if an argument is a float, or either an integer or float.

Elixir supports true and false as booleans:

Elixir also provides three boolean operators: or, and, and not. These operators are strict in the sense that they expect something that evaluates to a boolean (true or false) as their first argument:

Providing a non-boolean will raise an exception:

or and and are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:

Elixir also provides the concept of nil, to indicate the absence of a value, and a set of logical operators that also manipulate nil: ||/2, &&/2, and !/1. For these operators, false and nil are considered "falsy", all other values are considered "truthy":

Similarly, values like 0 and "", which some other programming languages consider to be "falsy", are also "truthy" in Elixir.

As a rule of thumb, use and, or and not when you are expecting booleans. If any of the arguments are non-boolean, use &&, || and !.

An atom is a constant whose value is its own name. Some other languages call these symbols. T

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```

Example 2 (unknown):
```unknown
iex> 1 + 2
3
iex> 5 * 5
25
iex> 10 / 2
5.0
```

Example 3 (unknown):
```unknown
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1
```

Example 4 (unknown):
```unknown
iex> 0b1010
10
iex> 0o777
511
iex> 0x1F
31
```

---

## Patterns and guards

**URL:** https://hexdocs.pm/elixir/patterns-and-guards.html#guards

**Contents:**
- Patterns and guards
- Patterns
  - Variables
  - Literals (numbers and atoms)
  - Tuples
  - Lists
  - Maps
  - Structs
  - Binaries
- Guards

Elixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.

This document provides a complete reference on patterns and guards, their semantics, where they are allowed, and how to extend them.

Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator (=):

In the example above, x starts without a value and has 1 assigned to it. Then, we compare the value of x to the literal 1, which succeeds as they are both 1.

Matching x against 2 would raise:

Patterns are not bidirectional. If you have a variable y that was never assigned to (often called an unbound variable) and you write 1 = y, an error will be raised:

In other words, patterns are allowed only on the left side of =. The right side of = follows the regular evaluation semantics of the language.

Now let's cover the pattern matching rules for each construct and then for each relevant data types.

Variables in patterns are always assigned to:

In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (^):

If the same variable appears multiple times in the same pattern, then all of them must be bound to the same value:

The underscore variable (_) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:

A pinned value represents the value itself and not its – even if syntactically equal – pattern. The right hand side is compared to be equal to the pinned value:

Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom:

Similar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats:

Tuples may appear in patterns using the curly brackets syntax ({}). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:

Lists may appear in patterns using the square brackets syntax ([]). A list in a pattern will match only lists of the same size, where each individual list element must also match:

Opposite to tuples, lists al

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> x = 1
1
iex> 1 = x
1
```

Example 2 (unknown):
```unknown
iex> 2 = x
** (MatchError) no match of right hand side value: 1
```

Example 3 (unknown):
```unknown
iex> 1 = y
** (CompileError) iex:2: undefined variable "y"
```

Example 4 (unknown):
```unknown
iex> x = 1
1
iex> x = 2
2
iex> x
2
```

---

## GenServer behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/GenServer.html

**Contents:**
- GenServer behaviour (Elixir v1.19.0)
- Example
    - use GenServer
- Client / Server APIs
- How to supervise
- Name registration
- Receiving "regular" messages
- Timeouts
- When (not) to use a GenServer
- Debugging with the :sys module

A behaviour module for implementing the server of a client-server relation.

A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.

The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in.

Let's start with a code example and then explore the available callbacks. Imagine we want to implement a service with a GenServer that works like a stack, allowing us to push and pop elements. We'll customize a generic GenServer with our own module by implementing three callbacks.

init/1 transforms our initial argument to the initial state for the GenServer. handle_call/3 fires when the server receives a synchronous pop message, popping an element from the stack and returning it to the user. handle_cast/2 will fire when the server receives an asynchronous push message, pushing an element onto the stack:

We leave the process machinery of startup, message passing, and the message loop to the GenServer behaviour and focus only on the stack implementation. We can now use the GenServer API to interact with the service by creating a process and sending it messages:

We start our Stack by calling start_link/2, passing the module with the server implementation and its initial argument with a comma-separated list of elements. The GenServer behaviour calls the init/1 callback to establish the initial GenServer state. From this point on, the GenServer has control so we interact with it by sending two types of messages on the client. call messages expect a reply from the server (and are therefore synchronous) while cast messages do not.

Each call to GenServer.call/3 results in a message that must be handled by the handle_call/3 callback in the GenServer. A cast/2 message must be handled by handle_cast/2. GenServer supports 8 callbacks, but only init/1 is required.

When you use GenServer, the GenServer module will set @behaviour GenServer and define a child_spec/1 function, so your module can be used as a child in a supervision tree.

Although in the example above we have used GenServer.start_link/3 and friends to directly start and communicate with 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
graph BT
    C(Client #3) ~~~ B(Client #2) ~~~ A(Client #1)
    A & B & C -->|request| GenServer
    GenServer -.->|reply| A & B & C
```

Example 2 (python):
```python
defmodule Stack do
  use GenServer

  # Callbacks

  @impl true
  def init(elements) do
    initial_state = String.split(elements, ",", trim: true)
    {:ok, initial_state}
  end

  @impl true
  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    {:reply, to_caller, new_state}
  end

  @impl true
  def handle_cast({:push, element}, state) do
    new_state = [element | state]
    {:noreply, new_state}
  end
end
```

Example 3 (javascript):
```javascript
# Start the server
{:ok, pid} = GenServer.start_link(Stack, "hello,world")

# This is the client
GenServer.call(pid, :pop)
#=> "hello"

GenServer.cast(pid, {:push, "elixir"})
#=> :ok

GenServer.call(pid, :pop)
#=> "elixir"
```

Example 4 (python):
```python
defmodule Stack do
  use GenServer

  # Client

  def start_link(default) when is_binary(default) do
    GenServer.start_link(__MODULE__, default)
  end

  def push(pid, element) do
    GenServer.cast(pid, {:push, element})
  end

  def pop(pid) do
    GenServer.call(pid, :pop)
  end

  # Server (callbacks)

  @impl true
  def init(elements) do
    initial_state = String.split(elements, ",", trim: true)
    {:ok, initial_state}
  end

  @impl true
  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    {:reply, to_caller, new_state}
  end

  @impl true
  def handle_cas
...
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_number/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction

**URL:** https://hexdocs.pm/elixir/introduction.html#running-scripts

**Contents:**
- Introduction
- Installation
- Interactive mode
- Running scripts

This guide will teach you about Elixir fundamentals - the language syntax, how to define modules, the common data structures in the language, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir's Interactive Shell, called IEx.

If you haven't yet installed Elixir, visit our installation page. Once you are done, you can run elixir --version to get the current Elixir version. The requirements for this guide are:

If you are looking for other resources for learning Elixir, you can also consult the learning page of the official website.

When you install Elixir, you will have three new command line executables: iex, elixir and elixirc.

For now, let's start by running iex (or iex.bat if you are on Windows PowerShell, where iex is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let's warm up with some basic expressions.

Open up iex and type the following expressions:

Please note that some details like version numbers may differ a bit in your session, that's not important. By executing the code above, you should evaluate expressions and see their results. To exit iex press Ctrl+C twice.

It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.

After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:

Save it as simple.exs and execute it with elixir:

iex and elixir are all we need to learn the main language concepts. There is a separate guide named "Mix and OTP guide" that explores how to actually create, manage, and test full-blown Elixir projects. For now, let's move on to learn the basic data types in the language.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
Erlang/OTP 26 [64-bit] [smp:2:2] [...]

Interactive Elixir - press Ctrl+C to exit
iex(1)> 40 + 2
42
iex(2)> "hello" <> " world"
"hello world"
```

Example 2 (unknown):
```unknown
IO.puts("Hello world from Elixir")
```

Example 3 (unknown):
```unknown
$ elixir simple.exs
Hello world from Elixir
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#tuple_size/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#or/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_W/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#t:get_and_update_fun/2

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defstruct/1-deriving

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_c/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#guards

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binary_slice/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Float (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Float.html

**Contents:**
- Float (Elixir v1.19.0)
- Kernel functions
- Known issues
- Summary
- Types
- Functions
- Types
- precision_range()
- Functions
- ceil(number, precision \\ 0)

Functions for working with floating-point numbers.

For mathematical operations on top of floating-points, see Erlang's :math module.

There are functions related to floating-point numbers on the Kernel module too. Here is a list of them:

There are some very well known problems with floating-point numbers and arithmetic due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.

For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:

There are also other known problems like flooring or rounding numbers. See round/2 and floor/2 for more details about them.

To learn more about floating-point arithmetic visit:

Rounds a float to the smallest float greater than or equal to number.

Rounds a float to the largest float less than or equal to number.

Returns the maximum finite value for a float.

Returns the minimum finite value for a float.

Parses a binary into a float.

Computes base raised to power of exponent.

Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator.

Rounds a floating-point value to an arbitrary number of fractional digits (between 0 and 15).

Returns a charlist which corresponds to the shortest text representation of the given float.

Returns a binary which corresponds to the shortest text representation of the given float.

Rounds a float to the smallest float greater than or equal to number.

ceil/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15).

The operation is performed on the binary floating point, without a conversion to decimal.

The behavior of ceil/2 for floats can be surprising. For example:

One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behavior above.

This function always returns floats. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards.

Rounds a float to the largest float less than or equal to number.

floor/2 also accepts a precision to round a floating-point va

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Float.ceil(-12.52, 2)
-12.51
```

Example 2 (unknown):
```unknown
iex> Float.ceil(34.25)
35.0
iex> Float.ceil(-56.5)
-56.0
iex> Float.ceil(34.251, 2)
34.26
iex> Float.ceil(-0.01)
-0.0
```

Example 3 (unknown):
```unknown
iex> Float.floor(12.52, 2)
12.51
```

Example 4 (unknown):
```unknown
iex> Float.floor(34.25)
34.0
iex> Float.floor(-56.5)
-57.0
iex> Float.floor(34.259, 2)
34.25
```

---

## Protocol behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Protocol.html#derive/3

**Contents:**
- Protocol behaviour (Elixir v1.19.0)
- Example
- Protocols and Structs
- Fallback to Any
- Multiple implementations
- Types
- Configuration
- Consolidation
- Summary
- Callbacks

Reference and functions for working with protocols.

A protocol specifies an API that should be defined by its implementations. A protocol is defined with Kernel.defprotocol/2 and its implementations with Kernel.defimpl/3.

In Elixir, we have two nouns for checking how many items there are in a data structure: length and size. length means the information must be computed. For example, length(list) needs to traverse the whole list to calculate its length. On the other hand, tuple_size(tuple) and byte_size(binary) do not depend on the tuple and binary size as the size information is precomputed in the data structure.

Although Elixir includes specific functions such as tuple_size, binary_size and map_size, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:

Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:

Finally, we can use the Size protocol to call the correct implementation:

Note that we didn't implement it for lists as we don't have the size information on lists, rather its value needs to be computed with length.

The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol.

It is possible to implement protocols for all Elixir types:

The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like MapSet. We can implement the Size protocol for those types as well:

When implementing a protocol for a struct, the :for option can be omitted if the defimpl/3 call is inside the module that defines the struct:

If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to Any. Conveniences for building implementations on top of existing ones are also available, look at defstruct/1 for more information about deriving protocols.

In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the @fallback_to_any attribute to true in the protocol definition:

The Size protocol can now be implemented for Any:

Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integ

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end
```

Example 2 (python):
```python
defimpl Size, for: BitString do
  def size(binary), do: byte_size(binary)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

Example 3 (javascript):
```javascript
Size.size({1, 2})
# => 2
Size.size(%{key: :value})
# => 1
```

Example 4 (python):
```python
defimpl Size, for: MapSet do
  def size(map_set), do: MapSet.size(map_set)
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#min/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_s/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#def/2-rescue-catch-after-else

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## File (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/File.html

**Contents:**
- File (Elixir v1.19.0)
- Encoding
- API
- Processes and raw files
- Seeking within a file
- Summary
- Types
- Functions
- Types
- encoding_mode()

This module contains functions to manipulate files.

Some of those functions are low-level, allowing the user to interact with files or IO devices, like open/2, copy/3 and others. This module also provides higher level functions that work with filenames and have their naming based on Unix variants. For example, one can copy a file via cp/3 and remove files and directories recursively via rm_rf/1.

Paths given to functions in this module can be either relative to the current working directory (as returned by File.cwd/0), or absolute paths. Shell conventions like ~ are not expanded automatically. To use paths like ~/Downloads, you can use Path.expand/1 or Path.expand/2 to expand your path to an absolute path.

In order to write and read files, one must use the functions in the IO module. By default, a file is opened in binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file, then the slower IO.read/2 and IO.write/2 functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.

Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.

Most of the functions in this module return :ok or {:ok, result} in case of success, {:error, reason} otherwise. Those functions also have a variant that ends with ! which returns the result (instead of the {:ok, result} tuple) in case of success or raises an exception in case it fails. For example:

In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).

Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.

This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.

However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in :raw mode. The options :read_ahead and :delayed_write are also useful when operating on large files or working with files in tight loo

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
File.read("hello.txt")
#=> {:ok, "World"}

File.read("invalid.txt")
#=> {:error, :enoent}

File.read!("hello.txt")
#=> "World"

File.read!("invalid.txt")
#=> raises File.Error
```

Example 2 (javascript):
```javascript
File.write!("example.txt", "Eats, Shoots & Leaves")
file = File.open!("example.txt")
:file.pread(file, 15, 6)
#=> {:ok, "Leaves"}
```

Example 3 (javascript):
```javascript
:file.position(file, 6)
#=> {:ok, 6}
:file.read(file, 6)
#=> {:ok, "Shoots"}
:file.position(file, {:cur, -12})
#=> {:ok, 0}
:file.read(file, 4)
#=> {:ok, "Eats"}
```

Example 4 (javascript):
```javascript
File.cd("bin")
#=> :ok

File.cd("non_existing_dir")
#=> {:error, :enoent}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_function/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Regex (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Regex.html#to_embed/2

**Contents:**
- Regex (Elixir v1.19.0)
- Escapes
  - Non-printing characters
  - Generic character types
- Modifiers
- Captures
- Character classes
- Summary
- Types
- Functions

Provides regular expressions for Elixir.

Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's :re module. More information can be found in the :re module documentation.

Regular expressions in Elixir can be created using the sigils ~r (see sigil_r/2):

A Regex is represented internally as the Regex struct. Therefore, %Regex{} can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. And since regexes are compiled, there is no guarantee two regular expressions from the same source are equal, for example:

may return true or false depending on your machine, endianness, available optimizations and others. You can, however, retrieve the source of a compiled regular expression by accessing the source field, and then compare those directly:

Escape sequences are split into two categories.

\u and \U are not supported. Other escape sequences, such as \ddd for octals, are supported but discouraged.

The modifiers available when creating a Regex are:

:unicode (u) - enables Unicode specific patterns like \p and causes character classes like \w, \W, \s, and the like to also match on Unicode (see examples below in "Character classes"). It expects valid Unicode strings to be given on match

:caseless (i) - adds case insensitivity

:dotall (s) - causes dot to match newlines and also sets newline to (*ANYCRLF).The new line setting, as described in the :re documentation, can be overridden by starting the regular expression pattern with:

:multiline (m) - causes ^ and $ to mark the beginning and end of each line; use \A and \z to match the end or beginning of the string

:extended (x) - whitespace characters are ignored except when escaped or within [..], and allow # to delimit comments

:firstline (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline

:ungreedy (U) - inverts the "greediness" of the regexp (the previous r option is deprecated in favor of U)

Many functions in this module handle what to capture in a regex match via the :capture option. The supported values are:

:all - all captured subpatterns including the complete matching string (this is the default)

:first - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded

:all_but_first - all but the first matching subpattern, i.e. all explicitly captured s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
# A simple regular expression that matches foo anywhere in the string
~r/foo/

# A regular expression with case insensitive and Unicode options
~r/foo/iu
```

Example 2 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/
```

Example 3 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source
```

Example 4 (unknown):
```unknown
iex> String.match?("123", ~r/^[[:alnum:]]+$/)
true
iex> String.match?("123 456", ~r/^[[:alnum:][:blank:]]+$/)
true
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_number/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_w/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#raise/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_C/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#function_exported?/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#rem/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#pop_in/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_in/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_T/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#+/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-truthy-and-falsy-values

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2-pitfalls

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Code (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Code.html#ensure_loaded?/1

**Contents:**
- Code (Elixir v1.19.0)
- Working with files
- Code loading on the Erlang VM
- ensure_compiled/1 and ensure_compiled!/1
- Compilation tracers
- Summary
- Types
- Functions
- Types
- binding()

Utilities for managing code compilation, code evaluation, and code loading.

This module complements Erlang's :code module to add behavior which is specific to Elixir. For functions to manipulate Elixir's AST (rather than evaluating it), see the Macro module.

This module contains three functions for compiling and evaluating files. Here is a summary of them and their behavior:

require_file/2 - compiles a file and tracks its name. It does not compile the file again if it has been previously required.

compile_file/2 - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times.

eval_file/2 - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section.

In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.

compile_file/2 must be used when you are interested in the modules defined in a file, without tracking. eval_file/2 should be used when you are interested in the result of evaluating the file rather than the modules it defines.

The functions above work with Elixir source. If you want to work with modules compiled to bytecode, which have the .beam extension and are typically found below the _build directory of a Mix project, see the functions in Erlang's :code module.

Erlang has two modes to load code: interactive and embedded.

By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.

You can use ensure_loaded/1 (as well as ensure_loaded?/1 and ensure_loaded!/1) to check if a module is loaded before using it and act.

Elixir also includes ensure_compiled/1 and ensure_compiled!/1 functions that are a superset of ensure_loaded/1.

Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded.

When invoked, ensure_compiled/1 and ensure_compiled!/1 halt the compilation of the caller until the module becomes available. Note that the distinction between ensure_compiled/1 and ensure_compiled!/1 is important: if you are using ensure_compiled!/1, you are indicating to the compiler that you can o

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
case Code.ensure_compiled(module) do
  {:module, _} -> module
  {:error, _} -> raise ...
end
```

Example 2 (python):
```python
defmodule MyTracer do
  def trace({:remote_function, _meta, module, name, arity}, env) do
    IO.puts("#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}")
    :ok
  end

  def trace(_event, _env) do
    :ok
  end
end
```

Example 3 (javascript):
```javascript
Code.append_path(".")
#=> true

Code.append_path("/does_not_exist")
#=> false
```

Example 4 (javascript):
```javascript
Code.append_paths([".", "/does_not_exist"])
#=> :ok
```

---

## Simple state with agents

**URL:** https://hexdocs.pm/elixir/agents.html

**Contents:**
- Simple state with agents
- The trouble with (mutable) state
- Agents 101
- Naming processes
- Other agent actions
- Client/server in agents

In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.

If you have skipped the Getting Started guide or read it long ago, be sure to re-read the Processes chapter. We will use it as a starting point.

Elixir is an immutable language where nothing is shared by default. If we want to share information, this is typically done by sending messages between processes.

When it comes to processes though, we rarely hand-roll our own, instead we use the abstractions available in Elixir and OTP:

Here, we will use agents, and create a module named KV.Bucket, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.

Agents are simple wrappers around state. If all you want from a process is to keep state, agents are a great fit. Let's start a iex session inside the project with:

And play a bit with agents:

We started an agent with an initial state of an empty list. The start_link/1 function returned the :ok tuple with a process identifier (PID) of the agent. We will use this PID for all further interactions. We then updated the agent's state, adding our new item to the head of the list. The second argument of Agent.update/3 is a function that takes the agent's current state as input and returns its desired new state. Finally, we retrieved the whole list. The second argument of Agent.get/3 is a function that takes the state as input and returns the value that Agent.get/3 itself will return. Once we are done with the agent, we can call Agent.stop/3 to terminate the agent process.

The Agent.update/3 function accepts as a second argument any function that receives one argument and returns a value:

As you can see, we can modify the agent state in any way we want. Therefore, we most likely don't want to access the Agent API throughout many different places in our code. Instead, we want to encapsulate all Agent-related functionality in a single module, which we will call KV.Bucket. Before we implement it, let's write some tests which will outline the API exposed by our module.

Create a file at test/kv/bucket_test.exs (remember the .exs extension) with the following:

use ExUnit.Case is responsible for setting up our module for testing and imports many test-related functionality, 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
$ iex -S mix
```

Example 2 (unknown):
```unknown
iex> {:ok, agent} = Agent.start_link(fn -> [] end)
{:ok, #PID<0.57.0>}
iex> Agent.update(agent, fn list -> ["eggs" | list] end)
:ok
iex> Agent.get(agent, fn list -> list end)
["eggs"]
iex> Agent.stop(agent)
:ok
```

Example 3 (unknown):
```unknown
iex> {:ok, agent} = Agent.start_link(fn -> [] end)
{:ok, #PID<0.338.0>}
iex> Agent.update(agent, fn _list -> 123 end)
:ok
iex> Agent.update(agent, fn content -> %{a: content} end)
:ok
iex> Agent.update(agent, fn content -> [12 | [content]] end)
:ok
iex> Agent.update(agent, fn list -> [:nop | list] end)
:ok
iex> Agent.get(agent, fn content -> content end)
[:nop, 12, %{a: 123}]
```

Example 4 (unknown):
```unknown
defmodule KV.BucketTest do
  use ExUnit.Case, async: true

  test "stores values by key" do
    {:ok, bucket} = KV.Bucket.start_link([])
    assert KV.Bucket.get(bucket, "milk") == nil

    KV.Bucket.put(bucket, "milk", 3)
    assert KV.Bucket.get(bucket, "milk") == 3
  end
end
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#2-bug-fixes

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Node (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Node.html#start/2

**Contents:**
- Node (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- state()
- t()
- Functions
- alive?()
- connect(node)

Functions related to VM nodes.

Some of the functions in this module are inlined by the compiler, similar to functions in the Kernel module and they are explicitly marked in their docs as "inlined by the compiler". For more information about inlined functions, check out the Kernel module.

Returns true if the local node is alive.

Establishes a connection to node.

Forces the disconnection of a node.

Returns the magic cookie of the local node.

Returns a list of all visible nodes in the system, excluding the local node.

Returns a list of nodes according to argument given.

Monitors the status of the node.

Behaves as monitor/2 except that it allows an extra option to be given, namely :allow_passive_connect.

Tries to set up a connection to node.

Returns the current node.

Sets the magic cookie of node to the atom cookie.

Returns the PID of a new process started by the application of fun on node. If node does not exist, a useless PID is returned.

Returns the PID of a new process started by the application of fun on node.

Returns the PID of a new process started by the application of module.function(args) on node.

Returns the PID of a new process started by the application of module.function(args) on node.

Returns the PID of a new linked process started by the application of fun on node.

Returns the PID of a new linked process started by the application of module.function(args) on node.

Spawns the given function on a node, monitors it and returns its PID and monitoring reference.

Spawns the given module and function passing the given args on a node, monitors it and returns its PID and monitoring reference.

Turns a non-distributed node into a distributed node.

Turns a distributed node into a non-distributed node.

Returns true if the local node is alive.

That is, if the node can be part of a distributed system.

Establishes a connection to node.

Returns true if successful, false if not, and the atom :ignored if the local node is not alive.

For more information, see :net_kernel.connect_node/1.

Forces the disconnection of a node.

This will appear to the node as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns true if disconnection succeeds, otherwise false. If the local node is not alive, the function returns :ignored.

For more information, see :erlang.disconnect_node/1.

Returns the magic cookie of the local node.

Returns the cookie if the node is alive, otherwise :nocookie.

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Node.ping(:unknown_node)
:pang
```

Example 2 (unknown):
```unknown
{:ok, pid} = Node.start(:example, name_domain: :shortnames, hidden: true)
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#dbg/2-default-debug-function

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction

**URL:** https://hexdocs.pm/elixir/introduction.html#installation

**Contents:**
- Introduction
- Installation
- Interactive mode
- Running scripts

This guide will teach you about Elixir fundamentals - the language syntax, how to define modules, the common data structures in the language, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir's Interactive Shell, called IEx.

If you haven't yet installed Elixir, visit our installation page. Once you are done, you can run elixir --version to get the current Elixir version. The requirements for this guide are:

If you are looking for other resources for learning Elixir, you can also consult the learning page of the official website.

When you install Elixir, you will have three new command line executables: iex, elixir and elixirc.

For now, let's start by running iex (or iex.bat if you are on Windows PowerShell, where iex is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let's warm up with some basic expressions.

Open up iex and type the following expressions:

Please note that some details like version numbers may differ a bit in your session, that's not important. By executing the code above, you should evaluate expressions and see their results. To exit iex press Ctrl+C twice.

It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.

After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:

Save it as simple.exs and execute it with elixir:

iex and elixir are all we need to learn the main language concepts. There is a separate guide named "Mix and OTP guide" that explores how to actually create, manage, and test full-blown Elixir projects. For now, let's move on to learn the basic data types in the language.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
Erlang/OTP 26 [64-bit] [smp:2:2] [...]

Interactive Elixir - press Ctrl+C to exit
iex(1)> 40 + 2
42
iex(2)> "hello" <> " world"
"hello world"
```

Example 2 (unknown):
```unknown
IO.puts("Hello world from Elixir")
```

Example 3 (unknown):
```unknown
$ elixir simple.exs
Hello world from Elixir
```

---

## Elixir v1.19.0 — Documentation

**URL:** https://hexdocs.pm/elixir/

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#=~/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Task (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Task.html

**Contents:**
- Task (Elixir v1.19.0)
- async and await
- Tasks are processes
- Dynamically supervised tasks
  - Distributed tasks
- Statically supervised tasks
    - use Task
- Ancestor and Caller Tracking
- Summary
- Types

Conveniences for spawning and awaiting tasks.

Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously:

Tasks spawned with async can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed.

Compared to plain processes, started with spawn/1, tasks include monitoring metadata and logging in case of errors.

Besides async/1 and await/2, tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. We will explore these scenarios next.

One of the common uses of tasks is to convert sequential code into concurrent code with Task.async/1 while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.

Task.await/2 is used to read the message sent by the task.

There are two important things to consider when using async:

If you are using async tasks, you must await a reply as they are always sent. If you are not expecting a reply, consider using Task.start_link/1 as detailed below.

Async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation. If this is not desired, you will want to use supervised tasks, described in a subsequent section.

Tasks are processes and so data will need to be completely copied to them. Take the following code as an example:

The code above copies over all of large_data, which can be resource intensive depending on the size of the data. There are two ways to address this.

First, if you need to access only part of large_data, consider extracting it before the task:

Alternatively, if you can move the data loading altogether to the task, it may be even better:

The Task.Supervisor module allows developers to dynamically create multiple supervised tasks.

However, in the majority of cases, you want to add the task supervisor to your supervision tree:

And now you can use async/await by passing the name of the sup

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
task = Task.async(fn -> do_some_work() end)
res = do_some_other_work()
res + Task.await(task)
```

Example 2 (unknown):
```unknown
large_data = fetch_large_data()
task = Task.async(fn -> do_some_work(large_data) end)
res = do_some_other_work()
res + Task.await(task)
```

Example 3 (unknown):
```unknown
large_data = fetch_large_data()
subset_data = large_data.some_field
task = Task.async(fn -> do_some_work(subset_data) end)
```

Example 4 (unknown):
```unknown
task = Task.async(fn ->
  large_data = fetch_large_data()
  do_some_work(large_data)
end)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#exit/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Naming conventions

**URL:** https://hexdocs.pm/elixir/naming-conventions.html

**Contents:**
- Naming conventions
- Casing
- Underscore (_foo)
- Trailing bang (foo!)
- Trailing question mark (foo?)
- is_ prefix (is_foo)
- Special names
  - length and size
  - get, fetch, fetch!
  - compare

This document is a reference of the naming conventions in Elixir, from casing to punctuation characters.

The naming convention is, by definition, a subset of the Elixir syntax. A convention aims to follow and set best practices for language and the community. If instead you want a complete reference into the Elixir syntax, beyond its conventions, see the Syntax reference.

Elixir developers must use snake_case when defining variables, function names, module attributes, and the like:

Aliases, commonly used as module names, are an exception as they must be capitalized and written in CamelCase, like OptionParser. For aliases, capital letters are kept in acronyms, like ExUnit.CaptureIO or Mix.SCM.

Atoms can be written either in :snake_case or :CamelCase, although the convention is to use the snake case version throughout Elixir.

Generally speaking, filenames follow the snake_case convention of the module they define. For example, MyApp should be defined inside the my_app.ex file. However, this is only a convention. At the end of the day any filename can be used as they do not affect the compiled code in any way.

Elixir relies on underscores in different situations.

For example, a value that is not meant to be used must be assigned to _ or to a variable starting with underscore:

Function names may also start with an underscore. Such functions are never imported by default:

Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the __foo__ format. For example, every module in Elixir has an __info__/1 function:

Elixir also includes five special forms that follow the double underscore format: __CALLER__/0, __DIR__/0, __ENV__/0and __MODULE__/0 retrieve compile-time information about the current environment, while __STACKTRACE__/0 retrieves the stacktrace for the current exception.

A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception. They most often exist as a "raising variant" of a function that returns :ok/:error tuples (or nil).

One example is File.read/1 and File.read!/1. File.read/1 will return a success or failure tuple, whereas File.read!/1 will return a plain value or else raise an exception:

The version without ! is preferred when you want to handle different outcomes using pattern matching:

However, if you expect the outcome to always be successful (for instance, if you expect the file always to ex

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
some_map = %{this_is_a_key: "and a value"}
is_map(some_map)
```

Example 2 (unknown):
```unknown
iex> {:ok, _contents} = File.read("README.md")
```

Example 3 (python):
```python
iex> defmodule Example do
...>   def _wont_be_imported do
...>     :oops
...>   end
...> end

iex> import Example
iex> _wont_be_imported()
** (CompileError) iex:1: undefined function _wont_be_imported/0
```

Example 4 (unknown):
```unknown
iex> String.__info__(:functions)
[at: 2, capitalize: 1, chunk: 2, ...]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#-/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_W/2-modifiers

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#floor/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## String (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/String.html

**Contents:**
- String (Elixir v1.19.0)
- Interpolation
- Escape characters
- Unicode and code points
- UTF-8 encoded and encodings
- Grapheme clusters
- String and binary operations
- Self-synchronization
- Compile binary patterns
- Summary

Strings in Elixir are UTF-8 encoded binaries.

Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as "hello" and "héllò".

In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: "this is a string with \"double quotes\"".

You can concatenate two strings with the <>/2 operator:

The functions in this module act according to The Unicode Standard, Version 17.0.0.

Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the #{} syntax:

Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation:

In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised.

Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:

Note it is generally not advised to use \xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \uNNNN. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.

In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.

Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point.

In Elixir you can use a ? in front of a character literal to reveal its code point:

Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. 97 translates to 0061 in hex, and we can represent any Unicode character in an Elixir string by 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> "hello" <> " " <> "world"
"hello world"
```

Example 2 (unknown):
```unknown
iex> name = "joe"
iex> "hello #{name}"
"hello joe"
```

Example 3 (unknown):
```unknown
iex> "2 + 2 = #{2 + 2}"
"2 + 2 = 4"
```

Example 4 (unknown):
```unknown
iex> ?a
97
iex> ?ł
322
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#not/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#byte_size/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Task.Supervisor (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Task.Supervisor.html

**Contents:**
- Task.Supervisor (Elixir v1.19.0)
- Scalability and partitioning
- Name registration
- Summary
- Types
- Functions
- Types
- async_opts()
- async_stream_option()
- option()

This module defines a supervisor which can be used to dynamically supervise tasks.

A task supervisor is started with no children, often under a supervisor and a name:

The options given in the child specification are documented in start_link/1.

Once started, you can start tasks directly under the supervisor, for example:

See the Task module for more examples.

The Task.Supervisor is a single process responsible for starting other processes. In some applications, the Task.Supervisor may become a bottleneck. To address this, you can start multiple instances of the Task.Supervisor and then pick a random instance to start the task on.

In the code above, we start a partition supervisor that will by default start a dynamic supervisor for each core in your machine. Then, instead of calling the Task.Supervisor by name, you call it through the partition supervisor using the {:via, PartitionSupervisor, {name, key}} format, where name is the name of the partition supervisor and key is the routing key. We picked self() as the routing key, which means each process will be assigned one of the existing task supervisors. Read the PartitionSupervisor docs for more information.

A Task.Supervisor is bound to the same name registration rules as a GenServer. Read more about them in the GenServer docs.

Options for async/3, async/5, async_nolink/3, and async_nolink/5 functions.

Options given to async_stream and async_stream_nolink functions.

Option values used by start_link

Starts a task that can be awaited on.

Starts a task that can be awaited on.

Starts a task that can be awaited on.

Starts a task that can be awaited on.

Returns a stream that runs the given function fun concurrently on each element in enumerable.

Returns a stream where the given function (module and function) is mapped concurrently on each element in enumerable.

Returns a stream that runs the given function concurrently on each element in enumerable.

Returns a stream where the given function (module and function) is mapped concurrently on each element in enumerable.

Returns all children PIDs except those that are restarting.

Starts a task as a child of the given supervisor.

Starts a task as a child of the given supervisor.

Starts a new supervisor.

Terminates the child with the given pid.

Options for async/3, async/5, async_nolink/3, and async_nolink/5 functions.

Options given to async_stream and async_stream_nolink functions.

Option values used by start_link

Starts a task that can be a

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
children = [
  {Task.Supervisor, name: MyApp.TaskSupervisor}
]

Supervisor.start_link(children, strategy: :one_for_one)
```

Example 2 (unknown):
```unknown
task = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->
  :do_some_work
end)
```

Example 3 (unknown):
```unknown
children = [
  {Task.Supervisor, name: MyApp.TaskSupervisor}
]
```

Example 4 (unknown):
```unknown
Task.Supervisor.async(MyApp.TaskSupervisor, fn -> :do_some_work end)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_exception/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#..///3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Process (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Process.html#send_after/4

**Contents:**
- Process (Elixir v1.19.0)
- Aliases
- Summary
- Types
- Functions
- Types
- alias()
- alias_opt()
- dest()
- process_info_item()

Conveniences for working with processes and the process dictionary.

Besides the functions available in this module, the Kernel module exposes and auto-imports some basic functionality related to processes available through the following functions:

While this module provides low-level conveniences to work with processes, developers typically use abstractions such as Agent, GenServer, Registry, Supervisor and Task for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.

Aliases are a feature introduced in Erlang/OTP 24. An alias is a way to refer to a PID in order to send messages to it. The advantage of using aliases is that they can be deactivated even if the aliased process is still running. If you send a message to a deactivated alias, nothing will happen. This makes request/response scenarios easier to implement.

You can use alias/0 or alias/1 to set an alias, and then you can send messages to that alias like you do with PIDs using send/2. To deactivate an alias, you can use unalias/1. If you send a message to a deactivated alias, nothing will happen.

For example, you could have a process that listens for :ping messages:

Now, another process might ping this process:

If now you deactivate the source_alias and ping the server again, you won't receive any response since the server will send/2 the :pong response to a deactivated alias.

See also the Process Aliases section of the Erlang reference manual.

An alias returned by alias/0 or alias/1.

A process destination.

Creates a process alias.

Creates a process alias.

Tells whether the given process is alive on the local node.

Cancels a timer returned by send_after/3.

Deletes the given key from the process dictionary.

Demonitors the monitor identified by the given reference.

Sends an exit signal with the given reason to pid.

Sets the given flag to value for the calling process.

Sets the given flag to value for the given process pid.

Returns all key-value pairs in the process dictionary.

Returns the value for the given key in the process dictionary, or default if key is not set.

Returns all keys in the process dictionary.

Returns all keys in the process dictionary that have the given value.

Returns the PID of the group leader for the calling process.

Sets the group leader of the given pid to leader.

Puts the calling process into a "hibernation" state.

Returns information about the process identified by pid, or returns nil if

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def server do
  receive do
    {:ping, source_alias} ->
      send(source_alias, :pong)
      server()
  end
end
```

Example 2 (javascript):
```javascript
server = spawn(&server/0)

source_alias = Process.alias()
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
end
#=> :pong
```

Example 3 (javascript):
```javascript
Process.unalias(source_alias)
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
after
  1000 -> :timeout
end
#=> :timeout
```

Example 4 (unknown):
```unknown
alias = Process.alias()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#use/2-best-practices

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Atom (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Atom.html#to_string/1

**Contents:**
- Atom (Elixir v1.19.0)
- Summary
- Functions
- Functions
- to_charlist(atom)
- Examples
- to_string(atom)
- Examples

Atoms are constants whose values are their own name.

They are often useful to enumerate over distinct values, such as:

Atoms are equal if their names are equal.

Often they are used to express the state of an operation, by using values such as :ok and :error.

The booleans true and false are also atoms:

Elixir allows you to skip the leading : for the atoms false, true, and nil.

Atoms must be composed of Unicode characters such as letters, numbers, underscore, and @. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:

Converts an atom to a charlist.

Converts an atom to a string.

Converts an atom to a charlist.

Inlined by the compiler.

Converts an atom to a string.

Inlined by the compiler.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> :apple
:apple
iex> :orange
:orange
iex> :watermelon
:watermelon
```

Example 2 (unknown):
```unknown
iex> :apple == :apple
true
iex> :apple == :orange
false
```

Example 3 (unknown):
```unknown
iex> true == :true
true
iex> is_atom(false)
true
iex> is_boolean(:false)
true
```

Example 4 (unknown):
```unknown
iex> :"this is an atom with spaces"
:"this is an atom with spaces"
```

---

## List.Chars protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/List.Chars.html

**Contents:**
- List.Chars protocol (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- t()
- Functions
- to_charlist(term)

The List.Chars protocol is responsible for converting a structure to a charlist (only if applicable).

The only function that must be implemented is to_charlist/1 which does the conversion.

The to_charlist/1 function automatically imported by Kernel invokes this protocol.

All the types that implement this protocol.

Converts term to a charlist.

All the types that implement this protocol.

Converts term to a charlist.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#!=/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#**/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#//2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html#running-tests

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmodule/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defexception/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#struct!/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Stream (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Stream.html

**Contents:**
- Stream (Elixir v1.19.0)
- Creating Streams
    - Do not check for Stream structs
- Summary
- Types
- Functions
- Types
- acc()
- default()
- element()

Functions for creating and composing streams.

Streams are composable, lazy enumerables (for an introduction on enumerables, see the Enum module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's Range is a stream:

In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The Stream module allows us to map the range, without triggering its enumeration:

Note that we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when Enum.map/2 is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in Stream are lazy and the functions in Enum are eager.

Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with Enum, intermediate lists are created, while Stream creates a recipe of computations that are executed at a later moment. Then when the stream is consumed later on, most commonly by using a function in the Enum module, the stream will emit its elements one by one.

Let's see another example:

Note that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:

Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!

That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call Stream.map/2 multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the Enum module.

Like with Enum, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as Stream.map/2. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.

There are many functions in Elixir's standard library that return streams, some examples are:

This module also provides many convenience fu

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> range = 1..5
1..5
iex> Enum.map(range, &(&1 * 2))
[2, 4, 6, 8, 10]
```

Example 2 (unknown):
```unknown
iex> range = 1..3
iex> stream = Stream.map(range, &(&1 * 2))
iex> Enum.map(stream, &(&1 + 1))
[3, 5, 7]
```

Example 3 (javascript):
```javascript
1..3
|> Enum.map(&IO.inspect(&1))
|> Enum.map(&(&1 * 2))
|> Enum.map(&IO.inspect(&1))
1
2
3
2
4
6
#=> [2, 4, 6]
```

Example 4 (javascript):
```javascript
stream = 1..3
|> Stream.map(&IO.inspect(&1))
|> Stream.map(&(&1 * 2))
|> Stream.map(&IO.inspect(&1))
Enum.to_list(stream)
1
2
2
4
3
6
#=> [2, 4, 6]
```

---

## Enum (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enum.html#member?/2

**Contents:**
- Enum (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- acc()
- default()
- element()
- index()
- t()

Functions for working with collections (known as enumerables).

In Elixir, an enumerable is any data type that implements the Enumerable protocol. Lists ([1, 2, 3]), Maps (%{foo: 1, bar: 2}) and Ranges (1..3) are common data types used as enumerables:

Many other enumerables exist in the language, such as MapSets and the data type returned by File.stream!/3 which allows a file to be traversed as if it was an enumerable.

For a general overview of all functions in the Enum module, see the Enum cheatsheet.

The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as Enum.map/2. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.

This linear behavior should also be expected on operations like count/1, member?/2, at/2 and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the Enum module is meant to work with a large variety of data types and not all data types can provide optimized behavior.

Finally, note the functions in the Enum module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the Stream module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the Stream module for examples and documentation.

Zero-based index. It can also be a negative integer.

Returns true if all elements in enumerable are truthy.

Returns true if fun.(element) is truthy for all elements in enumerable.

Returns true if at least one element in enumerable is truthy.

Returns true if fun.(element) is truthy for at least one element in enumerable.

Finds the element at the given index (zero-based).

Splits enumerable on every element for which fun returns a new value.

Shortcut to chunk_every(enumerable, count, count).

Returns list of lists containing count elements each, where each new chunk starts step elements into the enumerable.

Chunks the enumerable with fine grained control when every chunk is emitted.

Given an enumerable of enumerables, concatenates the enumerables into a single list.

Concatenates the enumerable on the right with the 

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> Enum.map([1, 2, 3], fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum([1, 2, 3])
6

iex> Enum.map(1..3, fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum(1..3)
6

iex> map = %{"a" => 1, "b" => 2}
iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)
[{"a", 2}, {"b", 4}]
```

Example 2 (unknown):
```unknown
iex> Enum.all?([1, 2, 3])
true

iex> Enum.all?([1, nil, 3])
false

iex> Enum.all?([])
true
```

Example 3 (unknown):
```unknown
iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)
true

iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)
false

iex> Enum.all?([], fn _ -> nil end)
true
```

Example 4 (unknown):
```unknown
iex> Enum.any?([false, false, false])
false

iex> Enum.any?([false, true, false])
true

iex> Enum.any?([])
false
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#reraise/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binary_part/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## RuntimeError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/RuntimeError.html

**Contents:**
- RuntimeError exception (Elixir v1.19.0)
- Fields

An exception for a generic runtime error.

This is the exception that raise/1 raises when you pass it only a string as a message:

You should use this exceptions sparingly, since most of the time it might be better to define your own exceptions specific to your application or library. Sometimes, however, there are situations in which you don't expect a condition to happen, but you want to give a meaningful error message if it does. In those cases, RuntimeError can be a good choice.

RuntimeError exceptions have a single field, :message (a String.t/0), which is public and can be accessed freely when reading or creating RuntimeError exceptions.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> raise "oops!"
** (RuntimeError) oops!
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#+/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_r/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmodule/2-reserved-module-names

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binary_slice/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defexception/1-raising-exceptions

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#match?/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#hd/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#--/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#reraise/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defoverridable/1-example-with-behaviour

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#and/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#exit/1-cli-exits

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_map_key/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-built-in-types

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_non_struct_map/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3E=/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## File (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/File.html#mkdir_p/1

**Contents:**
- File (Elixir v1.19.0)
- Encoding
- API
- Processes and raw files
- Seeking within a file
- Summary
- Types
- Functions
- Types
- encoding_mode()

This module contains functions to manipulate files.

Some of those functions are low-level, allowing the user to interact with files or IO devices, like open/2, copy/3 and others. This module also provides higher level functions that work with filenames and have their naming based on Unix variants. For example, one can copy a file via cp/3 and remove files and directories recursively via rm_rf/1.

Paths given to functions in this module can be either relative to the current working directory (as returned by File.cwd/0), or absolute paths. Shell conventions like ~ are not expanded automatically. To use paths like ~/Downloads, you can use Path.expand/1 or Path.expand/2 to expand your path to an absolute path.

In order to write and read files, one must use the functions in the IO module. By default, a file is opened in binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file, then the slower IO.read/2 and IO.write/2 functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.

Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.

Most of the functions in this module return :ok or {:ok, result} in case of success, {:error, reason} otherwise. Those functions also have a variant that ends with ! which returns the result (instead of the {:ok, result} tuple) in case of success or raises an exception in case it fails. For example:

In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).

Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.

This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.

However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in :raw mode. The options :read_ahead and :delayed_write are also useful when operating on large files or working with files in tight loo

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
File.read("hello.txt")
#=> {:ok, "World"}

File.read("invalid.txt")
#=> {:error, :enoent}

File.read!("hello.txt")
#=> "World"

File.read!("invalid.txt")
#=> raises File.Error
```

Example 2 (javascript):
```javascript
File.write!("example.txt", "Eats, Shoots & Leaves")
file = File.open!("example.txt")
:file.pread(file, 15, 6)
#=> {:ok, "Leaves"}
```

Example 3 (javascript):
```javascript
:file.position(file, 6)
#=> {:ok, 6}
:file.read(file, 6)
#=> {:ok, "Shoots"}
:file.position(file, {:cur, -12})
#=> {:ok, 0}
:file.read(file, 4)
#=> {:ok, "Eats"}
```

Example 4 (javascript):
```javascript
File.cd("bin")
#=> :ok

File.cd("non_existing_dir")
#=> {:error, :enoent}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#round/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_boolean/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Exception behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Exception.html#c:exception/1

**Contents:**
- Exception behaviour (Elixir v1.19.0)
- Formatting functions
- Summary
- Types
- Callbacks
- Functions
- Types
- arity_or_args()
- kind()
- location()

Functions for dealing with throw/catch/exit and exceptions.

This module also defines the behaviour required by custom exceptions. To define your own, see defexception/1.

Several functions in this module help format exceptions. Some of these functions expect the stacktrace as argument. The stacktrace is typically available inside catch and rescue by using the __STACKTRACE__/0 variable.

Do not rely on the particular format returned by the functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.

The kind handled by formatting functions

Called from Exception.blame/3 to augment the exception struct.

Receives the arguments given to raise/2 and returns the exception struct.

Receives the exception struct and must return its message.

Attaches information to throws/errors/exits for extra debugging.

Blames the invocation of the given module, function and arguments.

Normalizes and formats throws/errors/exits and stacktraces.

Normalizes and formats any throw/error/exit.

Formats an exit. It returns a string.

Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.

Formats the given file and line as shown in stacktraces.

Formats the given file, line, and column as shown in stacktraces.

Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.

Formats the stacktrace.

Receives a stacktrace entry and formats it into a string.

Gets the message for an exception.

Normalizes an exception, converting Erlang exceptions to Elixir exceptions.

The kind handled by formatting functions

Called from Exception.blame/3 to augment the exception struct.

Can be used to collect additional information about the exception or do some additional expensive computation.

Receives the arguments given to raise/2 and returns the exception struct.

The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message.

Receives the exception struct and must return its message.

Many exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented.

Attaches information to t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
Exception.format_fa(fn -> nil end, 1)
#=> "#Function<...>/1"
```

Example 2 (unknown):
```unknown
iex> Exception.format_file_line("foo", 1)
"foo:1:"

iex> Exception.format_file_line("foo", nil)
"foo:"

iex> Exception.format_file_line(nil, nil)
""
```

Example 3 (unknown):
```unknown
iex> Exception.format_file_line_column("foo", 1, 2)
"foo:1:2:"

iex> Exception.format_file_line_column("foo", 1, nil)
"foo:1:"

iex> Exception.format_file_line_column("foo", nil, nil)
"foo:"

iex> Exception.format_file_line_column("foo", nil, 2)
"foo:"

iex> Exception.format_file_line_column(nil, nil, nil)
""
```

Example 4 (unknown):
```unknown
iex> Exception.format_mfa(Foo, :bar, 1)
"Foo.bar/1"

iex> Exception.format_mfa(Foo, :bar, [])
"Foo.bar()"

iex> Exception.format_mfa(nil, :bar, [])
"nil.bar()"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#!==/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Stream (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Stream.html#transform/5

**Contents:**
- Stream (Elixir v1.19.0)
- Creating Streams
    - Do not check for Stream structs
- Summary
- Types
- Functions
- Types
- acc()
- default()
- element()

Functions for creating and composing streams.

Streams are composable, lazy enumerables (for an introduction on enumerables, see the Enum module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's Range is a stream:

In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The Stream module allows us to map the range, without triggering its enumeration:

Note that we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when Enum.map/2 is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in Stream are lazy and the functions in Enum are eager.

Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with Enum, intermediate lists are created, while Stream creates a recipe of computations that are executed at a later moment. Then when the stream is consumed later on, most commonly by using a function in the Enum module, the stream will emit its elements one by one.

Let's see another example:

Note that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:

Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!

That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call Stream.map/2 multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the Enum module.

Like with Enum, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as Stream.map/2. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.

There are many functions in Elixir's standard library that return streams, some examples are:

This module also provides many convenience fu

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> range = 1..5
1..5
iex> Enum.map(range, &(&1 * 2))
[2, 4, 6, 8, 10]
```

Example 2 (unknown):
```unknown
iex> range = 1..3
iex> stream = Stream.map(range, &(&1 * 2))
iex> Enum.map(stream, &(&1 + 1))
[3, 5, 7]
```

Example 3 (javascript):
```javascript
1..3
|> Enum.map(&IO.inspect(&1))
|> Enum.map(&(&1 * 2))
|> Enum.map(&IO.inspect(&1))
1
2
3
2
4
6
#=> [2, 4, 6]
```

Example 4 (javascript):
```javascript
stream = 1..3
|> Stream.map(&IO.inspect(&1))
|> Stream.map(&(&1 * 2))
|> Stream.map(&IO.inspect(&1))
Enum.to_list(stream)
1
2
2
4
3
6
#=> [2, 4, 6]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_in/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Keyword (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Keyword.html

**Contents:**
- Keyword (Elixir v1.19.0)
- Examples
- Duplicate keys and ordering
- Call syntax
- Summary
- Types
- Functions
- Types
- default()
- key()

A keyword list is a list that consists exclusively of two-element tuples.

The first element of these tuples is known as the key, and it must be an atom. The second element, known as the value, can be any term.

Keywords are mostly used to work with optional values. For a general introduction to keywords and how they compare with maps, see our Keyword and Maps guide.

For example, the following is a keyword list:

Elixir provides a special and more concise syntax for keyword lists:

The two syntaxes return the exact same value.

A key can be any atom, consisting of Unicode letters, numbers, an underscore or the @ sign. If the key should have any other characters, such as spaces, you can wrap it in quotes:

Wrapping an atom in quotes does not make it a string. Keyword list keys are always atoms. Quotes should only be used when necessary or Elixir will issue a warning.

A keyword may have duplicate keys so it is not strictly a key-value data type. However, most of the functions in this module work on a key-value structure and behave similar to the functions you would find in the Map module. For example, Keyword.get/3 will get the first entry matching the given key, regardless if duplicate entries exist. Similarly, Keyword.put/3 and Keyword.delete/2 ensure all duplicate entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts.

A handful of functions exist to handle duplicate keys, for example, get_values/2 returns all values for a given key and delete_first/2 deletes just the first entry of the existing ones.

Even though lists preserve the existing order, the functions in Keyword do not guarantee any ordering. For example, if you invoke Keyword.put(opts, new_key, new_value), there is no guarantee for where new_key will be added to (the front, the end or anywhere else).

Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:

Most of the functions in this module work in linear time. This means that the time it takes to perform an operation grows at the same rate as the length of the list.

When keyword lists are passed as the last argument to a function, the square brackets around the keyword list can be omitted. For example, the keyword list syntax:

can be written without the enclosing brackets whenever it is the last argument of a f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
[{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]
```

Example 2 (unknown):
```unknown
[exit_on_close: true, active: :once, packet_size: 1024]
```

Example 3 (unknown):
```unknown
iex> ["exit on close": true]
["exit on close": true]
```

Example 4 (python):
```python
def my_function([some_key: value, another_key: another_value])
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3C/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#in/2-ast-considerations

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Enum (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enum.html

**Contents:**
- Enum (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- acc()
- default()
- element()
- index()
- t()

Functions for working with collections (known as enumerables).

In Elixir, an enumerable is any data type that implements the Enumerable protocol. Lists ([1, 2, 3]), Maps (%{foo: 1, bar: 2}) and Ranges (1..3) are common data types used as enumerables:

Many other enumerables exist in the language, such as MapSets and the data type returned by File.stream!/3 which allows a file to be traversed as if it was an enumerable.

For a general overview of all functions in the Enum module, see the Enum cheatsheet.

The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as Enum.map/2. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.

This linear behavior should also be expected on operations like count/1, member?/2, at/2 and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the Enum module is meant to work with a large variety of data types and not all data types can provide optimized behavior.

Finally, note the functions in the Enum module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the Stream module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the Stream module for examples and documentation.

Zero-based index. It can also be a negative integer.

Returns true if all elements in enumerable are truthy.

Returns true if fun.(element) is truthy for all elements in enumerable.

Returns true if at least one element in enumerable is truthy.

Returns true if fun.(element) is truthy for at least one element in enumerable.

Finds the element at the given index (zero-based).

Splits enumerable on every element for which fun returns a new value.

Shortcut to chunk_every(enumerable, count, count).

Returns list of lists containing count elements each, where each new chunk starts step elements into the enumerable.

Chunks the enumerable with fine grained control when every chunk is emitted.

Given an enumerable of enumerables, concatenates the enumerables into a single list.

Concatenates the enumerable on the right with the 

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> Enum.map([1, 2, 3], fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum([1, 2, 3])
6

iex> Enum.map(1..3, fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum(1..3)
6

iex> map = %{"a" => 1, "b" => 2}
iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)
[{"a", 2}, {"b", 4}]
```

Example 2 (unknown):
```unknown
iex> Enum.all?([1, 2, 3])
true

iex> Enum.all?([1, nil, 3])
false

iex> Enum.all?([])
true
```

Example 3 (unknown):
```unknown
iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)
true

iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)
false

iex> Enum.all?([], fn _ -> nil end)
true
```

Example 4 (unknown):
```unknown
iex> Enum.any?([false, false, false])
false

iex> Enum.any?([false, true, false])
true

iex> Enum.any?([])
false
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#pop_in/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Atom (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Atom.html

**Contents:**
- Atom (Elixir v1.19.0)
- Summary
- Functions
- Functions
- to_charlist(atom)
- Examples
- to_string(atom)
- Examples

Atoms are constants whose values are their own name.

They are often useful to enumerate over distinct values, such as:

Atoms are equal if their names are equal.

Often they are used to express the state of an operation, by using values such as :ok and :error.

The booleans true and false are also atoms:

Elixir allows you to skip the leading : for the atoms false, true, and nil.

Atoms must be composed of Unicode characters such as letters, numbers, underscore, and @. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:

Converts an atom to a charlist.

Converts an atom to a string.

Converts an atom to a charlist.

Inlined by the compiler.

Converts an atom to a string.

Inlined by the compiler.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> :apple
:apple
iex> :orange
:orange
iex> :watermelon
:watermelon
```

Example 2 (unknown):
```unknown
iex> :apple == :apple
true
iex> :apple == :orange
false
```

Example 3 (unknown):
```unknown
iex> true == :true
true
iex> is_atom(false)
true
iex> is_boolean(:false)
true
```

Example 4 (unknown):
```unknown
iex> :"this is an atom with spaces"
:"this is an atom with spaces"
```

---

## Syntax reference

**URL:** https://hexdocs.pm/elixir/syntax-reference.html

**Contents:**
- Syntax reference
- Reserved words
- Data types
  - Numbers
  - Atoms
  - Strings
  - Charlists
  - Lists, tuples and binaries
  - Maps and keyword lists
  - Structs

Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of "syntax sugar" constructs to reduce the noise in common Elixir idioms.

This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.

These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:

Integers (1234) and floats (123.4) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as 1_000_000. Integers never contain a dot (.) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as 123.4e10 or 123.4E10.

Unquoted atoms start with a colon (:) which must be immediately followed by a Unicode letter or an underscore. The atom may continue using a sequence of Unicode letters, numbers, underscores, and @. Atoms may end in ! or ?. Valid unquoted atoms are: :ok, :ISO8601, and :integer?.

If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as :'🌢 Elixir', :"++olá++", and :"123".

Quoted and unquoted atoms with the same name are considered equivalent, so :atom, :"atom", and :'atom' represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.

All operators in Elixir are also valid atoms. Valid examples are :foo, :FOO, :foo_42, :foo@bar, and :++. Invalid examples are :@foo (@ is not allowed at start), :123 (numbers are not allowed at start), and :(*) (not a valid operator).

true, false, and nil are reserved words that are represented by the atoms :true, :false and :nil respectively.

To learn more about all Unicode characters allowed in atom, see the Unicode syntax document.

Single-line strings in Elixir are written between double-quotes, such as "foo". Any double-quote inside the string must be escaped with \. Strings support Unicode characters and are stored as UTF-8 encoded binaries.

Multi-line strings in Elixir are called heredocs. They are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentatio

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> test = """
...>     this
...>     is
...>     a
...>     test
...> """
"    this\n    is\n    a\n    test\n"
iex> test = """
...>     This
...>     Is
...>     A
...>     Test
...>     """
"This\nIs\nA\nTest\n"
```

Example 2 (unknown):
```unknown
iex(6)> 'abc' === [97, 98, 99]
true
```

Example 3 (unknown):
```unknown
case 1 do
  2 -> 3
  4 -> 5
end

cond do
  true -> false
end
```

Example 4 (unknown):
```unknown
(integer(), boolean() -> integer())
```

---

## Inspect.Opts (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Inspect.Opts.html

**Contents:**
- Inspect.Opts (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- color_key()
- new_opt()
- t()
- Functions
- default_inspect_fun()

Defines the options used by the Inspect protocol.

The following fields are available:

:base - prints integers and binaries as :binary, :octal, :decimal, or :hex. Defaults to :decimal.

:binaries - when :as_binaries all binaries will be printed in bit syntax.

When :as_strings all binaries will be printed as strings, non-printable bytes will be escaped.

When the default :infer, the binary will be printed as a string if :base is :decimal and if it is printable, otherwise in bit syntax. See String.printable?/1 to learn when a string is printable.

:charlists - when :as_charlists all lists will be printed as charlists, non-printable elements will be escaped.

When :as_lists all lists will be printed as lists.

When the default :infer, the list will be printed as a charlist if it is printable, otherwise as list. See List.ascii_printable?/1 to learn when a charlist is printable.

:custom_options (since v1.9.0) - a keyword list storing custom user-defined options. Useful when implementing the Inspect protocol for nested structs to pass the custom options through.

It supports some pre-defined keys:

:inspect_fun (since v1.9.0) - a function to build algebra documents. Defaults to Inspect.Opts.default_inspect_fun/0.

:limit - limits the number of items that are inspected for tuples, bitstrings, maps, lists and any other collection of items, with the exception of printable strings and printable charlists which use the :printable_limit option. It accepts a positive integer or :infinity. It defaults to 100 since Elixir v1.19.0, as it has better defaults to deal with nested collections.

:pretty - if set to true enables pretty printing. Defaults to false.

:printable_limit - limits the number of characters that are inspected on printable strings and printable charlists. You can use String.printable?/1 and List.ascii_printable?/1 to check if a given string or charlist is printable. If you don't want to limit the number of characters to a particular number, use :infinity. It accepts a positive integer or :infinity. Defaults to 4096.

:safe - when false, failures while inspecting structs will be raised as errors instead of being wrapped in the Inspect.Error exception. This is useful when debugging failures and crashes for custom inspect implementations. Defaults to true.

:structs - when false, structs are not formatted by the inspect protocol, they are instead printed as maps. Defaults to true.

:syntax_colors - when set to a keyword list of colors the output is color

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
previous_fun = Inspect.Opts.default_inspect_fun()

Inspect.Opts.default_inspect_fun(fn
  %{address: _} = map, opts ->
    previous_fun.(%{map | address: "[REDACTED]"}, opts)

  value, opts ->
    previous_fun.(value, opts)
end)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_U/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Tuple (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Tuple.html

**Contents:**
- Tuple (Elixir v1.19.0)
- Summary
- Functions
- Functions
- delete_at(tuple, index)
- Examples
- duplicate(data, size)
- Examples
- insert_at(tuple, index, value)
- Examples

Functions for working with tuples.

Please note the following functions for tuples are found in Kernel:

Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. Enum functions do not work on tuples.

Tuples are denoted with curly braces:

A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals.

Tuples are typically used either when a function has multiple return values or for error handling. File.read/1 returns {:ok, contents} if reading the given file is successful, or else {:error, reason} such as when the file does not exist.

The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple:

Removes an element from a tuple.

Inserts an element into a tuple.

Computes a product of tuple elements.

Computes a sum of tuple elements.

Converts a tuple to a list.

Removes an element from a tuple.

Deletes the element at the given index from tuple. Raises an ArgumentError if index is negative or greater than or equal to the length of tuple. Index is zero-based.

Inlined by the compiler.

Creates a tuple of size containing the given data at every position.

Inlined by the compiler.

Inserts an element into a tuple.

Inserts value into tuple at the given index. Raises an ArgumentError if index is negative or greater than the length of tuple. Index is zero-based.

Inlined by the compiler.

Computes a product of tuple elements.

Computes a sum of tuple elements.

Converts a tuple to a list.

Returns a new list with all the tuple elements.

Inlined by the compiler.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> {}
{}
iex> {1, :two, "three"}
{1, :two, "three"}
```

Example 2 (unknown):
```unknown
tuple = {:ok, :example}

# Avoid
result = Tuple.insert_at(tuple, 2, %{})

# Prefer
{:ok, atom} = tuple
result = {:ok, atom, %{}}
```

Example 3 (unknown):
```unknown
iex> tuple = {:foo, :bar, :baz}
iex> Tuple.delete_at(tuple, 0)
{:bar, :baz}
```

Example 4 (unknown):
```unknown
iex> Tuple.duplicate(:hello, 3)
{:hello, :hello, :hello}
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#v1-18

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#!=/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defimpl/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#&&/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defp/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defdelegate/2-options

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## URI (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/URI.html

**Contents:**
- URI (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- authority()
- t()
- Functions
- %URI{}
- append_path(uri, path)

Utilities for working with URIs.

This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to RFC 3986.

Additionally, the Erlang :uri_string module provides certain functionalities, such as RFC 3986 compliant URI normalization.

Appends path to the given uri.

Appends query to the given uri.

Checks if character is a reserved one in a URI.

Checks if character is allowed unescaped in a URI.

Checks if character is an unreserved one in a URI.

Percent-unescapes a URI.

Decodes query into a map.

Decodes string as "x-www-form-urlencoded".

Returns the default port for a given scheme.

Registers the default port for the given scheme.

Percent-encodes all characters that require escaping in string.

Encodes enumerable into a query string using encoding.

Encodes string as "x-www-form-urlencoded".

Creates a new URI struct from a URI or a string.

Similar to new/1 but raises URI.Error if an invalid string is given.

Parses a URI into its components, without further validation.

Returns a stream of two-element tuples representing key-value pairs in the given query.

Returns the string representation of the given URI struct.

The fields are defined to match the following URI representation (with field names between brackets):

Note the authority field is deprecated. parse/1 will still populate it for backwards compatibility but you should generally avoid setting or getting it.

Appends path to the given uri.

Path must start with / and cannot contain additional URL components like fragments or query strings. This function further assumes the path is valid and it does not contain a query string or fragment parts.

Appends query to the given uri.

The given query is not automatically encoded, use encode/2 or encode_www_form/1.

Checks if character is a reserved one in a URI.

As specified in RFC 3986, section 2.2, the following characters are reserved: :, /, ?, #, [, ], @, !, $, &, ', (, ), *, +, ,, ;, =

Checks if character is allowed unescaped in a URI.

This is the default used by URI.encode/2 where both reserved and unreserved characters are kept unescaped.

Checks if character is an unreserved one in a URI.

As specified in RFC 3986, section 2.3, the following characters are unreserved:

Percent-unescapes a URI.

Decodes query into a map.

Given a query string in the form of key1=value1&key2=value2..., this function inserts each key-value pair in the quer

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
[scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]
```

Example 2 (unknown):
```unknown
iex> URI.append_path(URI.parse("http://example.com/foo/?x=1"), "/my-path") |> URI.to_string()
"http://example.com/foo/my-path?x=1"

iex> URI.append_path(URI.parse("http://example.com"), "my-path")
** (ArgumentError) path must start with "/", got: "my-path"
```

Example 3 (unknown):
```unknown
iex> URI.append_query(URI.parse("http://example.com/"), "x=1") |> URI.to_string()
"http://example.com/?x=1"

iex> URI.append_query(URI.parse("http://example.com/?x=1"), "y=2") |> URI.to_string()
"http://example.com/?x=1&y=2"

iex> URI.append_query(URI.parse("http://example.com/?x=1"), "x=2") |> URI.to_string()
"http://example.com/?x=1&x=2"
```

Example 4 (unknown):
```unknown
iex> URI.char_reserved?(?+)
true
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#not/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_r/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#dbg/2-dbg-inside-iex

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#max/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%7C%7C/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Map (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Map.html#new/1

**Contents:**
- Map (Elixir v1.19.0)
    - Avoid parentheses
- Summary
- Types
- Functions
- Types
- key()
- value()
- Functions
- delete(map, key)

Maps are the "go to" key-value data structure in Elixir.

Maps can be created with the %{} syntax, and key-value pairs can be expressed as key => value:

Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).

Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicate keys. Keys are compared using the exact-equality operator (===/2). If colliding keys are defined in a map literal, the last one prevails.

When the key in a key-value pair is an atom, the key: value shorthand syntax can be used (as in many other special forms):

If you want to mix the shorthand syntax with =>, the shorthand syntax must come at the end:

Keys in maps can be accessed through some of the functions in this module (such as Map.get/3 or Map.fetch/2) or through the map[] syntax provided by the Access module:

To access atom keys, one may also use the map.key notation. Note that map.key will raise a KeyError if the map doesn't contain the key :key, compared to map[:key], that would return nil.

Do not add parentheses when accessing fields, such as in data.key(). If parentheses are used, Elixir will expect data to be an atom representing a module and attempt to call the function key/0 in it.

The two syntaxes for accessing keys reveal the dual nature of maps. The map[key] syntax is used for dynamically created maps that may have any key, of any type. map.key is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via defstruct/1, are one example of such "static maps", where the keys can also be checked during compile time.

Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.

But this will raise a MatchError exception:

Variables can be used as map keys both when writing map literals as well as when matching:

Maps also support a specific update syntax to update the value stored under existing keys. You can update using the atom keys syntax:

When a key that does not exist in the map is updated a KeyError exception will be raised:

The functions in this module that need to find a specific key work in logarithmic time. This me

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> %{}
%{}
iex> %{"one" => :two, 3 => "four"}
%{3 => "four", "one" => :two}
```

Example 2 (unknown):
```unknown
iex> %{a: 1, b: 2}
%{a: 1, b: 2}
```

Example 3 (javascript):
```javascript
iex> %{"hello" => "world", a: 1, b: 2}
%{:a => 1, :b => 2, "hello" => "world"}
```

Example 4 (unknown):
```unknown
iex> map = %{a: 1, b: 2}
iex> Map.fetch(map, :a)
{:ok, 1}
iex> map[:b]
2
iex> map["non_existing_key"]
nil
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#*/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%7C%7C/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#t:container/0

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Duration (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Duration.html#t:t/0

**Contents:**
- Duration (Elixir v1.19.0)
- Shifting
- Intervals
- Comparing durations
- Summary
- Types
- Functions
- Types
- duration()
- t()

Struct and functions for handling durations.

A Duration struct represents a collection of time scale units, allowing for manipulation and calculation of durations.

Date and time scale units are represented as integers, allowing for both positive and negative values.

Microseconds are represented using a tuple {microsecond, precision}. This ensures compatibility with other calendar types implementing time, such as Time, DateTime, and NaiveDateTime.

The most common use of durations in Elixir's standard library is to "shift" the calendar types.

In the example above, Date.shift/2 automatically converts the units into a Duration struct, although one can also be given directly:

It is important to note that shifting is not an arithmetic operation. For example, adding date + 1 month + 1 month does not yield the same result as date + 2 months. Let's see an example:

As you can see above, the results differ, which explains why operations with durations are called "shift" rather than "add". This happens because, once we add one month to 2016-01-31, we get 2016-02-29. Then adding one extra month gives us 2016-03-29 instead of 2016-03-31.

In particular, when applying durations to Calendar.ISO types:

larger units (such as years and months) are applied before smaller ones (such as weeks, hours, days, and so on)

units are collapsed into months (:year and :month), seconds (:week, :day, :hour, :minute, :second) and microseconds (:microsecond) before they are applied

1 year is equivalent to 12 months, 1 week is equivalent to 7 days. Therefore, 4 weeks are not equivalent to 1 month

in case of non-existing dates, the results are rounded down to the nearest valid date

As the shift/2 functions are calendar aware, they are guaranteed to return valid date/times, considering leap years as well as DST in applicable time zones.

Durations in Elixir can be combined with stream operations to build intervals. For example, to retrieve the next three Wednesdays starting from 17th April, 2024:

However, once again, it is important to remember that shifting a duration is not arithmetic, so you may want to use the functions in this module depending on what you to achieve. Compare the results of both examples below:

The second example consistently points to the last day of the month, as it performs operations on the duration, rather than shifting date after date.

In order to accurately compare durations, you need to either compare only certain fields or use a reference time insta

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Date.shift(~D[2016-01-03], month: 2)
~D[2016-03-03]
```

Example 2 (unknown):
```unknown
iex> Date.shift(~D[2016-01-03], Duration.new!(month: 2))
~D[2016-03-03]
```

Example 3 (unknown):
```unknown
iex> ~D[2016-01-31] |> Date.shift(month: 1) |> Date.shift(month: 1)
~D[2016-03-29]

iex> ~D[2016-01-31] |> Date.shift(month: 2)
~D[2016-03-31]
```

Example 4 (unknown):
```unknown
iex> ~D[2024-04-17] |> Stream.iterate(&Date.shift(&1, week: 1)) |> Enum.take(3)
[~D[2024-04-17], ~D[2024-04-24], ~D[2024-05-01]]
```

---

## System (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/System.html

**Contents:**
- System (Elixir v1.19.0)
- Time
- Summary
- Types
- Functions
- Types
- cmd_opts()
- shell_opts()
- signal()
- time_unit()

The System module provides functions that interact directly with the VM or the host system.

The System module also provides functions that work with time, returning different times kept by the system with support for different time units.

One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes "time warps". In order to understand how such changes may be harmful, imagine the following code:

If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via System.monotonic_time/0 which never decreases and does not leap:

Generally speaking, the VM provides three time measurements:

os_time/0 - the time reported by the operating system (OS). This time may be adjusted forwards or backwards in time with no limitation;

system_time/0 - the VM view of the os_time/0. The system time and operating system time may not match in case of time warps although the VM works towards aligning them. This time is not monotonic (i.e., it may decrease) as its behavior is configured by the VM time warp mode;

monotonic_time/0 - a monotonically increasing time provided by the Erlang VM. This is not strictly monotonically increasing. Multiple sequential calls of the function may return the same value.

The time functions in this module work in the :native unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the :native unit, to avoid loss of precision, with convert_time_unit/3 being invoked at the end to convert to a specific time unit like :millisecond or :microsecond. See the time_unit/0 type for more information.

For a more complete rundown on the VM support for different times, see the chapter on time and time correction in the Erlang docs.

The time unit to be passed to functions like monotonic_time/1 and others.

Lists command line arguments.

Modifies command line arguments.

Registers a program exit handler function.

Elixir build information.

Executes the given command with args.

Returns the endianness the system was compiled with.

Converts time from time unit from_unit to time unit to_unit.

Current working directory.

Current working directory, exception on error.

Deletes an environment variable.


*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
## DO NOT DO THIS
prev = System.os_time()
# ... execute some code ...
next = System.os_time()
diff = next - prev
```

Example 2 (unknown):
```unknown
## DO THIS
prev = System.monotonic_time()
# ... execute some code ...
next = System.monotonic_time()
diff = next - prev
```

Example 3 (unknown):
```unknown
iex> System.build_info()
%{
  build: "1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)",
  date: "2018-12-24T01:09:21Z",
  otp_release: "21",
  revision: "772a00a0c",
  version: "1.9.0-dev"
}
```

Example 4 (unknown):
```unknown
iex> System.cmd("echo", ["hello"])
{"hello\n", 0}

iex> System.cmd("echo", ["hello"], env: [{"MIX_ENV", "test"}])
{"hello\n", 0}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binding/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Port (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Port.html

**Contents:**
- Port (Elixir v1.19.0)
- Example
- Message and function APIs
- Open mechanisms
    - Windows argument splitting and untrusted arguments
  - spawn
  - spawn_executable
  - fd
- Orphan operating system processes
- Summary

Functions for interacting with the external world through ports.

Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing.

In the example above, we have created a new port that executes the program cat. cat is a program available on Unix-like operating systems that receives data from multiple inputs and concatenates them in the output.

After the port was created, we sent it two commands in the form of messages using send/2. The first command has the binary payload of "hello" and the second has "world".

After sending those two messages, we invoked the IEx helper flush(), which printed all messages received from the port, in this case we got "hello" and "world" back. Note that the messages are in binary because we passed the :binary option when opening the port in Port.open/2. Without such option, it would have yielded a list of bytes.

Once everything was done, we closed the port.

Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below.

There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module.

The messages supported by ports and their counterpart function APIs are listed below:

{pid, {:command, binary}} - sends the given data to the port. See command/3.

{pid, :close} - closes the port. Unless the port is already closed, the port will reply with {port, :closed} message once it has flushed its buffers and effectively closed. See close/1.

{pid, {:connect, new_pid}} - sets the new_pid as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes new_pid the new connected processes. Unless the port is dead, the port will reply to the old owner with {port, :connected}. See connect/2.

On its turn, the port will send the connected process the following messages:

The port can be opened through four main mechanisms.

As a short summary, prefer to use the :spawn and :spawn_executable options mentioned below. The other two options, :spawn_driver and :fd are for advanced usage within the VM. Also consider using System.cmd/3 if all you want is to execute a program and retrieve its return value.

On Unix systems, arguments are passed to a new operating system process as an array of strings but on 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> port = Port.open({:spawn, "cat"}, [:binary])
iex> send(port, {self(), {:command, "hello"}})
iex> send(port, {self(), {:command, "world"}})
iex> flush()
{#Port<0.1444>, {:data, "hello"}}
{#Port<0.1444>, {:data, "world"}}
iex> send(port, {self(), :close})
:ok
iex> flush()
{#Port<0.1444>, :closed}
:ok
```

Example 2 (unknown):
```unknown
iex> port = Port.open({:spawn, "echo hello"}, [:binary])
iex> flush()
{#Port<0.1444>, {:data, "hello\n"}}
```

Example 3 (unknown):
```unknown
iex> path = System.find_executable("echo")
iex> port = Port.open({:spawn_executable, path}, [:binary, args: ["hello world"]])
iex> flush()
{#Port<0.1380>, {:data, "hello world\n"}}
```

Example 4 (unknown):
```unknown
#!/usr/bin/env bash

# Start the program in the background
exec "$@" &
pid1=$!

# Silence warnings from here on
exec >/dev/null 2>&1

# Read from stdin in the background and
# kill running program when stdin closes
exec 0<&0 $(
  while read; do :; done
  kill -KILL $pid1
) &
pid2=$!

# Clean up
wait $pid1
ret=$?
kill -KILL $pid2
exit $ret
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_struct/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#==/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#abs/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Path (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Path.html

**Contents:**
- Path (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- relative_to_opts()
- t()
- Functions
- absname(path)
- Examples

This module provides conveniences for manipulating or retrieving file system paths.

The functions in this module may receive chardata as arguments and will always return a string encoded in UTF-8. Chardata is a string or a list of characters and strings, see IO.chardata/0. If a binary is given, in whatever encoding, its encoding will be kept.

The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like wildcard/2 and expand/1).

Converts the given path to an absolute one.

Builds a path from relative_to to path.

Returns the last component of the path or the path itself if it does not contain any directory separators.

Returns the last component of path with the extension stripped.

Returns the directory component of path.

Converts the path to an absolute one, expanding any . and .. components and a leading ~.

Expands the path relative to the path given as the second argument expanding any . and .. characters.

Returns the extension of the last component of path.

Joins a list of paths.

Forces the path to be a relative path.

Returns the direct relative path from path in relation to cwd.

Convenience to get the path relative to the current working directory.

Returns the path with the extension stripped.

Returns the path with the extension stripped.

Returns a relative path that is protected from directory-traversal attacks.

Returns a relative path that is protected from directory-traversal attacks.

Splits the path into a list at the path separator.

Returns the path type.

Traverses paths according to the given glob expression and returns a list of matches.

Converts the given path to an absolute one.

Unlike expand/1, no attempt is made to resolve .., ., or ~.

Builds a path from relative_to to path.

If path is already an absolute path, relative_to is ignored. See also relative_to/3. relative_to is either a path or an anonymous function, which is invoked only when necessary, that returns a path.

Unlike expand/2, no attempt is made to resolve .., . or ~.

Returns the last component of the path or the path itself if it does not contain any directory separators.

Returns the last component of path with the extension stripped.

This function should be used to remove a specific extension which may or may not be there.

Returns the directory component of path.

Converts the path to an absolute one, expanding any . and .. components and a leading ~.

If a relative path is provided 

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
Path.absname("foo")
#=> "/usr/local/foo"

Path.absname("../x")
#=> "/usr/local/../x"
```

Example 2 (javascript):
```javascript
Path.absname("foo")
#=> "D:/usr/local/foo"

Path.absname("../x")
#=> "D:/usr/local/../x"
```

Example 3 (unknown):
```unknown
iex> Path.absname("foo", "bar")
"bar/foo"

iex> Path.absname("../x", "bar")
"bar/../x"

iex> Path.absname("foo", fn -> "lazy" end)
"lazy/foo"
```

Example 4 (unknown):
```unknown
iex> Path.basename("foo")
"foo"

iex> Path.basename("foo/bar")
"bar"

iex> Path.basename("lib/module/submodule.ex")
"submodule.ex"

iex> Path.basename("/")
""
```

---

## Unicode syntax

**URL:** https://hexdocs.pm/elixir/unicode-syntax.html

**Contents:**
- Unicode syntax
- Introduction
- Unicode Annex #31
  - R1. Default Identifiers
    - Atoms
    - Variables, local calls, and remote calls
    - Aliases
  - R3. Pattern_White_Space and Pattern_Syntax Characters
  - R4. Equivalent Normalized Identifiers
- Unicode Technical Standard #39

Elixir supports Unicode throughout the language. This document is a complete reference of how Elixir supports Unicode in its syntax.

Strings ("olá") and charlists ('olá') support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.

Elixir also supports Unicode in variables, atoms, and calls since Elixir v1.5. The focus of this document is to provide a high-level introduction to how Elixir allows Unicode in its syntax. We also provide technical documentation describing how Elixir complies with the Unicode specification.

To check the Unicode version of your current Elixir installation, run String.Unicode.version().

Elixir allows Unicode characters in its variables, atoms, and calls. However, the Unicode characters must still obey the rules of the language syntax. In particular, variables and calls cannot start with an uppercase letter. From now on, we will refer to those terms as identifiers.

The characters allowed in identifiers are the ones specified by Unicode. Generally speaking, it is restricted to characters typically used by the writing system of human languages still in activity. In particular, it excludes symbols such as emojis, alternate numeric representations, musical notes, and the like.

Elixir imposes many restrictions on identifiers for security purposes. For example, the word "josé" can be written in two ways in Unicode: as the combination of the characters j o s é and as a combination of the characters j o s e ́, where the accent is its own character. The former is called NFC form and the latter is the NFD form. Elixir normalizes all characters to be the in the NFC form.

Elixir also disallows mixed-scripts which are not explicitly separated by _. For example, it is not possible to name a variable аdmin, where а is in Cyrillic and the remaining characters are in Latin. Doing so will raise the following error:

Finally, Elixir will also warn on confusable identifiers in the same file. For example, Elixir will emit a warning if you use both variables а (Cyrillic) and а (Latin) in your code.

That's the overall introduction of how Unicode is used in Elixir identifiers. In a nutshell, its goal is to support different writing systems in use today while keeping the Elixir language itself clear and secure.

For the technical details, see the next sections that cover the technical Unicode requirements.

Elixir

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
** (SyntaxError) invalid mixed-script identifier found: аdmin

Mixed-script identifiers are not supported for security reasons. 'аdmin' is made of the following scripts:

  \u0430 а {Cyrillic}
  \u0064 d {Latin}
  \u006D m {Latin}
  \u0069 i {Latin}
  \u006E n {Latin}

Make sure all characters in the identifier resolve to a single script or a highly
restrictive script. See https://hexdocs.pm/elixir/unicode-syntax.html for more information.
```

Example 2 (unknown):
```unknown
<Identifier> := <Start> <Continue>* <Ending>?
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defoverridable/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_list/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#match?/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## DateTime (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/DateTime.html#diff/3

**Contents:**
- DateTime (Elixir v1.19.0)
- Time zone database
- Datetimes as snapshots
- Converting between timezones
- Summary
- Types
- Functions
- Types
- t()
- Functions

A datetime implementation with a time zone.

This datetime can be seen as a snapshot of a date and time at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes. Note future datetimes are not necessarily guaranteed to exist, as time zones may change any time in the future due to geopolitical reasons. See the "Datetimes as snapshots" section for more information.

Remember, comparisons in Elixir using ==/2, >/2, </2 and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the compare/2, after?/2 and before?/2 functions. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum datetime of an Enum. For example:

Developers should avoid creating the DateTime struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.

Many functions in this module require a time zone database. A time zone database is a record of the UTC offsets that its locales have used at various times in the past, are using, and are expected to use in the future. Because those plans can change, it needs to be periodically updated.

By default, DateTime uses the default time zone database returned by Calendar.get_time_zone_database/0, which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles "Etc/UTC" datetimes and returns {:error, :utc_only_time_zone_database} for any other time zone.

Other time zone databases can also be configured. Here are some available options and libraries:

To use one of them, first make sure it is added as a dependency in mix.exs. It can then be configured either via configuration:

or by calling Calendar.put_time_zone_database/1:

See the proper names in the library installation instructions.

In the first section, we described datetimes as a "snapshot of a date and time at a given time zone". To understand precisely what we mean, let's see an example.

Imagine someone in Poland who wants to schedule a meeting with someone in Brazil in the next year. The meeting will happen at 2:30 AM in the Polish time zone. At what time will the meeting happen in Brazil?

You can consult the time zone database today, one year before, using the API in this module and it will give you an answer that is valid right now. However, this answer may not be vali

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Enum.min([~U[2022-01-12 00:01:00.00Z], ~U[2021-01-12 00:01:00.00Z]], DateTime)
~U[2021-01-12 00:01:00.00Z]
```

Example 2 (unknown):
```unknown
config :elixir, :time_zone_database, Tz.TimeZoneDatabase
```

Example 3 (unknown):
```unknown
Calendar.put_time_zone_database(Tz.TimeZoneDatabase)
```

Example 4 (javascript):
```javascript
# Local time to UTC
new_york = DateTime.from_naive!(~N[2023-06-26T09:30:00], "America/New_York")
#=> #DateTime<2023-06-26 09:30:00-04:00 EDT America/New_York>

utc = DateTime.shift_zone!(new_york, "Etc/UTC")
#=> ~U[2023-06-26 13:30:00Z]

# UTC to local time
DateTime.shift_zone!(utc, "Europe/Paris")
#=> #DateTime<2023-06-26 15:30:00+02:00 CEST Europe/Paris>
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#!==/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defstruct/1-types

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_D/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binary_slice/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3C/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## UndefinedFunctionError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/UndefinedFunctionError.html

**Contents:**
- UndefinedFunctionError exception (Elixir v1.19.0)

An exception raised when a function is invoked that is not defined.

The following fields of this exception are public and can be accessed freely:

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
# Let's use apply/3 as otherwise Elixir emits a compile-time warning
iex> apply(String, :non_existing_fun, ["hello"])
** (UndefinedFunctionError) function String.non_existing_fun/1 is undefined or private
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defguard/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#make_ref/0

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#def/2-default-arguments

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#tap/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#max/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3E/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html#project-compilation

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#apply/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#update_in/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#send/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#===/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#then/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-protocols

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#-/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#raise/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_exception/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#apply/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#floor/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#update_in/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#node/0

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_nil/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3C=/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Library guidelines

**URL:** https://hexdocs.pm/elixir/library-guidelines.html

**Contents:**
- Library guidelines
- Getting started
- Publishing
- Dependency handling
  - Dependency Version Requirements

This document outlines general guidelines for those writing and publishing Elixir libraries meant to be consumed by other developers.

You can create a new Elixir library by running the mix new command:

The project name is given in the snake_case convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the Naming Conventions document for more information.

Every project has a mix.exs file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a lib directory, which includes Elixir source code, and a test directory. A src directory may also exist for Erlang sources.

The mix new command also allows the --sup option to scaffold a new project with a supervision tree out of the box. For more information on running your project, see the official Mix & OTP guide or Mix documentation.

Writing code is only the first of many steps to publish a package. We strongly recommend developers to:

Choose a versioning schema. Elixir requires versions to be in the format MAJOR.MINOR.PATCH but the meaning of those numbers is up to you. Most projects choose Semantic Versioning.

Choose a license. The most common licenses in the Elixir community are the MIT License and the Apache License 2.0. The latter is also the one used by Elixir itself.

Run the code formatter. The code formatter formats your code according to a consistent style shared by your library and the whole community, making it easier for other developers to understand your code and contribute.

Write tests. Elixir ships with a test-framework named ExUnit. The project generated by mix new includes sample tests and doctests.

Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the Writing documentation chapter of the Getting Started guide for more information. Projects like ExDoc can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports "extra pages", like this one that you are reading. Such pages augment the documentation with tutorials, guides, references, and even cheat-sheets.

Follow best practices. The Elixir project documents a series of anti-patterns that you may want to avoid in your code. The proc

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
$ mix new my_library
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#apply/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Calendar.ISO (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Calendar.ISO.html

**Contents:**
- Calendar.ISO (Elixir v1.19.0)
- ISO 8601 compliance
  - Features
    - Examples
  - Extensions
    - Examples
  - Additions
    - Examples
- Summary
- Types

The default calendar implementation, a Gregorian calendar following ISO 8601.

This calendar implements a proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted.

The ISO 8601 specification is feature-rich, but allows applications to selectively implement most parts of it. The choices Elixir makes are catalogued below.

The standard library supports a minimal set of possible ISO 8601 features. Specifically, the parser only supports calendar dates and does not support ordinal and week formats. Additionally, it supports parsing ISO 8601 formatted durations, including negative time units and fractional seconds.

By default Elixir only parses extended-formatted date/times. You can opt-in to parse basic-formatted date/times.

NaiveDateTime.to_iso8601/2 and DateTime.to_iso8601/2 allow you to produce either basic or extended formatted strings, and Calendar.strftime/2 allows you to format datetimes however else you desire.

Elixir does not support reduced accuracy formats (for example, a date without the day component) nor decimal precisions in the lowest component (such as 10:01:25,5).

Elixir expects the extended format by default when parsing:

Parsing can be restricted to basic if desired:

Only calendar dates are supported in parsing; ordinal and week dates are not.

Years, months, days, hours, minutes, and seconds must be fully specified:

The parser and formatter adopt one ISO 8601 extension: extended year notation.

This allows dates to be prefixed with a + or - sign, extending the range of expressible years from the default (0000..9999) to -9999..9999. Elixir still restricts years in this format to four digits.

ISO 8601 does not allow a whitespace instead of T as a separator between date and times, both when parsing and formatting. This is a common enough representation, Elixir allows it during parsing.

The formatting of dates in NaiveDateTime.to_iso8601/1 and DateTime.to_iso8601/1 do produce specification-compliant string representations using the T separator.

"Before the Current Era" or "Before the Common Era" (BCE), for those years less than 1.

The "Current Era" or the "Common Era" (CE) which starts in year 1.

Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.

Microseconds with s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Calendar.ISO.parse_naive_datetime("2015-01-23T23:50:07")
{:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}
iex> Calendar.ISO.parse_naive_datetime("20150123T235007")
{:error, :invalid_format}
```

Example 2 (unknown):
```unknown
iex> Calendar.ISO.parse_naive_datetime("20150123T235007Z", :basic)
{:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}
iex> Calendar.ISO.parse_naive_datetime("20150123T235007Z", :extended)
{:error, :invalid_format}
```

Example 3 (unknown):
```unknown
iex> Calendar.ISO.parse_date("2015-04-15")
{:ok, {2015, 4, 15}}
iex> Calendar.ISO.parse_date("2015-105")
{:error, :invalid_format}
iex> Calendar.ISO.parse_date("2015-W16")
{:error, :invalid_format}
iex> Calendar.ISO.parse_date("2015-W016-3")
{:error, :invalid_format}
```

Example 4 (unknown):
```unknown
iex> Calendar.ISO.parse_date("2015-04-15")
{:ok, {2015, 4, 15}}
iex> Calendar.ISO.parse_date("2015-04")
{:error, :invalid_format}
iex> Calendar.ISO.parse_date("2015")
{:error, :invalid_format}

iex> Calendar.ISO.parse_time("23:50:07.0123456")
{:ok, {23, 50, 7, {12345, 6}}}
iex> Calendar.ISO.parse_time("23:50:07")
{:ok, {23, 50, 7, {0, 0}}}
iex> Calendar.ISO.parse_time("23:50")
{:error, :invalid_format}
iex> Calendar.ISO.parse_time("23")
{:error, :invalid_format}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#+/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_atom/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#bit_size/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#rem/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Inspect.Opts (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Inspect.Opts.html#t:new_opt/0

**Contents:**
- Inspect.Opts (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- color_key()
- new_opt()
- t()
- Functions
- default_inspect_fun()

Defines the options used by the Inspect protocol.

The following fields are available:

:base - prints integers and binaries as :binary, :octal, :decimal, or :hex. Defaults to :decimal.

:binaries - when :as_binaries all binaries will be printed in bit syntax.

When :as_strings all binaries will be printed as strings, non-printable bytes will be escaped.

When the default :infer, the binary will be printed as a string if :base is :decimal and if it is printable, otherwise in bit syntax. See String.printable?/1 to learn when a string is printable.

:charlists - when :as_charlists all lists will be printed as charlists, non-printable elements will be escaped.

When :as_lists all lists will be printed as lists.

When the default :infer, the list will be printed as a charlist if it is printable, otherwise as list. See List.ascii_printable?/1 to learn when a charlist is printable.

:custom_options (since v1.9.0) - a keyword list storing custom user-defined options. Useful when implementing the Inspect protocol for nested structs to pass the custom options through.

It supports some pre-defined keys:

:inspect_fun (since v1.9.0) - a function to build algebra documents. Defaults to Inspect.Opts.default_inspect_fun/0.

:limit - limits the number of items that are inspected for tuples, bitstrings, maps, lists and any other collection of items, with the exception of printable strings and printable charlists which use the :printable_limit option. It accepts a positive integer or :infinity. It defaults to 100 since Elixir v1.19.0, as it has better defaults to deal with nested collections.

:pretty - if set to true enables pretty printing. Defaults to false.

:printable_limit - limits the number of characters that are inspected on printable strings and printable charlists. You can use String.printable?/1 and List.ascii_printable?/1 to check if a given string or charlist is printable. If you don't want to limit the number of characters to a particular number, use :infinity. It accepts a positive integer or :infinity. Defaults to 4096.

:safe - when false, failures while inspecting structs will be raised as errors instead of being wrapped in the Inspect.Error exception. This is useful when debugging failures and crashes for custom inspect implementations. Defaults to true.

:structs - when false, structs are not formatted by the inspect protocol, they are instead printed as maps. Defaults to true.

:syntax_colors - when set to a keyword list of colors the output is color

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
previous_fun = Inspect.Opts.default_inspect_fun()

Inspect.Opts.default_inspect_fun(fn
  %{address: _} = map, opts ->
    previous_fun.(%{map | address: "[REDACTED]"}, opts)

  value, opts ->
    previous_fun.(value, opts)
end)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_tuple/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#struct/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#if/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_atom/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#--/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Protocol behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Protocol.html

**Contents:**
- Protocol behaviour (Elixir v1.19.0)
- Example
- Protocols and Structs
- Fallback to Any
- Multiple implementations
- Types
- Configuration
- Consolidation
- Summary
- Callbacks

Reference and functions for working with protocols.

A protocol specifies an API that should be defined by its implementations. A protocol is defined with Kernel.defprotocol/2 and its implementations with Kernel.defimpl/3.

In Elixir, we have two nouns for checking how many items there are in a data structure: length and size. length means the information must be computed. For example, length(list) needs to traverse the whole list to calculate its length. On the other hand, tuple_size(tuple) and byte_size(binary) do not depend on the tuple and binary size as the size information is precomputed in the data structure.

Although Elixir includes specific functions such as tuple_size, binary_size and map_size, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:

Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:

Finally, we can use the Size protocol to call the correct implementation:

Note that we didn't implement it for lists as we don't have the size information on lists, rather its value needs to be computed with length.

The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol.

It is possible to implement protocols for all Elixir types:

The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like MapSet. We can implement the Size protocol for those types as well:

When implementing a protocol for a struct, the :for option can be omitted if the defimpl/3 call is inside the module that defines the struct:

If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to Any. Conveniences for building implementations on top of existing ones are also available, look at defstruct/1 for more information about deriving protocols.

In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the @fallback_to_any attribute to true in the protocol definition:

The Size protocol can now be implemented for Any:

Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integ

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end
```

Example 2 (python):
```python
defimpl Size, for: BitString do
  def size(binary), do: byte_size(binary)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

Example 3 (javascript):
```javascript
Size.size({1, 2})
# => 2
Size.size(%{key: :value})
# => 1
```

Example 4 (python):
```python
defimpl Size, for: MapSet do
  def size(map_set), do: MapSet.size(map_set)
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_link/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## MatchError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/MatchError.html

**Contents:**
- MatchError exception (Elixir v1.19.0)

An exception raised when a pattern match (=/2) fails.

The following fields of this exception are public and can be accessed freely:

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> [_ | _] = []
** (MatchError) no match of right hand side value:
...
```

---

## 

**URL:** https://hexdocs.pm/elixir/

---

## String (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/String.html#t:t/0

**Contents:**
- String (Elixir v1.19.0)
- Interpolation
- Escape characters
- Unicode and code points
- UTF-8 encoded and encodings
- Grapheme clusters
- String and binary operations
- Self-synchronization
- Compile binary patterns
- Summary

Strings in Elixir are UTF-8 encoded binaries.

Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as "hello" and "héllò".

In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: "this is a string with \"double quotes\"".

You can concatenate two strings with the <>/2 operator:

The functions in this module act according to The Unicode Standard, Version 17.0.0.

Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the #{} syntax:

Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation:

In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised.

Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:

Note it is generally not advised to use \xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \uNNNN. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.

In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.

Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point.

In Elixir you can use a ? in front of a character literal to reveal its code point:

Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. 97 translates to 0061 in hex, and we can represent any Unicode character in an Elixir string by 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> "hello" <> " " <> "world"
"hello world"
```

Example 2 (unknown):
```unknown
iex> name = "joe"
iex> "hello #{name}"
"hello joe"
```

Example 3 (unknown):
```unknown
iex> "2 + 2 = #{2 + 2}"
"2 + 2 = 4"
```

Example 4 (unknown):
```unknown
iex> ?a
97
iex> ?ł
322
```

---

## File (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/File.html#cp_r/3

**Contents:**
- File (Elixir v1.19.0)
- Encoding
- API
- Processes and raw files
- Seeking within a file
- Summary
- Types
- Functions
- Types
- encoding_mode()

This module contains functions to manipulate files.

Some of those functions are low-level, allowing the user to interact with files or IO devices, like open/2, copy/3 and others. This module also provides higher level functions that work with filenames and have their naming based on Unix variants. For example, one can copy a file via cp/3 and remove files and directories recursively via rm_rf/1.

Paths given to functions in this module can be either relative to the current working directory (as returned by File.cwd/0), or absolute paths. Shell conventions like ~ are not expanded automatically. To use paths like ~/Downloads, you can use Path.expand/1 or Path.expand/2 to expand your path to an absolute path.

In order to write and read files, one must use the functions in the IO module. By default, a file is opened in binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file, then the slower IO.read/2 and IO.write/2 functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.

Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.

Most of the functions in this module return :ok or {:ok, result} in case of success, {:error, reason} otherwise. Those functions also have a variant that ends with ! which returns the result (instead of the {:ok, result} tuple) in case of success or raises an exception in case it fails. For example:

In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).

Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.

This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.

However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in :raw mode. The options :read_ahead and :delayed_write are also useful when operating on large files or working with files in tight loo

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
File.read("hello.txt")
#=> {:ok, "World"}

File.read("invalid.txt")
#=> {:error, :enoent}

File.read!("hello.txt")
#=> "World"

File.read!("invalid.txt")
#=> raises File.Error
```

Example 2 (javascript):
```javascript
File.write!("example.txt", "Eats, Shoots & Leaves")
file = File.open!("example.txt")
:file.pread(file, 15, 6)
#=> {:ok, "Leaves"}
```

Example 3 (javascript):
```javascript
:file.position(file, 6)
#=> {:ok, 6}
:file.read(file, 6)
#=> {:ok, "Shoots"}
:file.position(file, {:cur, -12})
#=> {:ok, 0}
:file.read(file, 4)
#=> {:ok, "Eats"}
```

Example 4 (javascript):
```javascript
File.cd("bin")
#=> :ok

File.cd("non_existing_dir")
#=> {:error, :enoent}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#in/2-guards

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_struct/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_U/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-guards

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#reraise/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#improved-pretty-printing-algorithm

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Enum.OutOfBoundsError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enum.OutOfBoundsError.html

**Contents:**
- Enum.OutOfBoundsError exception (Elixir v1.19.0)
- Summary
- Functions
- Functions
- message(index, enumerable)

An exception that is raised when a function expects an enumerable to have a certain size but finds that it is too small.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> Enum.fetch!([1, 2, 3], 5)
** (Enum.OutOfBoundsError) out of bounds error at position 5 when traversing enumerable [1, 2, 3]
```

---

## String (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/String.html#slice/3

**Contents:**
- String (Elixir v1.19.0)
- Interpolation
- Escape characters
- Unicode and code points
- UTF-8 encoded and encodings
- Grapheme clusters
- String and binary operations
- Self-synchronization
- Compile binary patterns
- Summary

Strings in Elixir are UTF-8 encoded binaries.

Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as "hello" and "héllò".

In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: "this is a string with \"double quotes\"".

You can concatenate two strings with the <>/2 operator:

The functions in this module act according to The Unicode Standard, Version 17.0.0.

Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the #{} syntax:

Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation:

In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised.

Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:

Note it is generally not advised to use \xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \uNNNN. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.

In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.

Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point.

In Elixir you can use a ? in front of a character literal to reveal its code point:

Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. 97 translates to 0061 in hex, and we can represent any Unicode character in an Elixir string by 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> "hello" <> " " <> "world"
"hello world"
```

Example 2 (unknown):
```unknown
iex> name = "joe"
iex> "hello #{name}"
"hello joe"
```

Example 3 (unknown):
```unknown
iex> "2 + 2 = #{2 + 2}"
"2 + 2 = 4"
```

Example 4 (unknown):
```unknown
iex> ?a
97
iex> ?ł
322
```

---

## List (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/List.html#flatten/1

**Contents:**
- List (Elixir v1.19.0)
- Charlists
- Summary
- Functions
- Functions
- ascii_printable?(list, limit \\ :infinity)
- Examples
- delete(list, element)
- Examples
- delete_at(list, index)

Linked lists hold zero, one, or more elements in the chosen order.

Lists in Elixir are specified between square brackets:

Two lists can be concatenated and subtracted using the ++/2 and --/2 operators:

An element can be prepended to a list using |:

Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:

Similarly, we could write the list [1, 2, 3] using only such pairs (called cons cells):

Some lists, called improper lists, do not have an empty list as the second element in the last cons cell:

Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the IO module).

Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time):

Most of the functions in this module work in linear time. This means that the time it takes to perform an operation grows at the same rate as the length of the list. For example length/1 and last/1 will run in linear time because they need to iterate through every element of the list, but first/1 will run in constant time because it only needs the first element.

Lists also implement the Enumerable protocol, so many functions to work with lists are found in the Enum module. Additionally, the following functions and operators for lists are found in Kernel:

If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:

Elixir uses the ~c sigil to define charlists:

In particular, charlists will be printed back by default with the ~c sigil if they contain only printable ASCII characters:

Even though the representation changed, the raw data does remain a list of integers, which can be handled as such:

You can use the IEx.Helpers.i/1 helper to get a condensed rundown on charlists in IEx when you encounter them, which shows you the type, description and also the raw representation in one single summary.

The rationale behind this behavior is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is Application.loaded_applications/0:

A list can be checked if it is made of only printable ASCII charact

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> [1, "two", 3, :four]
[1, "two", 3, :four]
```

Example 2 (unknown):
```unknown
iex> [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex> [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]
```

Example 3 (unknown):
```unknown
iex> new = 0
iex> list = [1, 2, 3]
iex> [new | list]
[0, 1, 2, 3]
```

Example 4 (unknown):
```unknown
iex> [head | tail] = [1, 2, 3]
iex> head
1
iex> tail
[2, 3]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_exception/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-supporting-documents

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html#exploring

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binary_part/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Calendar behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Calendar.html#strftime/3

**Contents:**
- Calendar behaviour (Elixir v1.19.0)
- Summary
- Types
- Callbacks
- Functions
- Types
- calendar()
- date()
- datetime()
- day()

This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.

It defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the calendar features in Elixir is to provide a base for interoperability rather than a full-featured datetime API.

For the actual date, time and datetime structs, see Date, Time, NaiveDateTime, and DateTime.

Types for year, month, day, and more are overspecified. For example, the month/0 type is specified as an integer instead of 1..12. This is because different calendars may have a different number of days per month.

A calendar implementation.

Any map or struct that contains the date fields.

Any map or struct that contains the datetime fields.

The internal time format is used when converting between calendars.

A tuple representing the day and the era.

The internal date format that is used when converting between calendars.

Microseconds with stored precision.

Any map or struct that contains the naive datetime fields.

The time zone standard offset in ISO seconds (typically not zero in summer times).

Options for formatting dates and times with strftime/3.

Any map or struct that contains the time fields.

The time zone ID according to the IANA tz database (for example, Europe/Zurich).

Specifies the time zone database for calendar operations.

The time zone UTC offset in ISO seconds for standard time.

The time zone abbreviation (for example, CET or CEST or BST).

Converts the date into a string according to the calendar.

Converts the datetime (with time zone) into a string according to the calendar.

Calculates the day and era from the given year, month, and day.

Calculates the day of the week from the given year, month, and day.

Calculates the day of the year from the given year, month, and day.

Define the rollover moment for the calendar.

Returns how many days there are in the given month of the given year.

Converts the given iso_days/0 to the first moment of the day.

Converts the given iso_days/0 to the last moment of the day.

Returns true if the given year is a leap year.

Returns how many months there are in the given year.

Converts iso_days/0 to the calendar's datetime format.

Converts the datetime (without time zone) into the iso_days/0 format.

Converts the naive datetime (without time zone) into a string according to the calendar.

Parses the string representation for a date returned by date_to_string/3 into a date tuple.

Pa

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
config :elixir, :time_zone_database, CustomTimeZoneDatabase
```

Example 2 (unknown):
```unknown
iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%y-%m-%d %I:%M:%S %p")
"19-08-26 01:52:06 PM"

iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%a, %B %d %Y")
"Mon, August 26 2019"
```

Example 3 (unknown):
```unknown
%<padding><width><format>
```

Example 4 (unknown):
```unknown
iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%y-%m-%d %I:%M:%S %p")
"19-08-26 01:52:06 PM"

iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%a, %B %d %Y")
"Mon, August 26 2019"

iex> Calendar.strftime(~U[2020-04-02 13:52:06.0Z], "%B %-d, %Y")
"April 2, 2020"

iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%c")
"2019-08-26 13:52:06"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#raise/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#elem/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_W/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmodule/2-dynamic-names

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#dbg/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#in/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#=~/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_float/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#destructure/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Basic types

**URL:** https://hexdocs.pm/elixir/basic-types.html#booleans-and-nil

**Contents:**
- Basic types
- Basic arithmetic
- Booleans and nil
- Atoms
- Strings
- Structural comparison

In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, and strings. Other data types, such as lists and tuples, will be explored in the next chapter.

Open up iex and type the following expressions:

Notice that 10 / 2 returned a float 5.0 instead of an integer 5. This is expected. In Elixir, the operator / always returns a float. If you want to do integer division or get the division remainder, you can invoke the div and rem functions:

Notice that Elixir allows you to drop the parentheses when invoking functions that expect one or more arguments. This feature gives a cleaner syntax when writing declarations and control-flow constructs. However, Elixir developers generally prefer to use parentheses.

Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:

Float numbers require a dot followed by at least one digit and also support e for scientific notation:

Floats in Elixir are 64-bit precision.

You can invoke the round function to get the closest integer to a given float, or the trunc function to get the integer part of a float.

Finally, we work with different data types, we will learn Elixir provides several predicate functions to check for the type of a value. For example, is_integer can be used to check if a value is an integer or not:

You can also use is_float or is_number to check, respectively, if an argument is a float, or either an integer or float.

Elixir supports true and false as booleans:

Elixir also provides three boolean operators: or, and, and not. These operators are strict in the sense that they expect something that evaluates to a boolean (true or false) as their first argument:

Providing a non-boolean will raise an exception:

or and and are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:

Elixir also provides the concept of nil, to indicate the absence of a value, and a set of logical operators that also manipulate nil: ||/2, &&/2, and !/1. For these operators, false and nil are considered "falsy", all other values are considered "truthy":

Similarly, values like 0 and "", which some other programming languages consider to be "falsy", are also "truthy" in Elixir.

As a rule of thumb, use and, or and not when you are expecting booleans. If any of the arguments are non-boolean, use &&, || and !.

An atom is a constant whose value is its own name. Some other languages call these symbols. T

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```

Example 2 (unknown):
```unknown
iex> 1 + 2
3
iex> 5 * 5
25
iex> 10 / 2
5.0
```

Example 3 (unknown):
```unknown
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1
```

Example 4 (unknown):
```unknown
iex> 0b1010
10
iex> 0o777
511
iex> 0x1F
31
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-system-modules

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#-/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#apply/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_timeout/1-passing-components

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Inspect protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Inspect.html

**Contents:**
- Inspect protocol (Elixir v1.19.0)
- Inspect representation
- Deriving
- Custom implementation
  - Error handling
- Summary
- Types
- Functions
- Types
- t()

The Inspect protocol converts an Elixir data structure into an algebra document.

This is typically done when you want to customize how your own structs are inspected in logs and the terminal.

This documentation refers to implementing the Inspect protocol for your own data structures. To learn more about using inspect, see Kernel.inspect/2 and IO.inspect/2.

There are typically three choices of inspect representation. In order to understand them, let's imagine we have the following User struct:

Print the struct using Elixir's struct syntax, for example: %User{address: "Earth", id: 13, name: "Jane"}. This is the default representation and best choice if all struct fields are public.

Print using the #User<...> notation, for example: #User<id: 13, name: "Jane", ...>. This notation does not emit valid Elixir code and is typically used when the struct has private fields (for example, you may want to hide the field :address to redact person identifiable information).

Print the struct using the expression syntax, for example: User.new(13, "Jane", "Earth"). This assumes there is a User.new/3 function. This option is mostly used as an alternative to option 2 for representing custom data structures, such as MapSet, Date.Range, and others.

You can implement the Inspect protocol for your own structs while adhering to the conventions above. Option 1 is the default representation and you can quickly achieve option 2 by deriving the Inspect protocol. For option 3, you need your custom implementation.

The Inspect protocol can be derived to customize the order of fields (the default is alphabetical) and hide certain fields from structs, so they don't show up in logs, inspects and similar. The latter is especially useful for fields containing private information.

The supported options are:

:only - only include the given fields when inspecting.

:except - remove the given fields when inspecting.

:optional - (since v1.14.0) a list of fields that should not be included when they match their default value. This can be used to simplify the struct representation at the cost of hiding information. Since v1.19.0, the :all atom can be passed to mark all fields as optional.

Whenever :only or :except are used to restrict fields, the struct will be printed using the #User<...> notation, as the struct can no longer be copy and pasted as valid Elixir code. Let's see an example:

If you use only the :optional option, the struct will still be printed as a valid struct.

You can a

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct [:id, :name, :address]
end
```

Example 2 (javascript):
```javascript
defmodule User do
  @derive {Inspect, only: [:id, :name]}
  defstruct [:id, :name, :address]
end

inspect(%User{id: 1, name: "Jane", address: "Earth"})
#=> #User<id: 1, name: "Jane", ...>
```

Example 3 (unknown):
```unknown
defmodule Point do
  @derive {Inspect, optional: [:z]}
  defstruct [x: 0, y: 0, z: 0]
end

inspect(%Point{x: 1})
%Point{x: 1, y: 0}
```

Example 4 (python):
```python
defimpl Inspect, for: MapSet do
  import Inspect.Algebra

  def inspect(map_set, opts) do
    {doc, opts} = to_doc_with_opts(MapSet.to_list(map_set), opts)
    {concat(["MapSet.new(", doc, ")"]), opts}
  end
end
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Basic types

**URL:** https://hexdocs.pm/elixir/basic-types.html#basic-arithmetic

**Contents:**
- Basic types
- Basic arithmetic
- Booleans and nil
- Atoms
- Strings
- Structural comparison

In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, and strings. Other data types, such as lists and tuples, will be explored in the next chapter.

Open up iex and type the following expressions:

Notice that 10 / 2 returned a float 5.0 instead of an integer 5. This is expected. In Elixir, the operator / always returns a float. If you want to do integer division or get the division remainder, you can invoke the div and rem functions:

Notice that Elixir allows you to drop the parentheses when invoking functions that expect one or more arguments. This feature gives a cleaner syntax when writing declarations and control-flow constructs. However, Elixir developers generally prefer to use parentheses.

Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:

Float numbers require a dot followed by at least one digit and also support e for scientific notation:

Floats in Elixir are 64-bit precision.

You can invoke the round function to get the closest integer to a given float, or the trunc function to get the integer part of a float.

Finally, we work with different data types, we will learn Elixir provides several predicate functions to check for the type of a value. For example, is_integer can be used to check if a value is an integer or not:

You can also use is_float or is_number to check, respectively, if an argument is a float, or either an integer or float.

Elixir supports true and false as booleans:

Elixir also provides three boolean operators: or, and, and not. These operators are strict in the sense that they expect something that evaluates to a boolean (true or false) as their first argument:

Providing a non-boolean will raise an exception:

or and and are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:

Elixir also provides the concept of nil, to indicate the absence of a value, and a set of logical operators that also manipulate nil: ||/2, &&/2, and !/1. For these operators, false and nil are considered "falsy", all other values are considered "truthy":

Similarly, values like 0 and "", which some other programming languages consider to be "falsy", are also "truthy" in Elixir.

As a rule of thumb, use and, or and not when you are expecting booleans. If any of the arguments are non-boolean, use &&, || and !.

An atom is a constant whose value is its own name. Some other languages call these symbols. T

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```

Example 2 (unknown):
```unknown
iex> 1 + 2
3
iex> 5 * 5
25
iex> 10 / 2
5.0
```

Example 3 (unknown):
```unknown
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1
```

Example 4 (unknown):
```unknown
iex> 0b1010
10
iex> 0o777
511
iex> 0x1F
31
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#..///3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_pid/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#make_ref/0-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#match?/2-values-vs-patterns

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defstruct/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#put_in/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Date (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Date.html

**Contents:**
- Date (Elixir v1.19.0)
- Comparing dates
- Using epochs
- Summary
- Types
- Functions
- Types
- t()
- Functions
- add(date, days)

A Date struct and functions.

The Date struct contains the fields year, month, day and calendar. New dates can be built with the new/3 function or using the ~D (see sigil_D/2) sigil:

Both new/3 and sigil return a struct where the date fields can be accessed directly:

The functions on this module work with the Date struct as well as any struct that contains the same fields as the Date struct, such as NaiveDateTime and DateTime. Such functions expect Calendar.date/0 in their typespecs (instead of t/0).

Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.

Comparisons in Elixir using ==/2, >/2, </2 and similar are structural and based on the Date struct fields. For proper comparison between dates, use the compare/2, after?/2 and before?/2 functions. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum date of an Enum. For example:

The add/2, diff/2 and shift/2 functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):

Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).

Adds the number of days to the given date.

Returns true if the first date is strictly later than the second.

Returns true if the first date is strictly earlier than the second.

Calculates a date that is the first day of the month for the given date.

Calculates a date that is the first day of the week for the given date.

Compares two date structs.

Converts the given date from its calendar to the given calendar.

Similar to Date.convert/2, but raises an ArgumentError if the conversion between the two calendars is not possible.

Calculates the day-of-era and era for a given calendar date.

Calculates the ordinal day of the week of a given date.

Calculates the day of the year of a given date.

Returns the number of days in the given date month.

Calculates the difference between two dates, in a full number of days.

Calculates a date that is the last day of the month for the given date.

Calculates a date that is the last day of the week for the given date.

Converts an Erlang date tuple to a Date struct.

Converts an Erlang date tuple but raises for invalid dates.

Converts a n

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> ~D[2000-01-01]
~D[2000-01-01]
```

Example 2 (unknown):
```unknown
iex> date = ~D[2000-01-01]
iex> date.year
2000
iex> date.month
1
```

Example 3 (unknown):
```unknown
iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-03-31]
```

Example 4 (unknown):
```unknown
iex> Date.diff(~D[2010-04-17], ~D[1970-01-01])
14716

iex> Date.add(~D[1970-01-01], 14716)
~D[2010-04-17]

iex> Date.shift(~D[1970-01-01], year: 40, month: 3, week: 2, day: 2)
~D[2010-04-17]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#tuple_size/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#use/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-inlining

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#erlang-otp-28-support

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_function/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_monitor/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#v1-19-0-2025-10-16

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#destructure/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#reraise/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction — Elixir v1.19.0

**URL:** https://hexdocs.pm/elixir/introduction.html

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#unless/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#3-soft-deprecations-no-warnings-emitted

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Code (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Code.html#format_string!/2

**Contents:**
- Code (Elixir v1.19.0)
- Working with files
- Code loading on the Erlang VM
- ensure_compiled/1 and ensure_compiled!/1
- Compilation tracers
- Summary
- Types
- Functions
- Types
- binding()

Utilities for managing code compilation, code evaluation, and code loading.

This module complements Erlang's :code module to add behavior which is specific to Elixir. For functions to manipulate Elixir's AST (rather than evaluating it), see the Macro module.

This module contains three functions for compiling and evaluating files. Here is a summary of them and their behavior:

require_file/2 - compiles a file and tracks its name. It does not compile the file again if it has been previously required.

compile_file/2 - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times.

eval_file/2 - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section.

In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.

compile_file/2 must be used when you are interested in the modules defined in a file, without tracking. eval_file/2 should be used when you are interested in the result of evaluating the file rather than the modules it defines.

The functions above work with Elixir source. If you want to work with modules compiled to bytecode, which have the .beam extension and are typically found below the _build directory of a Mix project, see the functions in Erlang's :code module.

Erlang has two modes to load code: interactive and embedded.

By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.

You can use ensure_loaded/1 (as well as ensure_loaded?/1 and ensure_loaded!/1) to check if a module is loaded before using it and act.

Elixir also includes ensure_compiled/1 and ensure_compiled!/1 functions that are a superset of ensure_loaded/1.

Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded.

When invoked, ensure_compiled/1 and ensure_compiled!/1 halt the compilation of the caller until the module becomes available. Note that the distinction between ensure_compiled/1 and ensure_compiled!/1 is important: if you are using ensure_compiled!/1, you are indicating to the compiler that you can o

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
case Code.ensure_compiled(module) do
  {:module, _} -> module
  {:error, _} -> raise ...
end
```

Example 2 (python):
```python
defmodule MyTracer do
  def trace({:remote_function, _meta, module, name, arity}, env) do
    IO.puts("#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}")
    :ok
  end

  def trace(_event, _env) do
    :ok
  end
end
```

Example 3 (javascript):
```javascript
Code.append_path(".")
#=> true

Code.append_path("/does_not_exist")
#=> false
```

Example 4 (javascript):
```javascript
Code.append_paths([".", "/does_not_exist"])
#=> :ok
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3-functions-as-keys

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#def/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Patterns and guards

**URL:** https://hexdocs.pm/elixir/patterns-and-guards.html

**Contents:**
- Patterns and guards
- Patterns
  - Variables
  - Literals (numbers and atoms)
  - Tuples
  - Lists
  - Maps
  - Structs
  - Binaries
- Guards

Elixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.

This document provides a complete reference on patterns and guards, their semantics, where they are allowed, and how to extend them.

Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator (=):

In the example above, x starts without a value and has 1 assigned to it. Then, we compare the value of x to the literal 1, which succeeds as they are both 1.

Matching x against 2 would raise:

Patterns are not bidirectional. If you have a variable y that was never assigned to (often called an unbound variable) and you write 1 = y, an error will be raised:

In other words, patterns are allowed only on the left side of =. The right side of = follows the regular evaluation semantics of the language.

Now let's cover the pattern matching rules for each construct and then for each relevant data types.

Variables in patterns are always assigned to:

In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (^):

If the same variable appears multiple times in the same pattern, then all of them must be bound to the same value:

The underscore variable (_) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:

A pinned value represents the value itself and not its – even if syntactically equal – pattern. The right hand side is compared to be equal to the pinned value:

Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom:

Similar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats:

Tuples may appear in patterns using the curly brackets syntax ({}). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:

Lists may appear in patterns using the square brackets syntax ([]). A list in a pattern will match only lists of the same size, where each individual list element must also match:

Opposite to tuples, lists al

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> x = 1
1
iex> 1 = x
1
```

Example 2 (unknown):
```unknown
iex> 2 = x
** (MatchError) no match of right hand side value: 1
```

Example 3 (unknown):
```unknown
iex> 1 = y
** (CompileError) iex:2: undefined variable "y"
```

Example 4 (unknown):
```unknown
iex> x = 1
1
iex> x = 2
2
iex> x
2
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defdelegate/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#raise/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#alias!/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Version (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Version.html

**Contents:**
- Version (Elixir v1.19.0)
- Versions
- Requirements
- Summary
- Types
- Functions
- Types
- build()
- major()
- match_opts()

Functions for parsing and matching versions against requirements.

A version is a string in a specific format or a Version generated after parsing via Version.parse/1.

Although Elixir projects are not required to follow SemVer, they must follow the format outlined on SemVer 2.0 schema.

In a nutshell, a version is represented by three numbers:

Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens ([0-9A-Za-z-]):

Build information can be added by appending a plus sign and a series of dot-separated identifiers immediately following the patch or pre-release version. Identifiers consist of only ASCII alphanumeric characters and hyphens ([0-9A-Za-z-]):

Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as >, >=, <, <=, and == that work as one would expect, and additionally the special operator ~> described in detail further below.

Requirements also support and and or for complex conditions:

Since the example above is such a common requirement, it can be expressed as:

~> will never include pre-release versions of its upper bound, regardless of the usage of the :allow_pre option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for ~> requirements and their corresponding translations.

The requirement operand after the ~> is allowed to omit the patch version, allowing us to express ~> 2.1 or ~> 2.1-dev, something that wouldn't be allowed when using the common comparison operators.

When the :allow_pre option is set false in Version.match?/3, the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to always allow pre-releases but note that in Hex :allow_pre is set to false. See the table below for examples.

Compares two versions.

Compiles a requirement to an internal representation that may optimize matching.

Checks if the given version matches the specification.

Parses a version string into a Version struct.

Parses a version string into a Version.

Parses a version requirement string into a Version.Requirement struct.

Parses a version requirement string into a Version.Requirement struct.

Converts the given version to a string.

It co

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
MAJOR.MINOR.PATCH
```

Example 2 (unknown):
```unknown
"1.0.0-alpha.3"
```

Example 3 (unknown):
```unknown
"1.0.0-alpha.3+20130417140000.amd64"
```

Example 4 (unknown):
```unknown
# Only version 2.0.0
"== 2.0.0"

# Anything later than 2.0.0
"> 2.0.0"
```

---

## Exception behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Exception.html

**Contents:**
- Exception behaviour (Elixir v1.19.0)
- Formatting functions
- Summary
- Types
- Callbacks
- Functions
- Types
- arity_or_args()
- kind()
- location()

Functions for dealing with throw/catch/exit and exceptions.

This module also defines the behaviour required by custom exceptions. To define your own, see defexception/1.

Several functions in this module help format exceptions. Some of these functions expect the stacktrace as argument. The stacktrace is typically available inside catch and rescue by using the __STACKTRACE__/0 variable.

Do not rely on the particular format returned by the functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.

The kind handled by formatting functions

Called from Exception.blame/3 to augment the exception struct.

Receives the arguments given to raise/2 and returns the exception struct.

Receives the exception struct and must return its message.

Attaches information to throws/errors/exits for extra debugging.

Blames the invocation of the given module, function and arguments.

Normalizes and formats throws/errors/exits and stacktraces.

Normalizes and formats any throw/error/exit.

Formats an exit. It returns a string.

Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.

Formats the given file and line as shown in stacktraces.

Formats the given file, line, and column as shown in stacktraces.

Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.

Formats the stacktrace.

Receives a stacktrace entry and formats it into a string.

Gets the message for an exception.

Normalizes an exception, converting Erlang exceptions to Elixir exceptions.

The kind handled by formatting functions

Called from Exception.blame/3 to augment the exception struct.

Can be used to collect additional information about the exception or do some additional expensive computation.

Receives the arguments given to raise/2 and returns the exception struct.

The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message.

Receives the exception struct and must return its message.

Many exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented.

Attaches information to t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
Exception.format_fa(fn -> nil end, 1)
#=> "#Function<...>/1"
```

Example 2 (unknown):
```unknown
iex> Exception.format_file_line("foo", 1)
"foo:1:"

iex> Exception.format_file_line("foo", nil)
"foo:"

iex> Exception.format_file_line(nil, nil)
""
```

Example 3 (unknown):
```unknown
iex> Exception.format_file_line_column("foo", 1, 2)
"foo:1:2:"

iex> Exception.format_file_line_column("foo", 1, nil)
"foo:1:"

iex> Exception.format_file_line_column("foo", nil, nil)
"foo:"

iex> Exception.format_file_line_column("foo", nil, 2)
"foo:"

iex> Exception.format_file_line_column(nil, nil, nil)
""
```

Example 4 (unknown):
```unknown
iex> Exception.format_mfa(Foo, :bar, 1)
"Foo.bar/1"

iex> Exception.format_mfa(Foo, :bar, [])
"Foo.bar()"

iex> Exception.format_mfa(nil, :bar, [])
"nil.bar()"
```

---

## Supervisor behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Supervisor.html

**Contents:**
- Supervisor behaviour (Elixir v1.19.0)
- Examples
    - Disclaimer
- Child specification
  - Shutdown values (:shutdown)
  - Restart values (:restart)
- child_spec/1 function
- Supervisor strategies and options
  - Strategies
  - Automatic shutdown

A behaviour module for implementing supervisors.

A supervisor is a process which supervises other processes, which we refer to as child processes. Supervisors are used to build a hierarchical process structure called a supervision tree. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.

A supervisor may be started directly with a list of child specifications via start_link/2 or you may define a module-based supervisor that implements the required callbacks. The sections below use start_link/2 to start supervisors in most examples, but it also includes a specific section on module-based ones.

In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer, a generic server, that keeps a counter. Other processes can then send messages to this process to read the counter and bump its value.

In practice you would not define a counter as a GenServer. Instead, if you need a counter, you would pass it around as inputs and outputs to the functions that need it. The reason we picked a counter in this example is due to its simplicity, as it allows us to focus on how supervisors work.

The Counter receives an argument on start_link. This argument is passed to the init/1 callback which becomes the initial value of the counter. Our counter handles two operations (known as calls): :get, to get the current counter value, and :bump, that bumps the counter by the given value and returns the old counter.

We can now start a supervisor that will start and supervise our counter process. The first step is to define a list of child specifications that control how each child behaves. Each child specification is a map, as shown below:

Note that when starting the GenServer, we are registering it with name Counter via the name: __MODULE__ option. This allows us to call it directly and get its value:

However, there is a bug in our counter server. If we call :bump with a non-numeric value, it is going to crash:

Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, reset back to its initial value of 0:

Supervisors support different strategies; in the example above, we have chosen :one_for_one. Furthermore, each supervisor can have many workers and/or supervisors as children, with each one having its own configuration (as outlined in the "Child specification" section).

The rest of this document wi

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
defmodule Counter do
  use GenServer

  def start_link(arg) when is_integer(arg) do
    GenServer.start_link(__MODULE__, arg, name: __MODULE__)
  end

  ## Callbacks

  @impl true
  def init(counter) do
    {:ok, counter}
  end

  @impl true
  def handle_call(:get, _from, counter) do
    {:reply, counter, counter}
  end

  def handle_call({:bump, value}, _from, counter) do
    {:reply, counter, counter + value}
  end
end
```

Example 2 (javascript):
```javascript
children = [
  # The Counter is a child started via Counter.start_link(0)
  %{
    id: Counter,
    start: {Counter, :start_link, [0]}
  }
]

# Now we start the supervisor with the children and a strategy
{:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)

# After started, we can query the supervisor for information
Supervisor.count_children(pid)
#=> %{active: 1, specs: 1, supervisors: 0, workers: 1}
```

Example 3 (javascript):
```javascript
GenServer.call(Counter, :get)
#=> 0

GenServer.call(Counter, {:bump, 3})
#=> 0

GenServer.call(Counter, :get)
#=> 3
```

Example 4 (unknown):
```unknown
GenServer.call(Counter, {:bump, "oops"})
** (exit) exited in: GenServer.call(Counter, {:bump, "oops"}, 5000)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_binary/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#inspect/2-options

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction to Mix

**URL:** https://hexdocs.pm/elixir/introduction-to-mix.html#automatic-code-formatting

**Contents:**
- Introduction to Mix
    - Source code
    - Is this guide required reading?
- Our first project
    - Executables in the PATH
- Project compilation
- Running tests
- Automatic code formatting
- Environments
    - Mix in production

In this guide, we will build a complete Elixir application, with its own supervision tree, configuration, tests, and more.

The requirements for this guide are (see elixir -v):

The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:

In order to build our key-value application, we are going to use three main tools:

OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;

Mix is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;

ExUnit is a unit-test based framework that ships with Elixir.

In this chapter, we will create our first project using Mix and explore different features in OTP, Mix, and ExUnit as we go.

The final code for the application built in this guide is in this repository and can be used as a reference.

This guide is not required reading in your Elixir journey. We'll explain.

As an Elixir developer, you will most likely use one of the many existing frameworks when writing your Elixir code. Phoenix covers web applications, Ecto communicates with databases, you can craft embedded software with Nerves, Nx powers machine learning and AI projects, Membrane assembles audio/video processing pipelines, Broadway handles data ingestion and processing, and many more. These frameworks handle the lower level details of concurrency, distribution, and fault-tolerance, so you, as a user, can focus on your own needs and demands.

On the other hand, if you want to learn the foundations these frameworks are built upon, and the abstractions that power the Elixir ecosystem, this guide will give you a tour through several important concepts.

When you install Elixir, besides getting the elixir, elixirc, and iex executables, you also get an executable Elixir script named mix.

Let's create our first project by invoking mix new from the command line. We'll pass the project path as the argument (kv, in this case). By default, the application name and module name will be retrieved from the path. So we tell Mix that our main module s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

Example 2 (unknown):
```unknown
$ mix new kv --module KV
```

Example 3 (unknown):
```unknown
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

Example 4 (python):
```python
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#../0-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_struct/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_exception/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3E=/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#inspect/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Integer (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Integer.html

**Contents:**
- Integer (Elixir v1.19.0)
- Summary
- Guards
- Functions
- Guards
- is_even(integer)
- Examples
- is_odd(integer)
- Examples
- Functions

Functions for working with integers.

Some functions that work on integers are found in Kernel:

Determines if an integer is even.

Determines if integer is odd.

Returns the ordered digits for the given integer.

Returns the extended greatest common divisor of the two given integers.

Performs a floored integer division.

Returns the greatest common divisor of the two given integers.

Computes the modulo remainder of an integer division.

Parses a text representation of an integer.

Computes base raised to power of exponent.

Returns a charlist which corresponds to the text representation of integer in the given base.

Returns a binary which corresponds to the text representation of integer in the given base.

Returns the integer represented by the ordered digits.

Determines if an integer is even.

Returns true if the given integer is an even number, otherwise it returns false.

Allowed in guard clauses.

Determines if integer is odd.

Returns true if the given integer is an odd number, otherwise it returns false.

Allowed in guard clauses.

Returns the ordered digits for the given integer.

An optional base value may be provided representing the radix for the returned digits. This one must be an integer >= 2.

Returns the extended greatest common divisor of the two given integers.

This function uses the extended Euclidean algorithm to return a three-element tuple with the gcd and the coefficients m and n of Bézout's identity such that:

By convention, extended_gcd(0, 0) returns {0, 0, 0}.

Performs a floored integer division.

Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0.

This function performs a floored integer division, which means that the result will always be rounded towards negative infinity.

If you want to perform truncated integer division (rounding towards zero), use Kernel.div/2 instead.

Returns the greatest common divisor of the two given integers.

The greatest common divisor (GCD) of integer1 and integer2 is the largest positive integer that divides both integer1 and integer2 without leaving a remainder.

By convention, gcd(0, 0) returns 0.

Computes the modulo remainder of an integer division.

This function performs a floored division, which means that the result will always have the sign of the divisor.

Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0.

Parses a text representation of an integer.

An optional base to the

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Integer.is_even(10)
true

iex> Integer.is_even(5)
false

iex> Integer.is_even(-10)
true

iex> Integer.is_even(0)
true
```

Example 2 (unknown):
```unknown
iex> Integer.is_odd(5)
true

iex> Integer.is_odd(6)
false

iex> Integer.is_odd(-5)
true

iex> Integer.is_odd(0)
false
```

Example 3 (unknown):
```unknown
iex> Integer.digits(123)
[1, 2, 3]

iex> Integer.digits(170, 2)
[1, 0, 1, 0, 1, 0, 1, 0]

iex> Integer.digits(-170, 2)
[-1, 0, -1, 0, -1, 0, -1, 0]
```

Example 4 (unknown):
```unknown
gcd(a, b) = m*a + n*b
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#openchain-certification

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#update_in/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#use/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_link/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-the-standard-library

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Protocol behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Protocol.html#c:__deriving__/2

**Contents:**
- Protocol behaviour (Elixir v1.19.0)
- Example
- Protocols and Structs
- Fallback to Any
- Multiple implementations
- Types
- Configuration
- Consolidation
- Summary
- Callbacks

Reference and functions for working with protocols.

A protocol specifies an API that should be defined by its implementations. A protocol is defined with Kernel.defprotocol/2 and its implementations with Kernel.defimpl/3.

In Elixir, we have two nouns for checking how many items there are in a data structure: length and size. length means the information must be computed. For example, length(list) needs to traverse the whole list to calculate its length. On the other hand, tuple_size(tuple) and byte_size(binary) do not depend on the tuple and binary size as the size information is precomputed in the data structure.

Although Elixir includes specific functions such as tuple_size, binary_size and map_size, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:

Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:

Finally, we can use the Size protocol to call the correct implementation:

Note that we didn't implement it for lists as we don't have the size information on lists, rather its value needs to be computed with length.

The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol.

It is possible to implement protocols for all Elixir types:

The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like MapSet. We can implement the Size protocol for those types as well:

When implementing a protocol for a struct, the :for option can be omitted if the defimpl/3 call is inside the module that defines the struct:

If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to Any. Conveniences for building implementations on top of existing ones are also available, look at defstruct/1 for more information about deriving protocols.

In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the @fallback_to_any attribute to true in the protocol definition:

The Size protocol can now be implemented for Any:

Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integ

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end
```

Example 2 (python):
```python
defimpl Size, for: BitString do
  def size(binary), do: byte_size(binary)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

Example 3 (javascript):
```javascript
Size.size({1, 2})
# => 2
Size.size(%{key: :value})
# => 1
```

Example 4 (python):
```python
defimpl Size, for: MapSet do
  def size(map_set), do: MapSet.size(map_set)
end
```

---

## Application behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Application.html

**Contents:**
- Application behaviour (Elixir v1.19.0)
- The application environment
    - Application environment in libraries
    - Reading the environment of other applications
- Compile-time environment
- The application callback module
    - use Application
- The application resource file
- The application life cycle
  - Loading applications

A module for working with applications and defining application callbacks.

Applications are the idiomatic way to package software in Erlang/OTP. To get the idea, they are similar to the "library" concept common in other programming languages, but with some additional characteristics.

An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and life cycle. Applications are loaded, started, and stopped. Each application also has its own environment, which provides a unified API for configuring each application.

Developers typically interact with the application environment and its callback module. Therefore those will be the topics we will cover first before jumping into details about the application resource file and life cycle.

Each application has its own environment. The environment is a keyword list that maps atoms to terms. Note that this environment is unrelated to the operating system environment.

By default, the environment of an application is an empty list. In a Mix project's mix.exs file, you can set the :env key in application/0:

Now, in your application, you can read this environment by using functions such as fetch_env!/2 and friends:

In Mix projects, the environment of the application and its dependencies can be overridden via the config/config.exs and config/runtime.exs files. The former is loaded at build-time, before your code compiles, and the latter at runtime, just before your app starts. For example, someone using your application can override its :db_host environment variable as follows:

See the "Configuration" section in the Mix module for more information. You can also change the application environment dynamically by using functions such as put_env/3 and delete_env/2.

If you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read about this anti-pattern.

Each application is responsible for its own environment. Do not use the functions in this module for directly accessing or modifying the environment of other applications. Whenever you change the application environment, Elixir's build tool will only recompile the files that belong to that application. So if you read the application environment of another application, there is a chance you will be depending on outdated configuration, as your file won

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def application do
  [env: [db_host: "localhost"]]
end
```

Example 2 (python):
```python
defmodule MyApp.DBClient do
  def start_link() do
    SomeLib.DBClient.start_link(host: db_host())
  end

  defp db_host do
    Application.fetch_env!(:my_app, :db_host)
  end
end
```

Example 3 (unknown):
```unknown
import Config
config :my_app, :db_host, "db.local"
```

Example 4 (python):
```python
defmodule MyApp.DBClient do
  def start_link() do
    SomeLib.DBClient.start_link(host: db_host())
  end

  defp db_host do
    Application.fetch_env!(:my_app, :db_host)
  end
end
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#t:t/0

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defoverridable/1-example

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binding/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_non_struct_map/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_T/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_tuple/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Float (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Float.html#floor/2

**Contents:**
- Float (Elixir v1.19.0)
- Kernel functions
- Known issues
- Summary
- Types
- Functions
- Types
- precision_range()
- Functions
- ceil(number, precision \\ 0)

Functions for working with floating-point numbers.

For mathematical operations on top of floating-points, see Erlang's :math module.

There are functions related to floating-point numbers on the Kernel module too. Here is a list of them:

There are some very well known problems with floating-point numbers and arithmetic due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.

For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:

There are also other known problems like flooring or rounding numbers. See round/2 and floor/2 for more details about them.

To learn more about floating-point arithmetic visit:

Rounds a float to the smallest float greater than or equal to number.

Rounds a float to the largest float less than or equal to number.

Returns the maximum finite value for a float.

Returns the minimum finite value for a float.

Parses a binary into a float.

Computes base raised to power of exponent.

Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator.

Rounds a floating-point value to an arbitrary number of fractional digits (between 0 and 15).

Returns a charlist which corresponds to the shortest text representation of the given float.

Returns a binary which corresponds to the shortest text representation of the given float.

Rounds a float to the smallest float greater than or equal to number.

ceil/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15).

The operation is performed on the binary floating point, without a conversion to decimal.

The behavior of ceil/2 for floats can be surprising. For example:

One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behavior above.

This function always returns floats. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards.

Rounds a float to the largest float less than or equal to number.

floor/2 also accepts a precision to round a floating-point va

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Float.ceil(-12.52, 2)
-12.51
```

Example 2 (unknown):
```unknown
iex> Float.ceil(34.25)
35.0
iex> Float.ceil(-56.5)
-56.0
iex> Float.ceil(34.251, 2)
34.26
iex> Float.ceil(-0.01)
-0.0
```

Example 3 (unknown):
```unknown
iex> Float.floor(12.52, 2)
12.51
```

Example 4 (unknown):
```unknown
iex> Float.floor(34.25)
34.0
iex> Float.floor(-56.5)
-57.0
iex> Float.floor(34.259, 2)
34.25
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#../0

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#if/2-blocks-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#in/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_w/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#abs/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#trunc/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_S/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#put_in/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_link/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Registry (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Registry.html

**Contents:**
- Registry (Elixir v1.19.0)
- Using in :via
    - With and without metadata
- Using as a dispatcher
- Using as a PubSub
- Registrations
- ETS
- Summary
- Types
- Functions

A local, decentralized and scalable key-value process storage.

It allows developers to lookup one or more processes with a given key. If the registry has :unique keys, a key points to 0 or 1 process. If the registry allows :duplicate keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.

Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation (===/2).

The registry can be used for different purposes, such as name lookups (using the :via option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below.

The registry may also be transparently partitioned, which provides more scalable behavior for running registries on highly concurrent environments with thousands or millions of entries.

Once the registry is started with a given name using Registry.start_link/1, it can be used to register and access named processes using the {:via, Registry, {registry, key}} tuple:

In the previous example, we were not interested in associating a value to the process:

However, in some cases it may be desired to associate a value to the process using the alternate {:via, Registry, {registry, key, value}} tuple:

When using the version of :via tuples with metadata, you can still use the version without metadata to look up the process.

To this point, we have been starting Registry using start_link/1. Typically the registry is started as part of a supervision tree though:

Only registries with unique keys can be used in :via. If the name is already taken, the case-specific start_link function (Agent.start_link/2 in the example above) will return {:error, {:already_started, current_pid}}.

Registry has a dispatch mechanism that allows developers to implement custom dispatch logic triggered from the caller. For example, let's say we have a duplicate registry started as so:

By calling register/3, different processes can register under a given key and associate any value under that key. In this case, let's register the current process under the key "hello" and attach the {IO, :inspect} tuple to it:

Now, an entity interested in dispatching events for a given key may call dispatch/3 passing in the key and a callback. This callback will be invoked with a list of all the valu

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
{:ok, _} = Registry.start_link(keys: :unique, name: MyApp.Registry)
name = {:via, Registry, {MyApp.Registry, "agent"}}
{:ok, _} = Agent.start_link(fn -> 0 end, name: name)
Agent.get(name, & &1)
#=> 0
Agent.update(name, &(&1 + 1))
Agent.get(name, & &1)
#=> 1
```

Example 2 (javascript):
```javascript
Registry.lookup(MyApp.Registry, "agent")
#=> [{self(), nil}]
```

Example 3 (javascript):
```javascript
{:ok, _} = Registry.start_link(keys: :unique, name: MyApp.Registry)
name = {:via, Registry, {MyApp.Registry, "agent", :hello}}
{:ok, agent_pid} = Agent.start_link(fn -> 0 end, name: name)

Registry.lookup(MyApp.Registry, "agent")
#=> [{agent_pid, :hello}]

name_without_meta = {:via, Registry, {MyApp.Registry, "agent"}}
Agent.update(name_without_meta, fn x -> x + 1 end)
Agent.get(name_without_meta, & &1)
#=> 1
```

Example 4 (unknown):
```unknown
{Registry, keys: :unique, name: MyApp.Registry}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defstruct/1-enforcing-keys

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#elem/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## URI (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/URI.html#merge/2

**Contents:**
- URI (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- authority()
- t()
- Functions
- %URI{}
- append_path(uri, path)

Utilities for working with URIs.

This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to RFC 3986.

Additionally, the Erlang :uri_string module provides certain functionalities, such as RFC 3986 compliant URI normalization.

Appends path to the given uri.

Appends query to the given uri.

Checks if character is a reserved one in a URI.

Checks if character is allowed unescaped in a URI.

Checks if character is an unreserved one in a URI.

Percent-unescapes a URI.

Decodes query into a map.

Decodes string as "x-www-form-urlencoded".

Returns the default port for a given scheme.

Registers the default port for the given scheme.

Percent-encodes all characters that require escaping in string.

Encodes enumerable into a query string using encoding.

Encodes string as "x-www-form-urlencoded".

Creates a new URI struct from a URI or a string.

Similar to new/1 but raises URI.Error if an invalid string is given.

Parses a URI into its components, without further validation.

Returns a stream of two-element tuples representing key-value pairs in the given query.

Returns the string representation of the given URI struct.

The fields are defined to match the following URI representation (with field names between brackets):

Note the authority field is deprecated. parse/1 will still populate it for backwards compatibility but you should generally avoid setting or getting it.

Appends path to the given uri.

Path must start with / and cannot contain additional URL components like fragments or query strings. This function further assumes the path is valid and it does not contain a query string or fragment parts.

Appends query to the given uri.

The given query is not automatically encoded, use encode/2 or encode_www_form/1.

Checks if character is a reserved one in a URI.

As specified in RFC 3986, section 2.2, the following characters are reserved: :, /, ?, #, [, ], @, !, $, &, ', (, ), *, +, ,, ;, =

Checks if character is allowed unescaped in a URI.

This is the default used by URI.encode/2 where both reserved and unreserved characters are kept unescaped.

Checks if character is an unreserved one in a URI.

As specified in RFC 3986, section 2.3, the following characters are unreserved:

Percent-unescapes a URI.

Decodes query into a map.

Given a query string in the form of key1=value1&key2=value2..., this function inserts each key-value pair in the quer

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
[scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]
```

Example 2 (unknown):
```unknown
iex> URI.append_path(URI.parse("http://example.com/foo/?x=1"), "/my-path") |> URI.to_string()
"http://example.com/foo/my-path?x=1"

iex> URI.append_path(URI.parse("http://example.com"), "my-path")
** (ArgumentError) path must start with "/", got: "my-path"
```

Example 3 (unknown):
```unknown
iex> URI.append_query(URI.parse("http://example.com/"), "x=1") |> URI.to_string()
"http://example.com/?x=1"

iex> URI.append_query(URI.parse("http://example.com/?x=1"), "y=2") |> URI.to_string()
"http://example.com/?x=1&y=2"

iex> URI.append_query(URI.parse("http://example.com/?x=1"), "x=2") |> URI.to_string()
"http://example.com/?x=1&x=2"
```

Example 4 (unknown):
```unknown
iex> URI.char_reserved?(?+)
true
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#pop_in/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_S/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## File (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/File.html#cp/3

**Contents:**
- File (Elixir v1.19.0)
- Encoding
- API
- Processes and raw files
- Seeking within a file
- Summary
- Types
- Functions
- Types
- encoding_mode()

This module contains functions to manipulate files.

Some of those functions are low-level, allowing the user to interact with files or IO devices, like open/2, copy/3 and others. This module also provides higher level functions that work with filenames and have their naming based on Unix variants. For example, one can copy a file via cp/3 and remove files and directories recursively via rm_rf/1.

Paths given to functions in this module can be either relative to the current working directory (as returned by File.cwd/0), or absolute paths. Shell conventions like ~ are not expanded automatically. To use paths like ~/Downloads, you can use Path.expand/1 or Path.expand/2 to expand your path to an absolute path.

In order to write and read files, one must use the functions in the IO module. By default, a file is opened in binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file, then the slower IO.read/2 and IO.write/2 functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.

Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.

Most of the functions in this module return :ok or {:ok, result} in case of success, {:error, reason} otherwise. Those functions also have a variant that ends with ! which returns the result (instead of the {:ok, result} tuple) in case of success or raises an exception in case it fails. For example:

In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).

Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.

This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.

However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in :raw mode. The options :read_ahead and :delayed_write are also useful when operating on large files or working with files in tight loo

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
File.read("hello.txt")
#=> {:ok, "World"}

File.read("invalid.txt")
#=> {:error, :enoent}

File.read!("hello.txt")
#=> "World"

File.read!("invalid.txt")
#=> raises File.Error
```

Example 2 (javascript):
```javascript
File.write!("example.txt", "Eats, Shoots & Leaves")
file = File.open!("example.txt")
:file.pread(file, 15, 6)
#=> {:ok, "Leaves"}
```

Example 3 (javascript):
```javascript
:file.position(file, 6)
#=> {:ok, 6}
:file.read(file, 6)
#=> {:ok, "Shoots"}
:file.position(file, {:cur, -12})
#=> {:ok, 0}
:file.read(file, 4)
#=> {:ok, "Eats"}
```

Example 4 (javascript):
```javascript
File.cd("bin")
#=> :ok

File.cd("non_existing_dir")
#=> {:error, :enoent}
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#self/0

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_port/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_port/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Enum cheatsheet

**URL:** https://hexdocs.pm/elixir/enum-cheat.html

**Contents:**
- Enum cheatsheet
- Predicates
  - any?(enum, fun)
  - all?(enum, fun)
  - member?(enum, value)
  - empty?(enum)
- Filtering
  - filter(enum, fun)
  - reject(enum, fun)
  - flat_map(enum, fun)

A quick reference into the Enum module, a module for working with collections (known as enumerables). Most of the examples below use the following data structure:

Some examples use the string =~ part operator, which checks the string on the left contains the part on the right.

any? with an empty collection is always false:

all? with an empty collection is always true:

item in enum is equivalent to Enum.member?(enum, item):

This function (also listed below) can be used to transform and filter in one pass, returning empty lists to exclude results:

Filtering can also be done with comprehensions:

Pattern-matching in comprehensions acts as a filter as well:

Mapping can also be done with comprehensions:

You can also filter and map at once:

Enum.each/2 is used exclusively for side-effects.

Reducing can also be done with comprehensions:

You can also filter and reduce at once:

See Enum.count_until/2 to count until a limit.

Frequencies of the last letter of the fruit:

See Enum.count_until/3 to count until a limit with a function.

Note: this should typically be done in one pass using Enum.sum_by/2.

Note: this should typically be done in one pass using Enum.product_by/2.

When sorting structs, use Enum.sort/2 with a module as sorter.

When the sorted by value is a struct, use Enum.sort_by/3 with a module as sorter.

When comparing structs, use Enum.min/2 with a module as sorter.

When comparing structs, use Enum.min_by/3 with a module as sorter.

When comparing structs, use Enum.max/2 with a module as sorter.

When comparing structs, use Enum.max_by/3 with a module as sorter.

Flattening can also be done with comprehensions:

Conversion can also be done with comprehensions:

dedup only removes contiguous duplicates:

Remove contiguous entries given a property:

uniq applies to the whole collection:

Comprehensions also support the uniq: true option.

Get entries which are unique by the last letter of the fruit:

Accessing a list by index in a loop is discouraged.

Group by the last letter of the fruit:

Group by the last letter of the fruit with custom value:

Negative ranges count from the back:

Negative indexes count from the back:

Stops splitting as soon as it is false:

Splits the whole collection:

Negative indexes count from the back:

Negative indexes count from the back:

Results will vary on every call:

Results will vary on every call:

Results will vary on every call:

See Enum.chunk_while/4 for custom chunking.

See Enum.zip/1 for zippin

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
cart = [
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]
```

Example 2 (unknown):
```unknown
iex> Enum.any?(cart, & &1.fruit == "orange")
true
iex> Enum.any?(cart, & &1.fruit == "pear")
false
```

Example 3 (unknown):
```unknown
iex> Enum.any?([], & &1.fruit == "orange")
false
```

Example 4 (unknown):
```unknown
iex> Enum.all?(cart, & &1.count > 0)
true
iex> Enum.all?(cart, & &1.count > 1)
false
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_integer/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#==/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#and/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#**/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_function/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## IO (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/IO.html

**Contents:**
- IO (Elixir v1.19.0)
- IO devices
- IO data
  - Use cases for IO data
  - Chardata
- Summary
- Types
- Functions
- Types
- chardata()

Functions handling input/output (IO).

Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides :stdio and :stderr as shortcuts to Erlang's :standard_io and :standard_error.

The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the String.Chars protocol (as shown in typespecs). For more information on chardata, see the "IO data" section below.

The functions of this module use UNIX-style naming where possible.

An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts:

:stdio - a shortcut for :standard_io, which maps to the current Process.group_leader/0 in Erlang

:stderr - a shortcut for the named process :standard_error provided in Erlang

IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the :file.position/2 function.

IO data is a data type that can be used as a more efficient alternative to binaries in certain situations.

A term of type IO data is a binary or a list containing bytes (integers within the 0..255 range) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary "hello":

The built-in iodata/0 type is defined in terms of iolist/0. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).

IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary.

In this function, creating the email address will copy the username and domain binaries. Now imagine you want to use the resulting email inside another binary:

Every time you concatenate binaries or use interpolation (#{}) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data:

Building IO data is cheaper than concatenating binaries. Concatenating multiple pieces of IO 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
[?h, "el", ["l", [?o]]]
```

Example 2 (unknown):
```unknown
def email(username, domain) do
  username <> "@" <> domain
end
```

Example 3 (javascript):
```javascript
def welcome_message(name, username, domain) do
  "Welcome #{name}, your email is: #{email(username, domain)}"
end

IO.puts(welcome_message("Meg", "meg", "example.com"))
#=> "Welcome Meg, your email is: meg@example.com"
```

Example 4 (javascript):
```javascript
def email(username, domain) do
  [username, ?@, domain]
end

def welcome_message(name, username, domain) do
  ["Welcome ", name, ", your email is: ", email(username, domain)]
end

IO.puts(welcome_message("Meg", "meg", "example.com"))
#=> "Welcome Meg, your email is: meg@example.com"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#def/2-keyword-lists-with-default-arguments

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Float (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Float.html#ceil/2

**Contents:**
- Float (Elixir v1.19.0)
- Kernel functions
- Known issues
- Summary
- Types
- Functions
- Types
- precision_range()
- Functions
- ceil(number, precision \\ 0)

Functions for working with floating-point numbers.

For mathematical operations on top of floating-points, see Erlang's :math module.

There are functions related to floating-point numbers on the Kernel module too. Here is a list of them:

There are some very well known problems with floating-point numbers and arithmetic due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.

For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:

There are also other known problems like flooring or rounding numbers. See round/2 and floor/2 for more details about them.

To learn more about floating-point arithmetic visit:

Rounds a float to the smallest float greater than or equal to number.

Rounds a float to the largest float less than or equal to number.

Returns the maximum finite value for a float.

Returns the minimum finite value for a float.

Parses a binary into a float.

Computes base raised to power of exponent.

Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator.

Rounds a floating-point value to an arbitrary number of fractional digits (between 0 and 15).

Returns a charlist which corresponds to the shortest text representation of the given float.

Returns a binary which corresponds to the shortest text representation of the given float.

Rounds a float to the smallest float greater than or equal to number.

ceil/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15).

The operation is performed on the binary floating point, without a conversion to decimal.

The behavior of ceil/2 for floats can be surprising. For example:

One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behavior above.

This function always returns floats. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards.

Rounds a float to the largest float less than or equal to number.

floor/2 also accepts a precision to round a floating-point va

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Float.ceil(-12.52, 2)
-12.51
```

Example 2 (unknown):
```unknown
iex> Float.ceil(34.25)
35.0
iex> Float.ceil(-56.5)
-56.0
iex> Float.ceil(34.251, 2)
34.26
iex> Float.ceil(-0.01)
-0.0
```

Example 3 (unknown):
```unknown
iex> Float.floor(12.52, 2)
12.51
```

Example 4 (unknown):
```unknown
iex> Float.floor(34.25)
34.0
iex> Float.floor(-56.5)
-57.0
iex> Float.floor(34.259, 2)
34.25
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defp/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_boolean/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_map_key/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#struct/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#tap/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-structural-comparison

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## BadMapError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/BadMapError.html

**Contents:**
- BadMapError exception (Elixir v1.19.0)

An exception raised when a map is expected, but something else was given.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> value = "hello"
iex> %{value | key: "value"}
** (BadMapError) expected a map, got:
...
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#../2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmacrop/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#update_in/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## String.Chars protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/String.Chars.html

**Contents:**
- String.Chars protocol (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- t()
- Functions
- to_string(term)

The String.Chars protocol is responsible for converting a structure to a binary (only if applicable).

The only function required to be implemented is to_string/1, which does the conversion.

The to_string/1 function automatically imported by Kernel invokes this protocol. String interpolation also invokes to_string/1 in its arguments. For example, "foo#{bar}" is the same as "foo" <> to_string(bar).

All the types that implement this protocol.

Converts term to a string.

All the types that implement this protocol.

Converts term to a string.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#def/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#type-checking-and-inference-of-anonymous-functions

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_float/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Code.Fragment (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Code.Fragment.html#lines/1

**Contents:**
- Code.Fragment (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- container_cursor_to_quoted_opts()
- cursor_opts()
- position()
- Functions
- container_cursor_to_quoted(fragment, opts \\ [])

This module provides conveniences for analyzing fragments of textual code and extract available information whenever possible.

This module should be considered experimental.

Options for converting code fragments to quoted expressions.

Options for cursor context functions.

Receives a string and returns a quoted expression with the cursor AST position within its parent expression.

Receives a string and returns the cursor context.

Returns the list of lines in the given string, preserving their line endings.

Receives a string and returns the surround context.

Options for converting code fragments to quoted expressions.

Options for cursor context functions.

Currently, these options are not used but reserved for future extensibility.

Receives a string and returns a quoted expression with the cursor AST position within its parent expression.

This function receives a string with an Elixir code fragment, representing a cursor position, and converts such string to AST with the inclusion of special __cursor__() node representing the cursor position within its container (i.e. its parent).

For example, take this code, which would be given as input:

This function will return the AST equivalent to:

In other words, this function is capable of closing any open brackets and insert the cursor position. Other content at the cursor position which is not a parent is discarded. For example, if this is given as input:

It will return the same AST:

Similarly, if only this is given:

Calls without parenthesis are also supported, as we assume the brackets are implicit.

Tuples, lists, maps, and binaries all retain the cursor position:

Returns the following AST:

Keyword lists (and do-end blocks) are also retained. The following:

For multi-line blocks, all previous lines are preserved.

The AST returned by this function is not safe to evaluate but it can be analyzed and expanded.

Containers (for example, a list):

If an expression is complete, then the whole expression is discarded and only the parent is returned:

this means complete expressions themselves return only the cursor:

Operators are also included from Elixir v1.15:

In order to parse the left-side of -> properly, which appears both in anonymous functions and do-end blocks, the trailing fragment option must be given with the rest of the contents:

:file - the filename to be reported in case of parsing errors. Defaults to "nofile".

:line - the starting line of the string being parsed. Defaults to 1.

:c

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
max(some_value,
```

Example 2 (unknown):
```unknown
max(some_value, __cursor__())
```

Example 3 (unknown):
```unknown
max(some_value, another_val
```

Example 4 (unknown):
```unknown
max(some_value, __cursor__())
```

---

## Code (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Code.html#ensure_loaded/1

**Contents:**
- Code (Elixir v1.19.0)
- Working with files
- Code loading on the Erlang VM
- ensure_compiled/1 and ensure_compiled!/1
- Compilation tracers
- Summary
- Types
- Functions
- Types
- binding()

Utilities for managing code compilation, code evaluation, and code loading.

This module complements Erlang's :code module to add behavior which is specific to Elixir. For functions to manipulate Elixir's AST (rather than evaluating it), see the Macro module.

This module contains three functions for compiling and evaluating files. Here is a summary of them and their behavior:

require_file/2 - compiles a file and tracks its name. It does not compile the file again if it has been previously required.

compile_file/2 - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times.

eval_file/2 - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section.

In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.

compile_file/2 must be used when you are interested in the modules defined in a file, without tracking. eval_file/2 should be used when you are interested in the result of evaluating the file rather than the modules it defines.

The functions above work with Elixir source. If you want to work with modules compiled to bytecode, which have the .beam extension and are typically found below the _build directory of a Mix project, see the functions in Erlang's :code module.

Erlang has two modes to load code: interactive and embedded.

By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.

You can use ensure_loaded/1 (as well as ensure_loaded?/1 and ensure_loaded!/1) to check if a module is loaded before using it and act.

Elixir also includes ensure_compiled/1 and ensure_compiled!/1 functions that are a superset of ensure_loaded/1.

Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded.

When invoked, ensure_compiled/1 and ensure_compiled!/1 halt the compilation of the caller until the module becomes available. Note that the distinction between ensure_compiled/1 and ensure_compiled!/1 is important: if you are using ensure_compiled!/1, you are indicating to the compiler that you can o

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
case Code.ensure_compiled(module) do
  {:module, _} -> module
  {:error, _} -> raise ...
end
```

Example 2 (python):
```python
defmodule MyTracer do
  def trace({:remote_function, _meta, module, name, arity}, env) do
    IO.puts("#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}")
    :ok
  end

  def trace(_event, _env) do
    :ok
  end
end
```

Example 3 (javascript):
```javascript
Code.append_path(".")
#=> true

Code.append_path("/does_not_exist")
#=> false
```

Example 4 (javascript):
```javascript
Code.append_paths([".", "/does_not_exist"])
#=> :ok
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#functions

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#ceil/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#dbg/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_timeout/1-passing-timeouts

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#++/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#var!/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Macro (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Macro.html#to_string/2

**Contents:**
- Macro (Elixir v1.19.0)
    - Evaluating code
- Summary
- Types
- Functions
- Types
- captured_remote_function()
- escape_opts()
- input()
- inspect_atom_opts()

Functions for manipulating AST and implementing macros.

Macros are compile-time constructs that receive Elixir's AST as input and return Elixir's AST as output.

Many of the functions in this module exist precisely to work with Elixir AST, to traverse, query, and transform it.

Let's see a simple example that shows the difference between functions and macros:

Now let's give it a try:

So far they behave the same, as we are passing an integer as argument. But let's see what happens when we pass an expression:

The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See input/0 and output/0 for more information.

To learn more about Elixir's AST and how to build them programmatically, see quote/2.

The functions in this module do not evaluate code. In fact, evaluating code from macros is often an anti-pattern. For code evaluation, see the Code module.

A captured remote function in the format of &Mod.fun/arity

The inputs of a macro

A keyword list of AST metadata.

The output of a macro

Abstract Syntax Tree (AST)

Converts the given string to CamelCase format.

Classifies an atom based on its possible AST placement.

Applies a mod, function, and args at compile-time in caller.

Default backend for Kernel.dbg/2.

Decomposes a local or remote call into its remote part (when provided), function name and argument list.

Recursively escapes a value so it can be inserted into a syntax tree.

Receives an AST node and expands it until it can no longer be expanded.

Expands all literals in ast with the given env.

Expands all literals in ast with the given acc and fun.

Receives an AST node and expands it once.

Generates AST nodes for a given number of required argument variables using Macro.var/2.

Generates AST nodes for a given number of required argument variables using Macro.unique_var/2.

Inspects atom according to different source formats.

Returns true if the given name and arity is an operator.

Returns the path to the node in ast for which fun returns a truthy value.

Pipes expr into the call_args at the given position.

This function behaves like prewalk/2, but performs a depth-first, post-order traversal of quoted expressions.

This functions behaves like prewalk/3, but performs a depth-first, post-order traversal of quoted expressions using an accumulator.

Returns an enumerable that traverses the ast in depth-f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  defmacro macro_inspect(value) do
    IO.inspect(value)
    value
  end

  def fun_inspect(value) do
    IO.inspect(value)
    value
  end
end
```

Example 2 (javascript):
```javascript
import Example

macro_inspect(1)
#=> 1
#=> 1

fun_inspect(1)
#=> 1
#=> 1
```

Example 3 (javascript):
```javascript
macro_inspect(1 + 2)
#=> {:+, [line: 3], [1, 2]}
#=> 3

fun_inspect(1 + 2)
#=> 3
#=> 3
```

Example 4 (unknown):
```unknown
iex> Macro.camelize("foo_bar")
"FooBar"

iex> Macro.camelize("foo/bar")
"Foo.Bar"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#ceil/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_timeout/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmodule/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Code (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Code.html#string_to_quoted/2

**Contents:**
- Code (Elixir v1.19.0)
- Working with files
- Code loading on the Erlang VM
- ensure_compiled/1 and ensure_compiled!/1
- Compilation tracers
- Summary
- Types
- Functions
- Types
- binding()

Utilities for managing code compilation, code evaluation, and code loading.

This module complements Erlang's :code module to add behavior which is specific to Elixir. For functions to manipulate Elixir's AST (rather than evaluating it), see the Macro module.

This module contains three functions for compiling and evaluating files. Here is a summary of them and their behavior:

require_file/2 - compiles a file and tracks its name. It does not compile the file again if it has been previously required.

compile_file/2 - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times.

eval_file/2 - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section.

In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.

compile_file/2 must be used when you are interested in the modules defined in a file, without tracking. eval_file/2 should be used when you are interested in the result of evaluating the file rather than the modules it defines.

The functions above work with Elixir source. If you want to work with modules compiled to bytecode, which have the .beam extension and are typically found below the _build directory of a Mix project, see the functions in Erlang's :code module.

Erlang has two modes to load code: interactive and embedded.

By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.

You can use ensure_loaded/1 (as well as ensure_loaded?/1 and ensure_loaded!/1) to check if a module is loaded before using it and act.

Elixir also includes ensure_compiled/1 and ensure_compiled!/1 functions that are a superset of ensure_loaded/1.

Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded.

When invoked, ensure_compiled/1 and ensure_compiled!/1 halt the compilation of the caller until the module becomes available. Note that the distinction between ensure_compiled/1 and ensure_compiled!/1 is important: if you are using ensure_compiled!/1, you are indicating to the compiler that you can o

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
case Code.ensure_compiled(module) do
  {:module, _} -> module
  {:error, _} -> raise ...
end
```

Example 2 (python):
```python
defmodule MyTracer do
  def trace({:remote_function, _meta, module, name, arity}, env) do
    IO.puts("#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}")
    :ok
  end

  def trace(_event, _env) do
    :ok
  end
end
```

Example 3 (javascript):
```javascript
Code.append_path(".")
#=> true

Code.append_path("/does_not_exist")
#=> false
```

Example 4 (javascript):
```javascript
Code.append_paths([".", "/does_not_exist"])
#=> :ok
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_reference/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defstruct/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#//2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#if/2-one-liner-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#dbg/2-configuring-the-debug-function

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#map_size/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## ArgumentError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/ArgumentError.html

**Contents:**
- ArgumentError exception (Elixir v1.19.0)

An exception raised when an argument to a function is invalid.

You can raise this exception when you want to signal that an argument to a function is invalid. For example, this exception is raised when calling Integer.to_string/1 with an invalid argument:

ArgumentError exceptions have a single field, :message (a String.t/0), which is public and can be accessed freely when reading or creating ArgumentError exceptions.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> Integer.to_string(1.0)
** (ArgumentError) errors were found at the given arguments:
...
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#!/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#then/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_w/2-modifiers

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#put_in/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Typespecs reference

**URL:** https://hexdocs.pm/elixir/typespecs.html#built-in-types

**Contents:**
- Typespecs reference
    - Typespecs are not set-theoretic types
- A simple example
- Types and their syntax
    - Differences with set-theoretic types
  - Basic types
  - Literals
  - Built-in types
  - Remote types
  - Maps

Elixir is in the process of implementing its own type system based on set-theoretic types. Typespecs, which are described in the following document, are a distinct notation for declaring types and specifications based on Erlang. Typespecs may be phased out as the set-theoretic type effort moves forward.

Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:

Type specifications (most often referred to as typespecs) are defined in different contexts using the following attributes:

In addition, you can use @typedoc to document a custom @type definition.

See the "User-defined types" and "Defining a specification" sub-sections below for more information on defining types and typespecs.

In the example above:

We declare a new type (word()) that is equivalent to the string type (String.t()).

We describe the type using a @typedoc, which will be included in the generated documentation.

We specify that the long_word?/1 function takes an argument of type word() and returns a boolean (boolean()), that is, either true or false.

The syntax Elixir provides for type specifications is similar to the one in Erlang. Most of the built-in types provided in Erlang (for example, pid()) are expressed in the same way: pid() (or simply pid). Parameterized types (such as list(integer)) are supported as well and so are remote types (such as Enum.t()). Integers and atom literals are allowed as types (for example, 1, :atom, or false). All other types are built out of unions of predefined types. Some types can also be declared using their syntactical notation, such as [type] for lists, {type1, type2, ...} for tuples and <<_ * _>> for binaries.

The notation to represent the union of types is the pipe |. For example, the typespec type :: atom() | pid() | tuple() creates a type type that can be either an atom, a pid, or a tuple. This is usually called a sum type in other languages

While they do share some similarities, the types below do not map one-to-one to the new types from the set-theoretic type system.

For example, there is no plan to support subsets of the integer() type such as positive, ranges or literals.

Furthermore, set-theoretic types support the full range of set operations, including intersections and negations.

The following literals are also supported in typespecs:

The following types are also provided by Elixir as shortcuts on top 

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
defmodule StringHelpers do
  @typedoc "A word from the dictionary"
  @type word() :: String.t()

  @spec long_word?(word()) :: boolean()
  def long_word?(word) when is_binary(word) do
    String.length(word) > 8
  end
end
```

Example 2 (unknown):
```unknown
type ::
      any()                     # the top type, the set of all terms
      | none()                  # the bottom type, contains no terms
      | atom()
      | map()                   # any map
      | pid()                   # process identifier
      | port()                  # port identifier
      | reference()
      | tuple()                 # tuple of any size

                                ## Numbers
      | float()
      | integer()
      | neg_integer()           # ..., -3, -2, -1
      | non_neg_integer()       # 0, 1, 2, 3, ...
      | pos_integer()           # 1, 2, 3, .
...
```

Example 3 (javascript):
```javascript
type ::                               ## Atoms
      :atom                           # atoms: :foo, :bar, ...
      | true | false | nil            # special atom literals

                                      ## Bitstrings
      | <<>>                          # empty bitstring
      | <<_::size>>                   # size is 0 or a positive integer
      | <<_::_*unit>>                 # unit is an integer from 1 to 256
      | <<_::size, _::_*unit>>

                                      ## (Anonymous) Functions
      | (-> type)                     # zero-arity, returns type
      | (type1
...
```

Example 4 (unknown):
```unknown
@type option :: {:name, String.t} | {:max, pos_integer} | {:min, pos_integer}
@type options :: [option()]
```

---

## Regex (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Regex.html#split/2

**Contents:**
- Regex (Elixir v1.19.0)
- Escapes
  - Non-printing characters
  - Generic character types
- Modifiers
- Captures
- Character classes
- Summary
- Types
- Functions

Provides regular expressions for Elixir.

Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's :re module. More information can be found in the :re module documentation.

Regular expressions in Elixir can be created using the sigils ~r (see sigil_r/2):

A Regex is represented internally as the Regex struct. Therefore, %Regex{} can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. And since regexes are compiled, there is no guarantee two regular expressions from the same source are equal, for example:

may return true or false depending on your machine, endianness, available optimizations and others. You can, however, retrieve the source of a compiled regular expression by accessing the source field, and then compare those directly:

Escape sequences are split into two categories.

\u and \U are not supported. Other escape sequences, such as \ddd for octals, are supported but discouraged.

The modifiers available when creating a Regex are:

:unicode (u) - enables Unicode specific patterns like \p and causes character classes like \w, \W, \s, and the like to also match on Unicode (see examples below in "Character classes"). It expects valid Unicode strings to be given on match

:caseless (i) - adds case insensitivity

:dotall (s) - causes dot to match newlines and also sets newline to (*ANYCRLF).The new line setting, as described in the :re documentation, can be overridden by starting the regular expression pattern with:

:multiline (m) - causes ^ and $ to mark the beginning and end of each line; use \A and \z to match the end or beginning of the string

:extended (x) - whitespace characters are ignored except when escaped or within [..], and allow # to delimit comments

:firstline (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline

:ungreedy (U) - inverts the "greediness" of the regexp (the previous r option is deprecated in favor of U)

Many functions in this module handle what to capture in a regex match via the :capture option. The supported values are:

:all - all captured subpatterns including the complete matching string (this is the default)

:first - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded

:all_but_first - all but the first matching subpattern, i.e. all explicitly captured s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
# A simple regular expression that matches foo anywhere in the string
~r/foo/

# A regular expression with case insensitive and Unicode options
~r/foo/iu
```

Example 2 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/
```

Example 3 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source
```

Example 4 (unknown):
```unknown
iex> String.match?("123", ~r/^[[:alnum:]]+$/)
true
iex> String.match?("123 456", ~r/^[[:alnum:][:blank:]]+$/)
true
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_D/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_monitor/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Compatibility and deprecations

**URL:** https://hexdocs.pm/elixir/compatibility-and-deprecations.html

**Contents:**
- Compatibility and deprecations
- Between non-major Elixir versions
- Between Elixir and Erlang/OTP
- Deprecations
  - Policy
  - Table of deprecations

Elixir is versioned according to a vMAJOR.MINOR.PATCH schema.

Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.

Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:

New releases are announced in the read-only announcements mailing list. All security releases will be tagged with [security].

There are currently no plans for a major v2 release.

Elixir minor and patch releases are backwards compatible: well-defined behaviors and documented APIs in a given version will continue working on future versions.

Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:

Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues.

Bugs: if an API has undesired behavior, a program that depends on the buggy behavior may break if the bug is fixed. We reserve the right to fix such bugs.

Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with --warnings-as-errors) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements.

Imports: new functions may be added to the Kernel module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using import Kernel, except: [...] with a list of all functions you don't want to be imported from Kernel. We reserve the right to do such additions.

In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the "Deprecations" section.

The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.

Erlang/OTP versioning is independent 

*[Content truncated]*

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_struct/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#function_exported?/3-unloaded-modules

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3E/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Process (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Process.html#link/1

**Contents:**
- Process (Elixir v1.19.0)
- Aliases
- Summary
- Types
- Functions
- Types
- alias()
- alias_opt()
- dest()
- process_info_item()

Conveniences for working with processes and the process dictionary.

Besides the functions available in this module, the Kernel module exposes and auto-imports some basic functionality related to processes available through the following functions:

While this module provides low-level conveniences to work with processes, developers typically use abstractions such as Agent, GenServer, Registry, Supervisor and Task for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.

Aliases are a feature introduced in Erlang/OTP 24. An alias is a way to refer to a PID in order to send messages to it. The advantage of using aliases is that they can be deactivated even if the aliased process is still running. If you send a message to a deactivated alias, nothing will happen. This makes request/response scenarios easier to implement.

You can use alias/0 or alias/1 to set an alias, and then you can send messages to that alias like you do with PIDs using send/2. To deactivate an alias, you can use unalias/1. If you send a message to a deactivated alias, nothing will happen.

For example, you could have a process that listens for :ping messages:

Now, another process might ping this process:

If now you deactivate the source_alias and ping the server again, you won't receive any response since the server will send/2 the :pong response to a deactivated alias.

See also the Process Aliases section of the Erlang reference manual.

An alias returned by alias/0 or alias/1.

A process destination.

Creates a process alias.

Creates a process alias.

Tells whether the given process is alive on the local node.

Cancels a timer returned by send_after/3.

Deletes the given key from the process dictionary.

Demonitors the monitor identified by the given reference.

Sends an exit signal with the given reason to pid.

Sets the given flag to value for the calling process.

Sets the given flag to value for the given process pid.

Returns all key-value pairs in the process dictionary.

Returns the value for the given key in the process dictionary, or default if key is not set.

Returns all keys in the process dictionary.

Returns all keys in the process dictionary that have the given value.

Returns the PID of the group leader for the calling process.

Sets the group leader of the given pid to leader.

Puts the calling process into a "hibernation" state.

Returns information about the process identified by pid, or returns nil if

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def server do
  receive do
    {:ping, source_alias} ->
      send(source_alias, :pong)
      server()
  end
end
```

Example 2 (javascript):
```javascript
server = spawn(&server/0)

source_alias = Process.alias()
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
end
#=> :pong
```

Example 3 (javascript):
```javascript
Process.unalias(source_alias)
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
after
  1000 -> :timeout
end
#=> :timeout
```

Example 4 (unknown):
```unknown
alias = Process.alias()
```

---

## Typespecs reference

**URL:** https://hexdocs.pm/elixir/typespecs.html

**Contents:**
- Typespecs reference
    - Typespecs are not set-theoretic types
- A simple example
- Types and their syntax
    - Differences with set-theoretic types
  - Basic types
  - Literals
  - Built-in types
  - Remote types
  - Maps

Elixir is in the process of implementing its own type system based on set-theoretic types. Typespecs, which are described in the following document, are a distinct notation for declaring types and specifications based on Erlang. Typespecs may be phased out as the set-theoretic type effort moves forward.

Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:

Type specifications (most often referred to as typespecs) are defined in different contexts using the following attributes:

In addition, you can use @typedoc to document a custom @type definition.

See the "User-defined types" and "Defining a specification" sub-sections below for more information on defining types and typespecs.

In the example above:

We declare a new type (word()) that is equivalent to the string type (String.t()).

We describe the type using a @typedoc, which will be included in the generated documentation.

We specify that the long_word?/1 function takes an argument of type word() and returns a boolean (boolean()), that is, either true or false.

The syntax Elixir provides for type specifications is similar to the one in Erlang. Most of the built-in types provided in Erlang (for example, pid()) are expressed in the same way: pid() (or simply pid). Parameterized types (such as list(integer)) are supported as well and so are remote types (such as Enum.t()). Integers and atom literals are allowed as types (for example, 1, :atom, or false). All other types are built out of unions of predefined types. Some types can also be declared using their syntactical notation, such as [type] for lists, {type1, type2, ...} for tuples and <<_ * _>> for binaries.

The notation to represent the union of types is the pipe |. For example, the typespec type :: atom() | pid() | tuple() creates a type type that can be either an atom, a pid, or a tuple. This is usually called a sum type in other languages

While they do share some similarities, the types below do not map one-to-one to the new types from the set-theoretic type system.

For example, there is no plan to support subsets of the integer() type such as positive, ranges or literals.

Furthermore, set-theoretic types support the full range of set operations, including intersections and negations.

The following literals are also supported in typespecs:

The following types are also provided by Elixir as shortcuts on top 

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
defmodule StringHelpers do
  @typedoc "A word from the dictionary"
  @type word() :: String.t()

  @spec long_word?(word()) :: boolean()
  def long_word?(word) when is_binary(word) do
    String.length(word) > 8
  end
end
```

Example 2 (unknown):
```unknown
type ::
      any()                     # the top type, the set of all terms
      | none()                  # the bottom type, contains no terms
      | atom()
      | map()                   # any map
      | pid()                   # process identifier
      | port()                  # port identifier
      | reference()
      | tuple()                 # tuple of any size

                                ## Numbers
      | float()
      | integer()
      | neg_integer()           # ..., -3, -2, -1
      | non_neg_integer()       # 0, 1, 2, 3, ...
      | pos_integer()           # 1, 2, 3, .
...
```

Example 3 (javascript):
```javascript
type ::                               ## Atoms
      :atom                           # atoms: :foo, :bar, ...
      | true | false | nil            # special atom literals

                                      ## Bitstrings
      | <<>>                          # empty bitstring
      | <<_::size>>                   # size is 0 or a positive integer
      | <<_::_*unit>>                 # unit is an integer from 1 to 256
      | <<_::size, _::_*unit>>

                                      ## (Anonymous) Functions
      | (-> type)                     # zero-arity, returns type
      | (type1
...
```

Example 4 (unknown):
```unknown
@type option :: {:name, String.t} | {:max, pos_integer} | {:min, pos_integer}
@type options :: [option()]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_monitor/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#1-enhancements

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_c/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#!/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#div/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_N/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction

**URL:** https://hexdocs.pm/elixir/introduction.html

**Contents:**
- Introduction
- Installation
- Interactive mode
- Running scripts

This guide will teach you about Elixir fundamentals - the language syntax, how to define modules, the common data structures in the language, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir's Interactive Shell, called IEx.

If you haven't yet installed Elixir, visit our installation page. Once you are done, you can run elixir --version to get the current Elixir version. The requirements for this guide are:

If you are looking for other resources for learning Elixir, you can also consult the learning page of the official website.

When you install Elixir, you will have three new command line executables: iex, elixir and elixirc.

For now, let's start by running iex (or iex.bat if you are on Windows PowerShell, where iex is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let's warm up with some basic expressions.

Open up iex and type the following expressions:

Please note that some details like version numbers may differ a bit in your session, that's not important. By executing the code above, you should evaluate expressions and see their results. To exit iex press Ctrl+C twice.

It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.

After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:

Save it as simple.exs and execute it with elixir:

iex and elixir are all we need to learn the main language concepts. There is a separate guide named "Mix and OTP guide" that explores how to actually create, manage, and test full-blown Elixir projects. For now, let's move on to learn the basic data types in the language.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
Erlang/OTP 26 [64-bit] [smp:2:2] [...]

Interactive Elixir - press Ctrl+C to exit
iex(1)> 40 + 2
42
iex(2)> "hello" <> " world"
"hello world"
```

Example 2 (unknown):
```unknown
IO.puts("Hello world from Elixir")
```

Example 3 (unknown):
```unknown
$ elixir simple.exs
Hello world from Elixir
```

---

## BadBooleanError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/BadBooleanError.html

**Contents:**
- BadBooleanError exception (Elixir v1.19.0)

An exception raised when a boolean is expected, but something else was given.

This exception is raised by and and or when the first argument is not a boolean:

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> 123 and true
** (BadBooleanError) expected a boolean on left-side of "and", got:
...
```

---

## Code.Fragment (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Code.Fragment.html

**Contents:**
- Code.Fragment (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- container_cursor_to_quoted_opts()
- cursor_opts()
- position()
- Functions
- container_cursor_to_quoted(fragment, opts \\ [])

This module provides conveniences for analyzing fragments of textual code and extract available information whenever possible.

This module should be considered experimental.

Options for converting code fragments to quoted expressions.

Options for cursor context functions.

Receives a string and returns a quoted expression with the cursor AST position within its parent expression.

Receives a string and returns the cursor context.

Returns the list of lines in the given string, preserving their line endings.

Receives a string and returns the surround context.

Options for converting code fragments to quoted expressions.

Options for cursor context functions.

Currently, these options are not used but reserved for future extensibility.

Receives a string and returns a quoted expression with the cursor AST position within its parent expression.

This function receives a string with an Elixir code fragment, representing a cursor position, and converts such string to AST with the inclusion of special __cursor__() node representing the cursor position within its container (i.e. its parent).

For example, take this code, which would be given as input:

This function will return the AST equivalent to:

In other words, this function is capable of closing any open brackets and insert the cursor position. Other content at the cursor position which is not a parent is discarded. For example, if this is given as input:

It will return the same AST:

Similarly, if only this is given:

Calls without parenthesis are also supported, as we assume the brackets are implicit.

Tuples, lists, maps, and binaries all retain the cursor position:

Returns the following AST:

Keyword lists (and do-end blocks) are also retained. The following:

For multi-line blocks, all previous lines are preserved.

The AST returned by this function is not safe to evaluate but it can be analyzed and expanded.

Containers (for example, a list):

If an expression is complete, then the whole expression is discarded and only the parent is returned:

this means complete expressions themselves return only the cursor:

Operators are also included from Elixir v1.15:

In order to parse the left-side of -> properly, which appears both in anonymous functions and do-end blocks, the trailing fragment option must be given with the rest of the contents:

:file - the filename to be reported in case of parsing errors. Defaults to "nofile".

:line - the starting line of the string being parsed. Defaults to 1.

:c

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
max(some_value,
```

Example 2 (unknown):
```unknown
max(some_value, __cursor__())
```

Example 3 (unknown):
```unknown
max(some_value, another_val
```

Example 4 (unknown):
```unknown
max(some_value, __cursor__())
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_C/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_function/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#tl/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## MapSet (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/MapSet.html

**Contents:**
- MapSet (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- internal(value)
- t()
- t(value)
- value()
- Functions

Functions that work on sets.

A set is a data structure that can contain unique elements of any kind, without any particular order. MapSet is the "go to" set data structure in Elixir.

A set can be constructed using MapSet.new/0:

Elements in a set don't have to be of the same type and they can be populated from an enumerable using MapSet.new/1:

Elements can be inserted using MapSet.put/2:

By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op.

A MapSet is represented internally using the %MapSet{} struct. This struct can be used whenever there's a need to pattern match on something being a MapSet:

Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets.

MapSets can also be constructed starting from other collection-type data structures: for example, see MapSet.new/1 or Enum.into/2.

MapSet is built on top of Erlang's :sets (version 2). This means that they share many properties, including logarithmic time complexity. Erlang :sets (version 2) are implemented on top of maps, so see the documentation for Map for more information on its execution time complexity.

Deletes value from map_set.

Returns a set that is map_set1 without the members of map_set2.

Checks if map_set1 and map_set2 have no members in common.

Checks if two sets are equal.

Filters the set by returning only the elements from map_set for which invoking fun returns a truthy value.

Returns a set containing only members that map_set1 and map_set2 have in common.

Checks if map_set contains value.

Creates a set from an enumerable.

Creates a set from an enumerable via the transformation function.

Inserts value into map_set if map_set doesn't already contain it.

Returns a set by excluding the elements from map_set for which invoking fun returns a truthy value.

Returns the number of elements in map_set.

Splits the map_set into two MapSets according to the given function fun.

Checks if map_set1's members are all contained in map_set2.

Returns a set with elements that are present in only one but not both sets.

Converts map_set to a list.

Returns a set containing all members of map_set1 and map_set2.

Deletes value from map_set.

Returns a new set which is a copy of map_set but without value.

Returns a set that is map_set1 without the members of map_set2.

Checks if map_set1 and map_set2 have no mem

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> MapSet.new()
MapSet.new([])
```

Example 2 (unknown):
```unknown
iex> MapSet.new([1, :two, {"three"}])
MapSet.new([1, :two, {"three"}])
```

Example 3 (unknown):
```unknown
iex> MapSet.new([2]) |> MapSet.put(4) |> MapSet.put(0)
MapSet.new([0, 2, 4])
```

Example 4 (unknown):
```unknown
iex> map_set = MapSet.new()
iex> MapSet.put(map_set, "foo")
MapSet.new(["foo"])
iex> map_set |> MapSet.put("foo") |> MapSet.put("foo")
MapSet.new(["foo"])
```

---

## Process (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Process.html#t:dest/0

**Contents:**
- Process (Elixir v1.19.0)
- Aliases
- Summary
- Types
- Functions
- Types
- alias()
- alias_opt()
- dest()
- process_info_item()

Conveniences for working with processes and the process dictionary.

Besides the functions available in this module, the Kernel module exposes and auto-imports some basic functionality related to processes available through the following functions:

While this module provides low-level conveniences to work with processes, developers typically use abstractions such as Agent, GenServer, Registry, Supervisor and Task for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.

Aliases are a feature introduced in Erlang/OTP 24. An alias is a way to refer to a PID in order to send messages to it. The advantage of using aliases is that they can be deactivated even if the aliased process is still running. If you send a message to a deactivated alias, nothing will happen. This makes request/response scenarios easier to implement.

You can use alias/0 or alias/1 to set an alias, and then you can send messages to that alias like you do with PIDs using send/2. To deactivate an alias, you can use unalias/1. If you send a message to a deactivated alias, nothing will happen.

For example, you could have a process that listens for :ping messages:

Now, another process might ping this process:

If now you deactivate the source_alias and ping the server again, you won't receive any response since the server will send/2 the :pong response to a deactivated alias.

See also the Process Aliases section of the Erlang reference manual.

An alias returned by alias/0 or alias/1.

A process destination.

Creates a process alias.

Creates a process alias.

Tells whether the given process is alive on the local node.

Cancels a timer returned by send_after/3.

Deletes the given key from the process dictionary.

Demonitors the monitor identified by the given reference.

Sends an exit signal with the given reason to pid.

Sets the given flag to value for the calling process.

Sets the given flag to value for the given process pid.

Returns all key-value pairs in the process dictionary.

Returns the value for the given key in the process dictionary, or default if key is not set.

Returns all keys in the process dictionary.

Returns all keys in the process dictionary that have the given value.

Returns the PID of the group leader for the calling process.

Sets the group leader of the given pid to leader.

Puts the calling process into a "hibernation" state.

Returns information about the process identified by pid, or returns nil if

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def server do
  receive do
    {:ping, source_alias} ->
      send(source_alias, :pong)
      server()
  end
end
```

Example 2 (javascript):
```javascript
server = spawn(&server/0)

source_alias = Process.alias()
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
end
#=> :pong
```

Example 3 (javascript):
```javascript
Process.unalias(source_alias)
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
after
  1000 -> :timeout
end
#=> :timeout
```

Example 4 (unknown):
```unknown
alias = Process.alias()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#-/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#spawn_monitor/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#put_elem/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#map_size/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Macro (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Macro.html#t:t/0

**Contents:**
- Macro (Elixir v1.19.0)
    - Evaluating code
- Summary
- Types
- Functions
- Types
- captured_remote_function()
- escape_opts()
- input()
- inspect_atom_opts()

Functions for manipulating AST and implementing macros.

Macros are compile-time constructs that receive Elixir's AST as input and return Elixir's AST as output.

Many of the functions in this module exist precisely to work with Elixir AST, to traverse, query, and transform it.

Let's see a simple example that shows the difference between functions and macros:

Now let's give it a try:

So far they behave the same, as we are passing an integer as argument. But let's see what happens when we pass an expression:

The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See input/0 and output/0 for more information.

To learn more about Elixir's AST and how to build them programmatically, see quote/2.

The functions in this module do not evaluate code. In fact, evaluating code from macros is often an anti-pattern. For code evaluation, see the Code module.

A captured remote function in the format of &Mod.fun/arity

The inputs of a macro

A keyword list of AST metadata.

The output of a macro

Abstract Syntax Tree (AST)

Converts the given string to CamelCase format.

Classifies an atom based on its possible AST placement.

Applies a mod, function, and args at compile-time in caller.

Default backend for Kernel.dbg/2.

Decomposes a local or remote call into its remote part (when provided), function name and argument list.

Recursively escapes a value so it can be inserted into a syntax tree.

Receives an AST node and expands it until it can no longer be expanded.

Expands all literals in ast with the given env.

Expands all literals in ast with the given acc and fun.

Receives an AST node and expands it once.

Generates AST nodes for a given number of required argument variables using Macro.var/2.

Generates AST nodes for a given number of required argument variables using Macro.unique_var/2.

Inspects atom according to different source formats.

Returns true if the given name and arity is an operator.

Returns the path to the node in ast for which fun returns a truthy value.

Pipes expr into the call_args at the given position.

This function behaves like prewalk/2, but performs a depth-first, post-order traversal of quoted expressions.

This functions behaves like prewalk/3, but performs a depth-first, post-order traversal of quoted expressions using an accumulator.

Returns an enumerable that traverses the ast in depth-f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  defmacro macro_inspect(value) do
    IO.inspect(value)
    value
  end

  def fun_inspect(value) do
    IO.inspect(value)
    value
  end
end
```

Example 2 (javascript):
```javascript
import Example

macro_inspect(1)
#=> 1
#=> 1

fun_inspect(1)
#=> 1
#=> 1
```

Example 3 (javascript):
```javascript
macro_inspect(1 + 2)
#=> {:+, [line: 3], [1, 2]}
#=> 3

fun_inspect(1 + 2)
#=> 3
#=> 3
```

Example 4 (unknown):
```unknown
iex> Macro.camelize("foo_bar")
"FooBar"

iex> Macro.camelize("foo/bar")
"Foo.Bar"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmodule/2-nesting

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Agent (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Agent.html

**Contents:**
- Agent (Elixir v1.19.0)
- Examples
    - use Agent
- How to supervise
- Name registration
- A word on distributed agents
- Hot code swapping
- Summary
- Types
- Functions

Agents are a simple abstraction around state.

Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time.

The Agent module provides a basic server implementation that allows state to be retrieved and updated via a simple API.

For example, the following agent implements a counter:

Thanks to the agent server process, the counter can be safely incremented concurrently.

When you use Agent, the Agent module will define a child_spec/1 function, so your module can be used as a child in a supervision tree.

Agents provide a segregation between the client and server APIs (similar to GenServers). In particular, the functions passed as arguments to the calls to Agent functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.

Consider these two examples:

The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling do_something_expensive(state) outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values.

An Agent is most commonly started under a supervision tree. When we invoke use Agent, it automatically defines a child_spec/1 function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do:

While one could also simply pass the Counter as a child to the supervisor, such as:

The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example:

and then you can use Counter, {C

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
defmodule Counter do
  use Agent

  def start_link(initial_value) do
    Agent.start_link(fn -> initial_value end, name: __MODULE__)
  end

  def value do
    Agent.get(__MODULE__, & &1)
  end

  def increment do
    Agent.update(__MODULE__, &(&1 + 1))
  end
end
```

Example 2 (javascript):
```javascript
Counter.start_link(0)
#=> {:ok, #PID<0.123.0>}

Counter.value()
#=> 0

Counter.increment()
#=> :ok

Counter.increment()
#=> :ok

Counter.value()
#=> 2
```

Example 3 (unknown):
```unknown
# Compute in the agent/server
def get_something(agent) do
  Agent.get(agent, fn state -> do_something_expensive(state) end)
end

# Compute in the agent/client
def get_something(agent) do
  Agent.get(agent, & &1) |> do_something_expensive()
end
```

Example 4 (unknown):
```unknown
children = [
  {Counter, 0}
]

Supervisor.start_link(children, strategy: :one_for_all)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_integer/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_timeout/1-argument

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Enumerable protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enumerable.html#t:t/0

**Contents:**
- Enumerable protocol (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- acc()
- continuation()
- reducer()
- result()
- slicing_fun()

Enumerable protocol used by Enum and Stream modules.

When you invoke a function in the Enum module, the first argument is usually a collection that must implement this protocol. For example, the expression Enum.map([1, 2, 3], &(&1 * 2)) invokes Enumerable.reduce/3 to perform the reducing operation that builds a mapped list by calling the mapping function &(&1 * 2) on every element in the collection and consuming the element with an accumulated list.

Internally, Enum.map/2 is implemented as follows:

Note that the user-supplied function is wrapped into a reducer/0 function. The reducer/0 function must return a tagged tuple after each step, as described in the acc/0 type. At the end, Enumerable.reduce/3 returns result/0.

This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the zip/1 and zip/2 functions).

This protocol requires four functions to be implemented, reduce/3, count/1, member?/2, and slice/1. The core of the protocol is the reduce/3 function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.

The accumulator value for each step.

A partially applied reduce function.

The reducer function.

The result of the reduce operation.

A slicing function that receives the initial position, the number of elements in the slice, and the step.

All the types that implement this protocol.

An enumerable of elements of type element.

Receives an enumerable and returns a list.

Retrieves the number of elements in the enumerable.

Checks if an element exists within the enumerable.

Reduces the enumerable into an element.

Returns a function that slices the data structure contiguously.

The accumulator value for each step.

It must be a tagged tuple with one of the following "tags":

Depending on the accumulator value, the result returned by Enumerable.reduce/3 will change. Please check the result/0 type documentation for more information.

In case a reducer/0 function returns a :suspend accumulator, it must be explicitly handled by the caller and never leak.

A partially applied reduce function.

The continuati

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def map(enumerable, fun) do
  reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end
  Enumerable.reduce(enumerable, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()
end
```

Example 2 (python):
```python
@spec integers_to_strings(Enumerable.t(integer())) :: Enumerable.t(String.t())
def integers_to_strings(integers) do
  Stream.map(integers, &Integer.to_string/1)
end
```

Example 3 (python):
```python
def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}
def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}
def reduce([], {:cont, acc}, _fun), do: {:done, acc}
def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#+/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#length/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_map/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#function_exported?/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_charlist/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_N/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#if/2-variables-scope

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#bit_size/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Process (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Process.html

**Contents:**
- Process (Elixir v1.19.0)
- Aliases
- Summary
- Types
- Functions
- Types
- alias()
- alias_opt()
- dest()
- process_info_item()

Conveniences for working with processes and the process dictionary.

Besides the functions available in this module, the Kernel module exposes and auto-imports some basic functionality related to processes available through the following functions:

While this module provides low-level conveniences to work with processes, developers typically use abstractions such as Agent, GenServer, Registry, Supervisor and Task for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.

Aliases are a feature introduced in Erlang/OTP 24. An alias is a way to refer to a PID in order to send messages to it. The advantage of using aliases is that they can be deactivated even if the aliased process is still running. If you send a message to a deactivated alias, nothing will happen. This makes request/response scenarios easier to implement.

You can use alias/0 or alias/1 to set an alias, and then you can send messages to that alias like you do with PIDs using send/2. To deactivate an alias, you can use unalias/1. If you send a message to a deactivated alias, nothing will happen.

For example, you could have a process that listens for :ping messages:

Now, another process might ping this process:

If now you deactivate the source_alias and ping the server again, you won't receive any response since the server will send/2 the :pong response to a deactivated alias.

See also the Process Aliases section of the Erlang reference manual.

An alias returned by alias/0 or alias/1.

A process destination.

Creates a process alias.

Creates a process alias.

Tells whether the given process is alive on the local node.

Cancels a timer returned by send_after/3.

Deletes the given key from the process dictionary.

Demonitors the monitor identified by the given reference.

Sends an exit signal with the given reason to pid.

Sets the given flag to value for the calling process.

Sets the given flag to value for the given process pid.

Returns all key-value pairs in the process dictionary.

Returns the value for the given key in the process dictionary, or default if key is not set.

Returns all keys in the process dictionary.

Returns all keys in the process dictionary that have the given value.

Returns the PID of the group leader for the calling process.

Sets the group leader of the given pid to leader.

Puts the calling process into a "hibernation" state.

Returns information about the process identified by pid, or returns nil if

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
def server do
  receive do
    {:ping, source_alias} ->
      send(source_alias, :pong)
      server()
  end
end
```

Example 2 (javascript):
```javascript
server = spawn(&server/0)

source_alias = Process.alias()
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
end
#=> :pong
```

Example 3 (javascript):
```javascript
Process.unalias(source_alias)
send(server, {:ping, source_alias})

receive do
  :pong -> :pong
after
  1000 -> :timeout
end
#=> :timeout
```

Example 4 (unknown):
```unknown
alias = Process.alias()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#length/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#type-checking-of-protocol-dispatch-and-implementations

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## String (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/String.html#count/2

**Contents:**
- String (Elixir v1.19.0)
- Interpolation
- Escape characters
- Unicode and code points
- UTF-8 encoded and encodings
- Grapheme clusters
- String and binary operations
- Self-synchronization
- Compile binary patterns
- Summary

Strings in Elixir are UTF-8 encoded binaries.

Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as "hello" and "héllò".

In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: "this is a string with \"double quotes\"".

You can concatenate two strings with the <>/2 operator:

The functions in this module act according to The Unicode Standard, Version 17.0.0.

Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the #{} syntax:

Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation:

In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised.

Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:

Note it is generally not advised to use \xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \uNNNN. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.

In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.

Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point.

In Elixir you can use a ? in front of a character literal to reveal its code point:

Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. 97 translates to 0061 in hex, and we can represent any Unicode character in an Elixir string by 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> "hello" <> " " <> "world"
"hello world"
```

Example 2 (unknown):
```unknown
iex> name = "joe"
iex> "hello #{name}"
"hello joe"
```

Example 3 (unknown):
```unknown
iex> "2 + 2 = #{2 + 2}"
"2 + 2 = 4"
```

Example 4 (unknown):
```unknown
iex> ?a
97
iex> ?ł
322
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#acknowledgements

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#type-system-improvements

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#throw/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#*/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#sigil_s/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_in/2-functions-as-keys

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## String (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/String.html#slice/2

**Contents:**
- String (Elixir v1.19.0)
- Interpolation
- Escape characters
- Unicode and code points
- UTF-8 encoded and encodings
- Grapheme clusters
- String and binary operations
- Self-synchronization
- Compile binary patterns
- Summary

Strings in Elixir are UTF-8 encoded binaries.

Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as "hello" and "héllò".

In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: "this is a string with \"double quotes\"".

You can concatenate two strings with the <>/2 operator:

The functions in this module act according to The Unicode Standard, Version 17.0.0.

Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the #{} syntax:

Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation:

In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised.

Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:

Note it is generally not advised to use \xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \uNNNN. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.

In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.

Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point.

In Elixir you can use a ? in front of a character literal to reveal its code point:

Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. 97 translates to 0061 in hex, and we can represent any Unicode character in an Elixir string by 

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> "hello" <> " " <> "world"
"hello world"
```

Example 2 (unknown):
```unknown
iex> name = "joe"
iex> "hello #{name}"
"hello joe"
```

Example 3 (unknown):
```unknown
iex> "2 + 2 = #{2 + 2}"
"2 + 2 = 4"
```

Example 4 (unknown):
```unknown
iex> ?a
97
iex> ?ł
322
```

---

## Enum (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Enum.html#take/2

**Contents:**
- Enum (Elixir v1.19.0)
- Summary
- Types
- Functions
- Types
- acc()
- default()
- element()
- index()
- t()

Functions for working with collections (known as enumerables).

In Elixir, an enumerable is any data type that implements the Enumerable protocol. Lists ([1, 2, 3]), Maps (%{foo: 1, bar: 2}) and Ranges (1..3) are common data types used as enumerables:

Many other enumerables exist in the language, such as MapSets and the data type returned by File.stream!/3 which allows a file to be traversed as if it was an enumerable.

For a general overview of all functions in the Enum module, see the Enum cheatsheet.

The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as Enum.map/2. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.

This linear behavior should also be expected on operations like count/1, member?/2, at/2 and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the Enum module is meant to work with a large variety of data types and not all data types can provide optimized behavior.

Finally, note the functions in the Enum module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the Stream module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the Stream module for examples and documentation.

Zero-based index. It can also be a negative integer.

Returns true if all elements in enumerable are truthy.

Returns true if fun.(element) is truthy for all elements in enumerable.

Returns true if at least one element in enumerable is truthy.

Returns true if fun.(element) is truthy for at least one element in enumerable.

Finds the element at the given index (zero-based).

Splits enumerable on every element for which fun returns a new value.

Shortcut to chunk_every(enumerable, count, count).

Returns list of lists containing count elements each, where each new chunk starts step elements into the enumerable.

Chunks the enumerable with fine grained control when every chunk is emitted.

Given an enumerable of enumerables, concatenates the enumerables into a single list.

Concatenates the enumerable on the right with the 

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> Enum.map([1, 2, 3], fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum([1, 2, 3])
6

iex> Enum.map(1..3, fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.sum(1..3)
6

iex> map = %{"a" => 1, "b" => 2}
iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)
[{"a", 2}, {"b", 4}]
```

Example 2 (unknown):
```unknown
iex> Enum.all?([1, 2, 3])
true

iex> Enum.all?([1, nil, 3])
false

iex> Enum.all?([])
true
```

Example 3 (unknown):
```unknown
iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)
true

iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)
false

iex> Enum.all?([], fn _ -> nil end)
true
```

Example 4 (unknown):
```unknown
iex> Enum.any?([false, false, false])
false

iex> Enum.any?([false, true, false])
true

iex> Enum.any?([])
false
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#../2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## System (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/System.html#convert_time_unit/3

**Contents:**
- System (Elixir v1.19.0)
- Time
- Summary
- Types
- Functions
- Types
- cmd_opts()
- shell_opts()
- signal()
- time_unit()

The System module provides functions that interact directly with the VM or the host system.

The System module also provides functions that work with time, returning different times kept by the system with support for different time units.

One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes "time warps". In order to understand how such changes may be harmful, imagine the following code:

If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via System.monotonic_time/0 which never decreases and does not leap:

Generally speaking, the VM provides three time measurements:

os_time/0 - the time reported by the operating system (OS). This time may be adjusted forwards or backwards in time with no limitation;

system_time/0 - the VM view of the os_time/0. The system time and operating system time may not match in case of time warps although the VM works towards aligning them. This time is not monotonic (i.e., it may decrease) as its behavior is configured by the VM time warp mode;

monotonic_time/0 - a monotonically increasing time provided by the Erlang VM. This is not strictly monotonically increasing. Multiple sequential calls of the function may return the same value.

The time functions in this module work in the :native unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the :native unit, to avoid loss of precision, with convert_time_unit/3 being invoked at the end to convert to a specific time unit like :millisecond or :microsecond. See the time_unit/0 type for more information.

For a more complete rundown on the VM support for different times, see the chapter on time and time correction in the Erlang docs.

The time unit to be passed to functions like monotonic_time/1 and others.

Lists command line arguments.

Modifies command line arguments.

Registers a program exit handler function.

Elixir build information.

Executes the given command with args.

Returns the endianness the system was compiled with.

Converts time from time unit from_unit to time unit to_unit.

Current working directory.

Current working directory, exception on error.

Deletes an environment variable.


*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
## DO NOT DO THIS
prev = System.os_time()
# ... execute some code ...
next = System.os_time()
diff = next - prev
```

Example 2 (unknown):
```unknown
## DO THIS
prev = System.monotonic_time()
# ... execute some code ...
next = System.monotonic_time()
diff = next - prev
```

Example 3 (unknown):
```unknown
iex> System.build_info()
%{
  build: "1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)",
  date: "2018-12-24T01:09:21Z",
  otp_release: "21",
  revision: "772a00a0c",
  version: "1.9.0-dev"
}
```

Example 4 (unknown):
```unknown
iex> System.cmd("echo", ["hello"])
{"hello\n", 0}

iex> System.cmd("echo", ["hello"], env: [{"MIX_ENV", "test"}])
{"hello\n", 0}
```

---

## Inspect protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Inspect.html#t:t/0

**Contents:**
- Inspect protocol (Elixir v1.19.0)
- Inspect representation
- Deriving
- Custom implementation
  - Error handling
- Summary
- Types
- Functions
- Types
- t()

The Inspect protocol converts an Elixir data structure into an algebra document.

This is typically done when you want to customize how your own structs are inspected in logs and the terminal.

This documentation refers to implementing the Inspect protocol for your own data structures. To learn more about using inspect, see Kernel.inspect/2 and IO.inspect/2.

There are typically three choices of inspect representation. In order to understand them, let's imagine we have the following User struct:

Print the struct using Elixir's struct syntax, for example: %User{address: "Earth", id: 13, name: "Jane"}. This is the default representation and best choice if all struct fields are public.

Print using the #User<...> notation, for example: #User<id: 13, name: "Jane", ...>. This notation does not emit valid Elixir code and is typically used when the struct has private fields (for example, you may want to hide the field :address to redact person identifiable information).

Print the struct using the expression syntax, for example: User.new(13, "Jane", "Earth"). This assumes there is a User.new/3 function. This option is mostly used as an alternative to option 2 for representing custom data structures, such as MapSet, Date.Range, and others.

You can implement the Inspect protocol for your own structs while adhering to the conventions above. Option 1 is the default representation and you can quickly achieve option 2 by deriving the Inspect protocol. For option 3, you need your custom implementation.

The Inspect protocol can be derived to customize the order of fields (the default is alphabetical) and hide certain fields from structs, so they don't show up in logs, inspects and similar. The latter is especially useful for fields containing private information.

The supported options are:

:only - only include the given fields when inspecting.

:except - remove the given fields when inspecting.

:optional - (since v1.14.0) a list of fields that should not be included when they match their default value. This can be used to simplify the struct representation at the cost of hiding information. Since v1.19.0, the :all atom can be passed to mark all fields as optional.

Whenever :only or :except are used to restrict fields, the struct will be printed using the #User<...> notation, as the struct can no longer be copy and pasted as valid Elixir code. Let's see an example:

If you use only the :optional option, the struct will still be printed as a valid struct.

You can a

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct [:id, :name, :address]
end
```

Example 2 (javascript):
```javascript
defmodule User do
  @derive {Inspect, only: [:id, :name]}
  defstruct [:id, :name, :address]
end

inspect(%User{id: 1, name: "Jane", address: "Earth"})
#=> #User<id: 1, name: "Jane", ...>
```

Example 3 (unknown):
```unknown
defmodule Point do
  @derive {Inspect, optional: [:z]}
  defstruct [x: 0, y: 0, z: 0]
end

inspect(%Point{x: 1})
%Point{x: 1, y: 0}
```

Example 4 (python):
```python
defimpl Inspect, for: MapSet do
  import Inspect.Algebra

  def inspect(map_set, opts) do
    {doc, opts} = to_doc_with_opts(MapSet.to_list(map_set), opts)
    {concat(["MapSet.new(", doc, ")"]), opts}
  end
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#put_in/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defdelegate/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Regex (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Regex.html

**Contents:**
- Regex (Elixir v1.19.0)
- Escapes
  - Non-printing characters
  - Generic character types
- Modifiers
- Captures
- Character classes
- Summary
- Types
- Functions

Provides regular expressions for Elixir.

Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's :re module. More information can be found in the :re module documentation.

Regular expressions in Elixir can be created using the sigils ~r (see sigil_r/2):

A Regex is represented internally as the Regex struct. Therefore, %Regex{} can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. And since regexes are compiled, there is no guarantee two regular expressions from the same source are equal, for example:

may return true or false depending on your machine, endianness, available optimizations and others. You can, however, retrieve the source of a compiled regular expression by accessing the source field, and then compare those directly:

Escape sequences are split into two categories.

\u and \U are not supported. Other escape sequences, such as \ddd for octals, are supported but discouraged.

The modifiers available when creating a Regex are:

:unicode (u) - enables Unicode specific patterns like \p and causes character classes like \w, \W, \s, and the like to also match on Unicode (see examples below in "Character classes"). It expects valid Unicode strings to be given on match

:caseless (i) - adds case insensitivity

:dotall (s) - causes dot to match newlines and also sets newline to (*ANYCRLF).The new line setting, as described in the :re documentation, can be overridden by starting the regular expression pattern with:

:multiline (m) - causes ^ and $ to mark the beginning and end of each line; use \A and \z to match the end or beginning of the string

:extended (x) - whitespace characters are ignored except when escaped or within [..], and allow # to delimit comments

:firstline (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline

:ungreedy (U) - inverts the "greediness" of the regexp (the previous r option is deprecated in favor of U)

Many functions in this module handle what to capture in a regex match via the :capture option. The supported values are:

:all - all captured subpatterns including the complete matching string (this is the default)

:first - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded

:all_but_first - all but the first matching subpattern, i.e. all explicitly captured s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
# A simple regular expression that matches foo anywhere in the string
~r/foo/

# A regular expression with case insensitive and Unicode options
~r/foo/iu
```

Example 2 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/
```

Example 3 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source
```

Example 4 (unknown):
```unknown
iex> String.match?("123", ~r/^[[:alnum:]]+$/)
true
iex> String.match?("123 456", ~r/^[[:alnum:][:blank:]]+$/)
true
```

---

## Regex (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Regex.html#t:t/0

**Contents:**
- Regex (Elixir v1.19.0)
- Escapes
  - Non-printing characters
  - Generic character types
- Modifiers
- Captures
- Character classes
- Summary
- Types
- Functions

Provides regular expressions for Elixir.

Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's :re module. More information can be found in the :re module documentation.

Regular expressions in Elixir can be created using the sigils ~r (see sigil_r/2):

A Regex is represented internally as the Regex struct. Therefore, %Regex{} can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. And since regexes are compiled, there is no guarantee two regular expressions from the same source are equal, for example:

may return true or false depending on your machine, endianness, available optimizations and others. You can, however, retrieve the source of a compiled regular expression by accessing the source field, and then compare those directly:

Escape sequences are split into two categories.

\u and \U are not supported. Other escape sequences, such as \ddd for octals, are supported but discouraged.

The modifiers available when creating a Regex are:

:unicode (u) - enables Unicode specific patterns like \p and causes character classes like \w, \W, \s, and the like to also match on Unicode (see examples below in "Character classes"). It expects valid Unicode strings to be given on match

:caseless (i) - adds case insensitivity

:dotall (s) - causes dot to match newlines and also sets newline to (*ANYCRLF).The new line setting, as described in the :re documentation, can be overridden by starting the regular expression pattern with:

:multiline (m) - causes ^ and $ to mark the beginning and end of each line; use \A and \z to match the end or beginning of the string

:extended (x) - whitespace characters are ignored except when escaped or within [..], and allow # to delimit comments

:firstline (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline

:ungreedy (U) - inverts the "greediness" of the regexp (the previous r option is deprecated in favor of U)

Many functions in this module handle what to capture in a regex match via the :capture option. The supported values are:

:all - all captured subpatterns including the complete matching string (this is the default)

:first - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded

:all_but_first - all but the first matching subpattern, i.e. all explicitly captured s

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
# A simple regular expression that matches foo anywhere in the string
~r/foo/

# A regular expression with case insensitive and Unicode options
~r/foo/iu
```

Example 2 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/
```

Example 3 (unknown):
```unknown
~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source
```

Example 4 (unknown):
```unknown
iex> String.match?("123", ~r/^[[:alnum:]]+$/)
true
iex> String.match?("123 456", ~r/^[[:alnum:][:blank:]]+$/)
true
```

---

## Macro (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Macro.html#dbg/3

**Contents:**
- Macro (Elixir v1.19.0)
    - Evaluating code
- Summary
- Types
- Functions
- Types
- captured_remote_function()
- escape_opts()
- input()
- inspect_atom_opts()

Functions for manipulating AST and implementing macros.

Macros are compile-time constructs that receive Elixir's AST as input and return Elixir's AST as output.

Many of the functions in this module exist precisely to work with Elixir AST, to traverse, query, and transform it.

Let's see a simple example that shows the difference between functions and macros:

Now let's give it a try:

So far they behave the same, as we are passing an integer as argument. But let's see what happens when we pass an expression:

The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See input/0 and output/0 for more information.

To learn more about Elixir's AST and how to build them programmatically, see quote/2.

The functions in this module do not evaluate code. In fact, evaluating code from macros is often an anti-pattern. For code evaluation, see the Code module.

A captured remote function in the format of &Mod.fun/arity

The inputs of a macro

A keyword list of AST metadata.

The output of a macro

Abstract Syntax Tree (AST)

Converts the given string to CamelCase format.

Classifies an atom based on its possible AST placement.

Applies a mod, function, and args at compile-time in caller.

Default backend for Kernel.dbg/2.

Decomposes a local or remote call into its remote part (when provided), function name and argument list.

Recursively escapes a value so it can be inserted into a syntax tree.

Receives an AST node and expands it until it can no longer be expanded.

Expands all literals in ast with the given env.

Expands all literals in ast with the given acc and fun.

Receives an AST node and expands it once.

Generates AST nodes for a given number of required argument variables using Macro.var/2.

Generates AST nodes for a given number of required argument variables using Macro.unique_var/2.

Inspects atom according to different source formats.

Returns true if the given name and arity is an operator.

Returns the path to the node in ast for which fun returns a truthy value.

Pipes expr into the call_args at the given position.

This function behaves like prewalk/2, but performs a depth-first, post-order traversal of quoted expressions.

This functions behaves like prewalk/3, but performs a depth-first, post-order traversal of quoted expressions using an accumulator.

Returns an enumerable that traverses the ast in depth-f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  defmacro macro_inspect(value) do
    IO.inspect(value)
    value
  end

  def fun_inspect(value) do
    IO.inspect(value)
    value
  end
end
```

Example 2 (javascript):
```javascript
import Example

macro_inspect(1)
#=> 1
#=> 1

fun_inspect(1)
#=> 1
#=> 1
```

Example 3 (javascript):
```javascript
macro_inspect(1 + 2)
#=> {:+, [line: 3], [1, 2]}
#=> 3

fun_inspect(1 + 2)
#=> 3
#=> 3
```

Example 4 (unknown):
```unknown
iex> Macro.camelize("foo_bar")
"FooBar"

iex> Macro.camelize("foo/bar")
"Foo.Bar"
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#t:value/0

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## 

**URL:** https://hexdocs.pm/elixir/Elixir.epub

---

## NaiveDateTime (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/NaiveDateTime.html

**Contents:**
- NaiveDateTime (Elixir v1.19.0)
- Comparing naive date times
- Using epochs
- Summary
- Types
- Functions
- Types
- t()
- Functions
- add(naive_datetime, amount_to_add, unit \\ :second)

A NaiveDateTime struct (without a time zone) and functions.

The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the new/2 and new/8 functions or using the ~N (see sigil_N/2) sigil:

The date and time fields in the struct can be accessed directly:

We call them "naive" because this datetime representation does not have a time zone. This means the datetime may not actually exist in certain areas in the world even though it is valid.

For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since NaiveDateTime is not validated against a time zone, such errors would go unnoticed.

Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries.

Comparisons in Elixir using ==/2, >/2, </2 and similar are structural and based on the NaiveDateTime struct fields. For proper comparison between naive datetimes, use the compare/2, after?/2 and before?/2 functions. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum naive datetime of an Enum. For example:

The add/3 and diff/3 functions can be used for computing date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00):

Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).

Adds a specified amount of time to a NaiveDateTime.

Returns true if the first NaiveDateTime is strictly later than the second.

Returns true if the first NaiveDateTime is strictly earlier than the second.

Calculates a NaiveDateTime that is the first moment for the given NaiveDateTime.

Compares two NaiveDateTime structs.

Converts the given naive_datetime from one calendar to another.

Converts the given naive_datetime from one calendar to another.

Subtracts naive_datetime2 from naive_datetime1.

Calculates a NaiveDateTime that is the last moment for the given NaiveDateTime.

Converts an Erlang datetime tuple to a NaiveDateTime struct.

Converts an Erlang datetime tuple to a NaiveDateTime struct.

Converts a number

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> ~N[2000-01-01 23:00:07]
~N[2000-01-01 23:00:07]
```

Example 2 (unknown):
```unknown
iex> naive = ~N[2000-01-01 23:00:07]
iex> naive.year
2000
iex> naive.second
7
```

Example 3 (unknown):
```unknown
iex> Enum.min([~N[2020-01-01 23:00:07], ~N[2000-01-01 23:00:07]], NaiveDateTime)
~N[2000-01-01 23:00:07]
```

Example 4 (unknown):
```unknown
iex> NaiveDateTime.diff(~N[2010-04-17 14:00:00], ~N[1970-01-01 00:00:00])
1271512800

iex> NaiveDateTime.add(~N[1970-01-01 00:00:00], 1_271_512_800)
~N[2010-04-17 14:00:00]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Module behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Module.html

**Contents:**
- Module behaviour (Elixir v1.19.0)
- Module attributes
  - @after_compile
  - @after_verify (since v1.14.0)
  - @before_compile
  - @behaviour
  - @impl (since v1.5.0)
  - @compile
  - @deprecated (since v1.6.0)
  - @doc and @typedoc

Provides functions to deal with modules during compilation time.

It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.

After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the __info__/1 function attached to each compiled module.

Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir:

A hook that will be invoked right after the current module is compiled. Accepts a module or a {module, function_name}. See the "Compile callbacks" section below.

A hook that will be invoked right after the current module is verified for undefined functions, deprecations, etc. Accepts a module or a {module, function_name}. See the "Compile callbacks" section below.

A hook that will be invoked before the module is compiled. Accepts a module or a {module, function_or_macro_name} tuple. See the "Compile callbacks" section below.

Note the British spelling!

Behaviours can be referenced by modules to ensure they implement required specific function signatures defined by @callback.

For example, you could specify a URI.Parser behaviour as follows:

And then a module may use it as:

If the behaviour changes or URI.HTTP does not implement one of the callbacks, a warning will be raised.

For detailed documentation, see the behaviour typespec documentation.

To aid in the correct implementation of behaviours, you may optionally declare @impl for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases:

if you mark a function with @impl when that function is not a callback.

if you don't mark a function with @impl when other functions are marked with @impl. If you mark one function with @impl, you must mark all other callbacks for that behaviour as @impl.

@impl works on a per-context basis. If you generate a function through a macro and mark it with @impl, that won't affect the module where that function is generated in.

@impl also helps with maintainability by making it clear to other developers that the function is implementing a callback.

Using @impl, the example above can be rewritten as:

You may pass either false, true, or a specific behaviour to @impl.

The code is now more readable, as it is now clear which functions are part of yo

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule URI.Parser do
  @doc "Defines a default port"
  @callback default_port() :: integer

  @doc "Parses the given URL"
  @callback parse(uri_info :: URI.t()) :: URI.t()
end
```

Example 2 (python):
```python
defmodule URI.HTTP do
  @behaviour URI.Parser
  def default_port(), do: 80
  def parse(info), do: info
end
```

Example 3 (python):
```python
defmodule URI.HTTP do
  @behaviour URI.Parser

  @impl true
  def default_port(), do: 80

  @impl true
  def parse(info), do: info
end
```

Example 4 (python):
```python
defmodule Foo do
  @behaviour Bar
  @behaviour Baz

  # Will warn if neither Bar nor Baz specify a callback named bar/0.
  @impl true
  def bar(), do: :ok

  # Will warn if Baz does not specify a callback named baz/0.
  @impl Baz
  def baz(), do: :ok
end
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defmodule/2-module-names-and-aliases

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## ArithmeticError exception (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/ArithmeticError.html

**Contents:**
- ArithmeticError exception (Elixir v1.19.0)

An exception raised on invalid arithmetic operations.

For example, this exception is raised if you divide by 0:

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> 1 / 0
** (ArithmeticError) bad argument in arithmetic expression
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Changelog for Elixir v1.19

**URL:** https://hexdocs.pm/elixir/changelog.html#faster-compile-times-in-large-projects

**Contents:**
- Changelog for Elixir v1.19
- Type system improvements
  - Type checking of protocol dispatch and implementations
  - Type checking and inference of anonymous functions
  - Acknowledgements
- Faster compile times in large projects
  - Code loading bottlenecks
  - Parallel compilation of dependencies
- Improved pretty printing algorithm
- Erlang/OTP 28 support

This release also adds type checking when dispatching and implementing protocols.

For example, string interpolation in Elixir uses the String.Chars protocol. If you pass a value that does not implement said protocol, Elixir will now emit a warning accordingly.

Here is an example passing a range, which cannot be converted into a string, to an interpolation:

the above emits the following warnings:

Warnings are also emitted if you pass a data type that does not implement the Enumerable protocol as a generator to for-comprehensions:

Elixir v1.19 can now type infer and type check anonymous functions. Here is a trivial example:

The example above has an obvious typing violation, as the anonymous function expects a map but a string is given. With Elixir v1.19, the following warning is now printed:

Function captures, such as &String.to_integer/1, will also propagate the type as of Elixir v1.19, arising more opportunity for Elixir's type system to catch bugs in our programs.

The type system was made possible thanks to a partnership between CNRS and Remote. The development work is currently sponsored by Fresha, Starfish*, and Dashbit.

This release includes two compiler improvements that can lead up to 4x faster builds in large codebases.

While Elixir has always compiled the given files in project or a dependency in parallel, the compiler would sometimes be unable to use all of the machine resources efficiently. This release addresses two common limitations, delivering performance improvements that scale with codebase size and available CPU cores.

Prior to this release, Elixir would load modules as soon as they were defined. However, because the Erlang part of code loading happens within a single process (the code server), this would make it a bottleneck, reducing parallelization, especially on large projects.

This release makes it so modules are loaded lazily. This reduces the pressure on the code server and the amount of work during compilation, with reports of more than two times faster compilation for large projects. The benefits depend on the codebase size and the number of CPU cores available.

Implementation wise, the parallel compiler already acts as a mechanism to resolve modules during compilation, so we built on that. By making sure the compiler controls both module compilation and module loading, it can also better guarantee deterministic builds.

There are two potential regressions with this approach. The first one happens if you spawn process

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  def my_code(first..last//step = range) do
    "hello #{range}"
  end
end
```

Example 2 (unknown):
```unknown
warning: incompatible value given to string interpolation:

    data

it has type:

    %Range{first: term(), last: term(), step: term()}

but expected a type that implements the String.Chars protocol, it must be one of:

    dynamic(
      %Date{} or %DateTime{} or %NaiveDateTime{} or %Time{} or %URI{} or %Version{} or
        %Version.Requirement{}
    ) or atom() or binary() or float() or integer() or list(term())
```

Example 3 (python):
```python
defmodule Example do
  def my_code(%Date{} = date) do
    for(x <- date, do: x)
  end
end
```

Example 4 (unknown):
```unknown
warning: incompatible value given to for-comprehension:

    x <- date

it has type:

    %Date{year: term(), month: term(), day: term(), calendar: term()}

but expected a type that implements the Enumerable protocol, it must be one of:

    dynamic(
      %Date.Range{} or %File.Stream{} or %GenEvent.Stream{} or %HashDict{} or %HashSet{} or
        %IO.Stream{} or %MapSet{} or %Range{} or %Stream{}
    ) or fun() or list(term()) or non_struct_map()
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#defguard/1-example

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#inspect/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Macro (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Macro.html#escape/1

**Contents:**
- Macro (Elixir v1.19.0)
    - Evaluating code
- Summary
- Types
- Functions
- Types
- captured_remote_function()
- escape_opts()
- input()
- inspect_atom_opts()

Functions for manipulating AST and implementing macros.

Macros are compile-time constructs that receive Elixir's AST as input and return Elixir's AST as output.

Many of the functions in this module exist precisely to work with Elixir AST, to traverse, query, and transform it.

Let's see a simple example that shows the difference between functions and macros:

Now let's give it a try:

So far they behave the same, as we are passing an integer as argument. But let's see what happens when we pass an expression:

The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See input/0 and output/0 for more information.

To learn more about Elixir's AST and how to build them programmatically, see quote/2.

The functions in this module do not evaluate code. In fact, evaluating code from macros is often an anti-pattern. For code evaluation, see the Code module.

A captured remote function in the format of &Mod.fun/arity

The inputs of a macro

A keyword list of AST metadata.

The output of a macro

Abstract Syntax Tree (AST)

Converts the given string to CamelCase format.

Classifies an atom based on its possible AST placement.

Applies a mod, function, and args at compile-time in caller.

Default backend for Kernel.dbg/2.

Decomposes a local or remote call into its remote part (when provided), function name and argument list.

Recursively escapes a value so it can be inserted into a syntax tree.

Receives an AST node and expands it until it can no longer be expanded.

Expands all literals in ast with the given env.

Expands all literals in ast with the given acc and fun.

Receives an AST node and expands it once.

Generates AST nodes for a given number of required argument variables using Macro.var/2.

Generates AST nodes for a given number of required argument variables using Macro.unique_var/2.

Inspects atom according to different source formats.

Returns true if the given name and arity is an operator.

Returns the path to the node in ast for which fun returns a truthy value.

Pipes expr into the call_args at the given position.

This function behaves like prewalk/2, but performs a depth-first, post-order traversal of quoted expressions.

This functions behaves like prewalk/3, but performs a depth-first, post-order traversal of quoted expressions using an accumulator.

Returns an enumerable that traverses the ast in depth-f

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule Example do
  defmacro macro_inspect(value) do
    IO.inspect(value)
    value
  end

  def fun_inspect(value) do
    IO.inspect(value)
    value
  end
end
```

Example 2 (javascript):
```javascript
import Example

macro_inspect(1)
#=> 1
#=> 1

fun_inspect(1)
#=> 1
#=> 1
```

Example 3 (javascript):
```javascript
macro_inspect(1 + 2)
#=> {:+, [line: 3], [1, 2]}
#=> 3

fun_inspect(1 + 2)
#=> 3
#=> 3
```

Example 4 (unknown):
```unknown
iex> Macro.camelize("foo_bar")
"FooBar"

iex> Macro.camelize("foo/bar")
"Foo.Bar"
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_timeout/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Collectable protocol (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Collectable.html

**Contents:**
- Collectable protocol (Elixir v1.19.0)
- Why Collectable?
- Examples
- Summary
- Types
- Functions
- Types
- command()
- t()
- Functions

A protocol to traverse data structures.

The Enum.into/2 function uses this protocol to insert an enumerable into a collection:

The Enumerable protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the Enumerable protocol do not keep shape. For example, passing a map to Enum.map/2 always returns a list.

This design is intentional. Enumerable was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a Range, as it has a fixed shape where only the range limits and step are stored.

The Collectable module was designed to fill the gap left by the Enumerable protocol. Collectable.into/1 can be seen as the opposite of Enumerable.reduce/3. If the functions in Enumerable are about taking values out, then Collectable.into/1 is about collecting those values into a structure.

To show how to manually use the Collectable protocol, let's play with a simplified implementation for MapSet.

To show how the protocol can be implemented, we can again look at the simplified implementation for MapSet. In this implementation "collecting" elements simply means inserting them in the set through MapSet.put/2.

So now we can call Enum.into/2:

All the types that implement this protocol.

Returns an initial accumulator and a "collector" function.

All the types that implement this protocol.

Returns an initial accumulator and a "collector" function.

Receives a collectable which can be used as the initial accumulator that will be passed to the function.

The collector function receives a term and a command and injects the term into the collectable accumulator on every {:cont, term} command.

:done is passed as a command when no further values will be injected. This is useful when there's a need to close resources or normalizing values. A collectable must be returned when the command is :done.

If injection is suddenly interrupted, :halt is passed and the function can return any value as it won't be used.

For examples on how to use the Collectable protocol and into/1 see the module documentation.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
iex> Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}
```

Example 2 (unknown):
```unknown
iex> {initial_acc, collector_fun} = Collectable.into(MapSet.new())
iex> updated_acc = Enum.reduce([1, 2, 3], initial_acc, fn elem, acc ->
...>   collector_fun.(acc, {:cont, elem})
...> end)
iex> collector_fun.(updated_acc, :done)
MapSet.new([1, 2, 3])
```

Example 3 (python):
```python
defimpl Collectable, for: MapSet do
  def into(map_set) do
    collector_fun = fn
      map_set_acc, {:cont, elem} ->
        MapSet.put(map_set_acc, elem)

      map_set_acc, :done ->
        map_set_acc

      _map_set_acc, :halt ->
        :ok
    end

    initial_acc = map_set

    {initial_acc, collector_fun}
  end
end
```

Example 4 (unknown):
```unknown
iex> Enum.into([1, 2, 3], MapSet.new())
MapSet.new([1, 2, 3])
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#binary_slice/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Naming conventions

**URL:** https://hexdocs.pm/elixir/naming-conventions.html#is_-prefix-is_foo

**Contents:**
- Naming conventions
- Casing
- Underscore (_foo)
- Trailing bang (foo!)
- Trailing question mark (foo?)
- is_ prefix (is_foo)
- Special names
  - length and size
  - get, fetch, fetch!
  - compare

This document is a reference of the naming conventions in Elixir, from casing to punctuation characters.

The naming convention is, by definition, a subset of the Elixir syntax. A convention aims to follow and set best practices for language and the community. If instead you want a complete reference into the Elixir syntax, beyond its conventions, see the Syntax reference.

Elixir developers must use snake_case when defining variables, function names, module attributes, and the like:

Aliases, commonly used as module names, are an exception as they must be capitalized and written in CamelCase, like OptionParser. For aliases, capital letters are kept in acronyms, like ExUnit.CaptureIO or Mix.SCM.

Atoms can be written either in :snake_case or :CamelCase, although the convention is to use the snake case version throughout Elixir.

Generally speaking, filenames follow the snake_case convention of the module they define. For example, MyApp should be defined inside the my_app.ex file. However, this is only a convention. At the end of the day any filename can be used as they do not affect the compiled code in any way.

Elixir relies on underscores in different situations.

For example, a value that is not meant to be used must be assigned to _ or to a variable starting with underscore:

Function names may also start with an underscore. Such functions are never imported by default:

Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the __foo__ format. For example, every module in Elixir has an __info__/1 function:

Elixir also includes five special forms that follow the double underscore format: __CALLER__/0, __DIR__/0, __ENV__/0and __MODULE__/0 retrieve compile-time information about the current environment, while __STACKTRACE__/0 retrieves the stacktrace for the current exception.

A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception. They most often exist as a "raising variant" of a function that returns :ok/:error tuples (or nil).

One example is File.read/1 and File.read!/1. File.read/1 will return a success or failure tuple, whereas File.read!/1 will return a plain value or else raise an exception:

The version without ! is preferred when you want to handle different outcomes using pattern matching:

However, if you expect the outcome to always be successful (for instance, if you expect the file always to ex

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
some_map = %{this_is_a_key: "and a value"}
is_map(some_map)
```

Example 2 (unknown):
```unknown
iex> {:ok, _contents} = File.read("README.md")
```

Example 3 (python):
```python
iex> defmodule Example do
...>   def _wont_be_imported do
...>     :oops
...>   end
...> end

iex> import Example
iex> _wont_be_imported()
** (CompileError) iex:1: undefined function _wont_be_imported/0
```

Example 4 (unknown):
```unknown
iex> String.__info__(:functions)
[at: 2, capitalize: 1, chunk: 2, ...]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#summary

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Integer (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Integer.html#floor_div/2

**Contents:**
- Integer (Elixir v1.19.0)
- Summary
- Guards
- Functions
- Guards
- is_even(integer)
- Examples
- is_odd(integer)
- Examples
- Functions

Functions for working with integers.

Some functions that work on integers are found in Kernel:

Determines if an integer is even.

Determines if integer is odd.

Returns the ordered digits for the given integer.

Returns the extended greatest common divisor of the two given integers.

Performs a floored integer division.

Returns the greatest common divisor of the two given integers.

Computes the modulo remainder of an integer division.

Parses a text representation of an integer.

Computes base raised to power of exponent.

Returns a charlist which corresponds to the text representation of integer in the given base.

Returns a binary which corresponds to the text representation of integer in the given base.

Returns the integer represented by the ordered digits.

Determines if an integer is even.

Returns true if the given integer is an even number, otherwise it returns false.

Allowed in guard clauses.

Determines if integer is odd.

Returns true if the given integer is an odd number, otherwise it returns false.

Allowed in guard clauses.

Returns the ordered digits for the given integer.

An optional base value may be provided representing the radix for the returned digits. This one must be an integer >= 2.

Returns the extended greatest common divisor of the two given integers.

This function uses the extended Euclidean algorithm to return a three-element tuple with the gcd and the coefficients m and n of Bézout's identity such that:

By convention, extended_gcd(0, 0) returns {0, 0, 0}.

Performs a floored integer division.

Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0.

This function performs a floored integer division, which means that the result will always be rounded towards negative infinity.

If you want to perform truncated integer division (rounding towards zero), use Kernel.div/2 instead.

Returns the greatest common divisor of the two given integers.

The greatest common divisor (GCD) of integer1 and integer2 is the largest positive integer that divides both integer1 and integer2 without leaving a remainder.

By convention, gcd(0, 0) returns 0.

Computes the modulo remainder of an integer division.

This function performs a floored division, which means that the result will always have the sign of the divisor.

Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0.

Parses a text representation of an integer.

An optional base to the

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> Integer.is_even(10)
true

iex> Integer.is_even(5)
false

iex> Integer.is_even(-10)
true

iex> Integer.is_even(0)
true
```

Example 2 (unknown):
```unknown
iex> Integer.is_odd(5)
true

iex> Integer.is_odd(6)
false

iex> Integer.is_odd(-5)
true

iex> Integer.is_odd(0)
false
```

Example 3 (unknown):
```unknown
iex> Integer.digits(123)
[1, 2, 3]

iex> Integer.digits(170, 2)
[1, 0, 1, 0, 1, 0, 1, 0]

iex> Integer.digits(-170, 2)
[-1, 0, -1, 0, -1, 0, -1, 0]
```

Example 4 (unknown):
```unknown
gcd(a, b) = m*a + n*b
```

---

## Date (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Date.html#compare/2

**Contents:**
- Date (Elixir v1.19.0)
- Comparing dates
- Using epochs
- Summary
- Types
- Functions
- Types
- t()
- Functions
- add(date, days)

A Date struct and functions.

The Date struct contains the fields year, month, day and calendar. New dates can be built with the new/3 function or using the ~D (see sigil_D/2) sigil:

Both new/3 and sigil return a struct where the date fields can be accessed directly:

The functions on this module work with the Date struct as well as any struct that contains the same fields as the Date struct, such as NaiveDateTime and DateTime. Such functions expect Calendar.date/0 in their typespecs (instead of t/0).

Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.

Comparisons in Elixir using ==/2, >/2, </2 and similar are structural and based on the Date struct fields. For proper comparison between dates, use the compare/2, after?/2 and before?/2 functions. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum date of an Enum. For example:

The add/2, diff/2 and shift/2 functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):

Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).

Adds the number of days to the given date.

Returns true if the first date is strictly later than the second.

Returns true if the first date is strictly earlier than the second.

Calculates a date that is the first day of the month for the given date.

Calculates a date that is the first day of the week for the given date.

Compares two date structs.

Converts the given date from its calendar to the given calendar.

Similar to Date.convert/2, but raises an ArgumentError if the conversion between the two calendars is not possible.

Calculates the day-of-era and era for a given calendar date.

Calculates the ordinal day of the week of a given date.

Calculates the day of the year of a given date.

Returns the number of days in the given date month.

Calculates the difference between two dates, in a full number of days.

Calculates a date that is the last day of the month for the given date.

Calculates a date that is the last day of the week for the given date.

Converts an Erlang date tuple to a Date struct.

Converts an Erlang date tuple but raises for invalid dates.

Converts a n

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> ~D[2000-01-01]
~D[2000-01-01]
```

Example 2 (unknown):
```unknown
iex> date = ~D[2000-01-01]
iex> date.year
2000
iex> date.month
1
```

Example 3 (unknown):
```unknown
iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-03-31]
```

Example 4 (unknown):
```unknown
iex> Date.diff(~D[2010-04-17], ~D[1970-01-01])
14716

iex> Date.add(~D[1970-01-01], 14716)
~D[2010-04-17]

iex> Date.shift(~D[1970-01-01], year: 40, month: 3, week: 2, day: 2)
~D[2010-04-17]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#&&/2

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_in/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel.SpecialForms (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.SpecialForms.html

**Contents:**
- Kernel.SpecialForms (Elixir v1.19.0)
- Summary
- Functions
- Functions
- %struct{}
- Pattern matching on struct names
- %{}
- AST representation
- &expr
- Capture

Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.

The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module.

These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2). The macros {}/1 and <<>>/1 are also special forms used to define tuple and binary data structures respectively.

This module also documents macros that return information about Elixir's compilation environment, such as (__ENV__/0, __MODULE__/0, __DIR__/0, __STACKTRACE__/0, and __CALLER__/0).

Additionally, it documents two special forms, __block__/1 and __aliases__/1, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.

Matches on or builds a struct.

Capture operator. Captures or creates an anonymous function.

Dot operator. Defines a remote call, a call to an anonymous function, or an alias.

Internal special form to hold aliases information.

Internal special form for block expressions.

Returns the current calling environment as a Macro.Env struct.

Internal special form for cursor position.

Returns the absolute path of the directory of the current file as a binary.

Returns the current environment information as a Macro.Env struct.

Returns the current module name as an atom or nil otherwise.

Returns the stacktrace for the currently handled exception.

Type operator. Used by types and bitstrings to specify types.

Defines a new bitstring.

Match operator. Matches the value on the right against the pattern on the left.

alias/2 is used to set up aliases, often useful with modules' names.

Matches the given expression against the given clauses.

Evaluates the expression corresponding to the first clause that evaluates to a truthy value.

Defines an anonymous function.

Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.

Imports functions and macros from other modules.

Gets the representation of any expression.

Checks if there is a message matching any of the given clauses in the current process mailbox.

Requires a module in order to use its macros.

Calls the overridden function when overriding it wit

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
defmodule User do
  defstruct name: "john", age: 27
end
```

Example 2 (unknown):
```unknown
%User{} == %{__struct__: User, name: "john", age: 27}
```

Example 3 (javascript):
```javascript
%User{age: 31}
#=> %{__struct__: User, name: "john", age: 31}
```

Example 4 (unknown):
```unknown
%User{age: age} = user
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#node/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_string/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#@/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#def/2-function-names

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Range (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Range.html

**Contents:**
- Range (Elixir v1.19.0)
- Use cases
  - Ranges as collections
  - Ranges as slices
- Definition
- Representation
- Summary
- Types
- Functions
- Types

Ranges represent a sequence of zero, one or many, ascending or descending integers with a common difference called step.

The most common form of creating and matching on ranges is via the first..last and first..last//step notations, auto-imported from Kernel:

Ranges are always inclusive in Elixir. When a step is defined, integers will only belong to the range if they match the step:

When defining a range without a step, the step will be defined based on the first and last position of the range, If last >= first, it will be an increasing range with a step of 1. Otherwise, it is a decreasing range. Note, however, implicit decreasing ranges are deprecated. Therefore, if you need a decreasing range from 3 to 1, prefer to write 3..1//-1 instead.

../0 can also be used as a shortcut to create the range 0..-1//1, also known as the full-slice range:

Ranges typically have two uses in Elixir: as a collection or to represent a slice of another data structure.

Ranges in Elixir are enumerables and therefore can be used with the Enum module:

Ranges may also have a single element:

Or even no elements at all:

The full-slice range, returned by ../0, is an empty collection:

Ranges are also frequently used to slice collections. You can slice strings or any enumerable:

In those cases, the first and last values of the range are mapped to positions in the collections.

If a negative number is given, it maps to a position from the back:

The range 0..-1//1, returned by ../0, returns the collection as is, which is why it is called the full-slice range:

An increasing range first..last//step is a range from first to last increasing by step where step must be a positive integer and all values v must be first <= v and v <= last. Therefore, a range 10..0//1 is an empty range because there is no value v that is 10 <= v and v <= 0.

Similarly, a decreasing range first..last//step is a range from first to last decreasing by step where step must be a negative integer and values v must be first >= v and v >= last. Therefore, a range 0..10//-1 is an empty range because there is no value v that is 0 >= v and v >= 10.

Internally, ranges are represented as structs:

You can access the range fields (first, last, and step) directly but you should not modify nor create ranges by hand. Instead use the proper operators or new/2 and new/3.

Ranges implement the Enumerable protocol with memory efficient versions of all Enumerable callbacks:

Such function calls are efficient memory-wise n

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> 1 in 1..10
true
iex> 5 in 1..10
true
iex> 10 in 1..10
true
```

Example 2 (unknown):
```unknown
iex> 5 in 1..10//2
true
iex> 4 in 1..10//2
false
```

Example 3 (unknown):
```unknown
iex> ..
0..-1//1
```

Example 4 (unknown):
```unknown
iex> Enum.to_list(1..3)
[1, 2, 3]
iex> Enum.to_list(3..1//-1)
[3, 2, 1]
iex> Enum.to_list(1..5//2)
[1, 3, 5]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#tl/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#round/1

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#++/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#module-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Introduction

**URL:** https://hexdocs.pm/elixir/introduction.html#interactive-mode

**Contents:**
- Introduction
- Installation
- Interactive mode
- Running scripts

This guide will teach you about Elixir fundamentals - the language syntax, how to define modules, the common data structures in the language, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir's Interactive Shell, called IEx.

If you haven't yet installed Elixir, visit our installation page. Once you are done, you can run elixir --version to get the current Elixir version. The requirements for this guide are:

If you are looking for other resources for learning Elixir, you can also consult the learning page of the official website.

When you install Elixir, you will have three new command line executables: iex, elixir and elixirc.

For now, let's start by running iex (or iex.bat if you are on Windows PowerShell, where iex is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let's warm up with some basic expressions.

Open up iex and type the following expressions:

Please note that some details like version numbers may differ a bit in your session, that's not important. By executing the code above, you should evaluate expressions and see their results. To exit iex press Ctrl+C twice.

It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.

After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:

Save it as simple.exs and execute it with elixir:

iex and elixir are all we need to learn the main language concepts. There is a separate guide named "Mix and OTP guide" that explores how to actually create, manage, and test full-blown Elixir projects. For now, let's move on to learn the basic data types in the language.

Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (unknown):
```unknown
Erlang/OTP 26 [64-bit] [smp:2:2] [...]

Interactive Elixir - press Ctrl+C to exit
iex(1)> 40 + 2
42
iex(2)> "hello" <> " world"
"hello world"
```

Example 2 (unknown):
```unknown
IO.puts("Hello world from Elixir")
```

Example 3 (unknown):
```unknown
$ elixir simple.exs
Hello world from Elixir
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#hd/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#exit/1-otp-exits

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#is_reference/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#byte_size/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#pop_in/2-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Access behaviour (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Access.html#all/0

**Contents:**
- Access behaviour (Elixir v1.19.0)
- Maps and structs
- Updating nested data structures
- Summary
- Types
- Callbacks
- Functions
- Types
- access_fun(data, current_value)
- container()

Key-based access to data structures.

The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax.

Access supports keyword lists (Keyword) and maps (Map) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist:

This syntax is very convenient as it can be nested arbitrarily:

This works because accessing anything on a nil value, returns nil itself:

While the access syntax is allowed in maps via map[key], if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key], as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined) or if map is nil.

Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax.

In other words, the map[key] syntax is loose, returning nil for missing keys, while the map.key syntax is strict, raising for both nil values and missing keys.

To bridge this gap, Elixir provides the get_in/1 and get_in/2 functions, which are capable of traversing nested data structures, even in the presence of nils:

Notice how, even if no user was found, get_in/1 returned nil. Outside of get_in/1, trying to access the field .age on nil would raise.

The get_in/2 function takes one step further by allowing different accessors to be mixed in. For example, given a user map with the :name and :languages keys, here is how to access the name of all programming languages:

This module provides convenience functions for traversing other structures, like tuples and lists. As we will see next, they can even be used to update nested data structures.

If you want to learn more about the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store, see the Map module.

The access syntax can also be used with the Kernel.put_in/2, Kernel.update_in/2, Kernel.get_and_update_in/2, and Kernel.pop_in/1 macros to further manipulate values in nested data structures:

As shown in the previous section, you can also use the Kernel.put_in/3, Kernel.update_in/3, Kernel.pop_in/2, and Kernel.get_and_update_in/3 functions to provide nested custom accessors. For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase:

See t

*[Content truncated]*

**Examples:**

Example 1 (javascript):
```javascript
iex> keywords = [a: 1, b: 2]
iex> keywords[:a]
1
iex> keywords[:c]
nil

iex> map = %{a: 1, b: 2}
iex> map[:a]
1

iex> star_ratings = %{1.0 => "★", 1.5 => "★☆", 2.0 => "★★"}
iex> star_ratings[1.5]
"★☆"
```

Example 2 (unknown):
```unknown
iex> keywords = [a: 1, b: 2]
iex> keywords[:c][:unknown]
nil
```

Example 3 (unknown):
```unknown
iex> nil[:a]
nil
```

Example 4 (javascript):
```javascript
iex> users = %{"john" => %{age: 27}, "meg" => %{age: 23}}
iex> get_in(users["john"].age)
27
iex> get_in(users["unknown"].age)
nil
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Typespecs reference

**URL:** https://hexdocs.pm/elixir/typespecs.html#basic-types

**Contents:**
- Typespecs reference
    - Typespecs are not set-theoretic types
- A simple example
- Types and their syntax
    - Differences with set-theoretic types
  - Basic types
  - Literals
  - Built-in types
  - Remote types
  - Maps

Elixir is in the process of implementing its own type system based on set-theoretic types. Typespecs, which are described in the following document, are a distinct notation for declaring types and specifications based on Erlang. Typespecs may be phased out as the set-theoretic type effort moves forward.

Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:

Type specifications (most often referred to as typespecs) are defined in different contexts using the following attributes:

In addition, you can use @typedoc to document a custom @type definition.

See the "User-defined types" and "Defining a specification" sub-sections below for more information on defining types and typespecs.

In the example above:

We declare a new type (word()) that is equivalent to the string type (String.t()).

We describe the type using a @typedoc, which will be included in the generated documentation.

We specify that the long_word?/1 function takes an argument of type word() and returns a boolean (boolean()), that is, either true or false.

The syntax Elixir provides for type specifications is similar to the one in Erlang. Most of the built-in types provided in Erlang (for example, pid()) are expressed in the same way: pid() (or simply pid). Parameterized types (such as list(integer)) are supported as well and so are remote types (such as Enum.t()). Integers and atom literals are allowed as types (for example, 1, :atom, or false). All other types are built out of unions of predefined types. Some types can also be declared using their syntactical notation, such as [type] for lists, {type1, type2, ...} for tuples and <<_ * _>> for binaries.

The notation to represent the union of types is the pipe |. For example, the typespec type :: atom() | pid() | tuple() creates a type type that can be either an atom, a pid, or a tuple. This is usually called a sum type in other languages

While they do share some similarities, the types below do not map one-to-one to the new types from the set-theoretic type system.

For example, there is no plan to support subsets of the integer() type such as positive, ranges or literals.

Furthermore, set-theoretic types support the full range of set operations, including intersections and negations.

The following literals are also supported in typespecs:

The following types are also provided by Elixir as shortcuts on top 

*[Content truncated]*

**Examples:**

Example 1 (python):
```python
defmodule StringHelpers do
  @typedoc "A word from the dictionary"
  @type word() :: String.t()

  @spec long_word?(word()) :: boolean()
  def long_word?(word) when is_binary(word) do
    String.length(word) > 8
  end
end
```

Example 2 (unknown):
```unknown
type ::
      any()                     # the top type, the set of all terms
      | none()                  # the bottom type, contains no terms
      | atom()
      | map()                   # any map
      | pid()                   # process identifier
      | port()                  # port identifier
      | reference()
      | tuple()                 # tuple of any size

                                ## Numbers
      | float()
      | integer()
      | neg_integer()           # ..., -3, -2, -1
      | non_neg_integer()       # 0, 1, 2, 3, ...
      | pos_integer()           # 1, 2, 3, .
...
```

Example 3 (javascript):
```javascript
type ::                               ## Atoms
      :atom                           # atoms: :foo, :bar, ...
      | true | false | nil            # special atom literals

                                      ## Bitstrings
      | <<>>                          # empty bitstring
      | <<_::size>>                   # size is 0 or a positive integer
      | <<_::_*unit>>                 # unit is an integer from 1 to 256
      | <<_::size, _::_*unit>>

                                      ## (Anonymous) Functions
      | (-> type)                     # zero-arity, returns type
      | (type1
...
```

Example 4 (unknown):
```unknown
@type option :: {:name, String.t} | {:max, pos_integer} | {:min, pos_integer}
@type options :: [option()]
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#get_in/1-examples

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---

## Kernel (Elixir v1.19.0)

**URL:** https://hexdocs.pm/elixir/Kernel.html#to_timeout/1-passing-durations

**Contents:**
- Kernel (Elixir v1.19.0)
- The standard library
  - Built-in types
  - Data types
  - System modules
  - Protocols
  - Process-based and application-centric functionality
  - Supporting documents
- Guards
- Truthy and falsy values

Kernel is Elixir's default environment.

It mainly consists of:

You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call:

If you don't want to import a function or macro from Kernel, use the :except option and then list the function/macro by arity:

See import/2 for more information on importing.

Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms.

Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).

The following modules handle Elixir built-in data types:

There are two data types without an accompanying module:

Elixir also provides other data types that are built on top of the types listed above. Some of them are:

Modules that interface with the underlying system, such as:

Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library:

The following modules build on top of processes to provide concurrency, fault-tolerance, and more.

Under the "Pages" section in sidebar you will find tutorials, guides, and reference documents that outline Elixir semantics and behaviors in more detail. Those are:

This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example:

The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or. The whole guard is true if all guard expressions will evaluate to true. A more complete introduction to guards is available in the Patterns and guards page.

Besides the booleans true and false, Elixir has the concept of a "truthy" or "falsy" value.

Elixir has functions, like and/2, that only work with booleans, but also functions that work with these truthy/falsy values, like &&/2 and !/1.

The functions in this module perform structural comparison. This allows different data types to be compared using comparis

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
iex> is_number(13)
true
```

Example 2 (unknown):
```unknown
import Kernel, except: [if: 2, is_number: 1]
```

Example 3 (python):
```python
def drive(%User{age: age}) when age >= 16 do
  ...
end
```

Example 4 (unknown):
```unknown
1 < :an_atom
```

---
